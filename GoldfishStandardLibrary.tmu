<TMU|<tuple|1.1.0|2025.0.9>>

<style|<tuple|book|chinese|literate|goldfish|reduced-margins|guile|smart-ref|preview-ref|python>>

<\body>
  <\hide-preamble>
    <assign|scm|<macro|body|<goldfish-lang|<arg|body>>>>

    <assign|scm-chunk|<\macro|name|prev|next|body>
      <\generic-chunk|<arg|name>|<arg|prev>|<arg|next>>
        <with|mode|prog|prog-language|goldfish|font-family|rm|<arg|body>>
      </generic-chunk>
    </macro>>

    <assign|subparagraph|<macro|title|<assign|subparagraph-numbered|<compound|subparagraph-display-numbers>><assign|subparagraph-prefix|<macro|<compound|the-subparagraph>.>><compound|next-subparagraph><compound|subparagraph-clean><compound|subparagraph-header|<arg|title>><compound|subparagraph-toc|<arg|title>><small|<if|<value|subparagraph-numbered>|<compound|subparagraph-numbered-title|<arg|title>>|<compound|subparagraph-unnumbered-title|<arg|title>>>>>>

    <assign|r7rs|<flag|R7RS|dark cyan>>

    <assign|srfi|<flag|SRFI|dark red>>

    <assign|goldfish-version|17.11.15>

    <assign|typehint|<macro|body|<goldfish-lang|<arg|body>>>>

    <assign|font|math=Latin Modern Math,cjk=Noto CJK SC,CMU>
  </hide-preamble>

  <chapter|C++部分开始>

  <section|许可证>

  <\cpp-chunk|src/goldfish.hpp|false|true>
    //

    // Copyright (C) 2024 The Goldfish Scheme Authors

    //

    // Licensed under the Apache License, Version 2.0 (the "License");

    // you may not use this file except in compliance with the License.

    // You may obtain a copy of the License at

    //

    // http://www.apache.org/licenses/LICENSE-2.0

    //

    // Unless required by applicable law or agreed to in writing, software

    // distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    // WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    // License for the specific language governing permissions and limitations

    // under the License.

    //

    \;
  </cpp-chunk>

  <section|实现>

  <paragraph|头文件>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    #include \<less\>algorithm\<gtr\>

    #include \<less\>chrono\<gtr\>

    #include \<less\>cstdint\<gtr\>

    #include \<less\>cstdlib\<gtr\>

    #include \<less\>cstring\<gtr\>

    #include \<less\>iostream\<gtr\>

    #include \<less\>s7.h\<gtr\>

    #include \<less\>string\<gtr\>

    #include \<less\>vector\<gtr\>

    \;

    #include \<less\>tbox/platform/file.h\<gtr\>

    #include \<less\>tbox/platform/path.h\<gtr\>

    #include \<less\>tbox/tbox.h\<gtr\>

    \;

    #ifdef TB_CONFIG_OS_WINDOWS

    #include \<less\>io.h\<gtr\>

    #include \<less\>windows.h\<gtr\>

    #elif TB_CONFIG_OS_MACOSX

    #include \<less\>limits.h\<gtr\>

    #include \<less\>mach-o/dyld.h\<gtr\>

    #else

    #include \<less\>linux/limits.h\<gtr\>

    #endif

    \;

    #if !defined(TB_CONFIG_OS_WINDOWS)

    #include \<less\>errno.h\<gtr\>

    #include \<less\>pwd.h\<gtr\>

    #include \<less\>unistd.h\<gtr\>

    #include \<less\>wordexp.h\<gtr\>

    #endif

    \;
  </cpp-chunk>

  <paragraph|GOLDFISH_VERSION>

  金鱼Scheme的版本，<todo|后续统一使用<value|goldfish-version>这个在导言区预定义的值>。文学编程的Build Buffer功能暂时不支持展开导言区预定义的值。

  <\cpp-chunk|src/goldfish.hpp|true|true>
    #define GOLDFISH_VERSION "17.11.15"

    \;
  </cpp-chunk>

  <paragraph|GOLDFISH_PATH_MAXN>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    #define GOLDFISH_PATH_MAXN TB_PATH_MAXN

    \;
  </cpp-chunk>

  <paragraph|全局变量>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static std::vector\<less\>std::string\<gtr\> command_args= std::vector\<less\>std::string\<gtr\> ();

    \;
  </cpp-chunk>

  <paragraph|goldfish命名空间的开始>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    namespace goldfish {

    using std::cerr;

    using std::cout;

    using std::endl;

    using std::string;

    using std::vector;

    \;
  </cpp-chunk>

  <section|公共辅助函数>

  <subparagraph|string_vector_to_s7_vector>

  将<cpp|std::vector>复制为S7的<scm|vector>。

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline s7_pointer

    string_vector_to_s7_vector (s7_scheme* sc, vector\<less\>string\<gtr\> v) {

    \ \ int \ \ \ \ \ \ \ N \ = v.size ();

    \ \ s7_pointer ret= s7_make_vector (sc, N);

    \ \ for (int i= 0; i \<less\> N; i++) {

    \ \ \ \ s7_vector_set (sc, ret, i, s7_make_string (sc, v[i].c_str ()));

    \ \ }

    \ \ return ret;

    }

    \;
  </cpp-chunk>

  <paragraph|glue_define>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_define (s7_scheme *sc, const char* name, const char* desc, s7_function f, s7_int required, s7_int optional) {

    \ \ s7_pointer cur_env= s7_curlet (sc);

    \ \ s7_pointer func= s7_make_typed_function (sc, name, f, required, optional, false, desc, NULL);

    \ \ s7_define (sc, cur_env, s7_make_symbol (sc, name), func);

    }

    \;
  </cpp-chunk>

  <chapter|boot.scm><label|chapter:scheme_boot>

  S7 Scheme默认并不遵循R7RS，在启动S7 Scheme之后，我们需要做的第一件事就是加载<scm|boot.scm>，实现R7RS的<scm|define-library>和<scm|import>。

  <section|基础文件操作>

  <paragraph|version><index|g_version><typehint|=\<gtr\> string?>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_version (s7_scheme* sc, s7_pointer args) {

    \ \ return s7_make_string (sc, GOLDFISH_VERSION);

    }

    \;
  </cpp-chunk>

  \;

  <value|r7rs><paragraph|file-exists?><index|file-exists?>

  <\goldfish-chunk|goldfish/scheme/boot.scm|false|true>
    (define (file-exists? path)

    \ \ (if (string? path)

    \ \ \ \ (if (not (g_access path 0)) ; F_OK

    \ \ \ \ \ \ #f

    \ \ \ \ \ \ (if (g_access path 1) ; R_OK

    \ \ \ \ \ \ \ \ \ \ #t

    \ \ \ \ \ \ \ \ \ \ (error 'permission-error (string-append "No permission: " path))))

    \ \ \ \ (error 'type-error "(file-exists? path): path should be string")))

    \;
  </goldfish-chunk>

  <value|r7rs><paragraph|delete-file><index|delete-file><typehint|((path string?))>

  <\scm-chunk|goldfish/scheme/boot.scm|true|true>
    (define (delete-file path)

    \ \ (if (not (string? path))

    \ \ \ \ (error 'type-error "(delete-file path): path should be string")

    \ \ \ \ (if (not (file-exists? path))

    \ \ \ \ \ \ (error 'read-error (string-append path " does not exist"))

    \ \ \ \ \ \ (g_delete-file path))))

    \;
  </scm-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_delete_file (s7_scheme* sc, s7_pointer args) {

    \ \ const char* path_c= s7_string (s7_car (args));

    \ \ return s7_make_boolean (sc, tb_file_remove (path_c));

    }

    \;
  </cpp-chunk>

  <paragraph|glue_goldfish>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_goldfish (s7_scheme* sc) {

    \ \ s7_pointer cur_env= s7_curlet (sc);

    \;

    \ \ const char* s_version \ \ \ = "version";

    \ \ const char* d_version \ \ \ = "(version) =\<gtr\> string";

    \ \ const char* s_delete_file= "g_delete-file";

    \ \ const char* d_delete_file= "(g_delete-file string) =\<gtr\> boolean";

    \;

    \ \ s7_define (sc, cur_env, s7_make_symbol (sc, s_version),

    \ \ \ \ \ \ \ \ \ \ \ \ \ s7_make_typed_function (sc, s_version, f_version, 0, 0, false,

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ d_version, NULL));

    \;

    \ \ s7_define (sc, cur_env, s7_make_symbol (sc, s_delete_file),

    \ \ \ \ \ \ \ \ \ \ \ \ \ s7_make_typed_function (sc, s_delete_file, f_delete_file, 1, 0,

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ false, d_delete_file, NULL));

    }

    \;
  </cpp-chunk>

  <section|R7RS函数库>

  <value|r7rs><paragraph|define-library><index|define-library>

  <\scm-chunk|goldfish/scheme/boot.scm|true|true>
    ; 0-clause BSD

    ; Adapted from S7 Scheme's r7rs.scm

    (define-macro (define-library libname . body) ; \|(lib name)\| -\<gtr\> environment

    \ \ `(define ,(symbol (object-\<gtr\>string libname))

    \ \ \ \ \ (with-let (sublet (unlet)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons 'import import)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons '*export* ())

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons 'export (define-macro (,(gensym) . names)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ `(set! *export* (append ',names *export*)))))

    \ \ \ \ \ \ \ ,@body

    \ \ \ \ \ \ \ (apply inlet

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (map (lambda (entry)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (or (member (car entry) '(*export* export import))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (and (pair? *export*)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (not (member (car entry) *export*))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (values)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (curlet))))))

    \;

    (unless (defined? 'r7rs-import-library-filename)

    \ \ (define (r7rs-import-library-filename libs)

    \ \ \ \ (when (pair? libs)

    \ \ \ \ \ \ (let ((lib-filename (let loop ((lib (if (memq (caar libs) '(only except prefix rename))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cadar libs)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (car libs)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (name ""))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (set! name (string-append name (symbol-\<gtr\>string (car lib))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (null? (cdr lib))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (string-append name ".scm")

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (set! name (string-append name "/"))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (cdr lib) name))))))

    \ \ \ \ \ \ \ \ (unless (member lib-filename (*s7* 'file-names))

    \ \ \ \ \ \ \ \ \ \ (load lib-filename)))

    \ \ \ \ \ \ (r7rs-import-library-filename (cdr libs)))))

    \;
  </scm-chunk>

  <value|r7rs><paragraph|import><index|import>

  <\scm-chunk|goldfish/scheme/boot.scm|true|false>
    (define-macro (import . libs)

    \ \ `(begin

    \ \ \ \ \ (r7rs-import-library-filename ',libs)

    \ \ \ \ \ (varlet (curlet)

    \ \ \ \ \ \ \ ,@(map (lambda (lib)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (case (car lib)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((only)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ `((lambda (e names)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (apply inlet

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (map (lambda (name)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons name (e name)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ names)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (symbol-\<gtr\>value (symbol (object-\<gtr\>string (cadr ',lib))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cddr ',lib)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((except)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ `((lambda (e names)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (apply inlet

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (map (lambda (entry)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (member (car entry) names)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (values)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ e)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (symbol-\<gtr\>value (symbol (object-\<gtr\>string (cadr ',lib))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cddr ',lib)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((prefix)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ `((lambda (e prefx)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (apply inlet

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (map (lambda (entry)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons (string-\<gtr\>symbol\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (string-append (symbol-\<gtr\>string prefx)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (symbol-\<gtr\>string (car entry))))\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cdr entry)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ e)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (symbol-\<gtr\>value (symbol (object-\<gtr\>string (cadr ',lib))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (caddr ',lib)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((rename)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ `((lambda (e names)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (apply inlet

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (map (lambda (entry)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let ((info (assoc (car entry) names)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if info

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons (cadr info) (cdr entry))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ entry)))\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ e)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (symbol-\<gtr\>value (symbol (object-\<gtr\>string (cadr ',lib))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cddr ',lib)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ `(let ((sym (symbol (object-\<gtr\>string ',lib))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (not (defined? sym))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (format () "~A not loaded~%" sym)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (symbol-\<gtr\>value sym))))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ libs))))

    \;
  </scm-chunk>

  <chapter|(scheme time)>

  <paragraph|g_current-second><index|g_current-second><typehint|=\<gtr\> inexact?>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_current_second (s7_scheme* sc, s7_pointer args) {

    \ \ // TODO: use std::chrono::tai_clock::now() when using C++ 20

    \ \ tb_timeval_t tp= {0};

    \ \ tb_gettimeofday (&tp, tb_null);

    \ \ s7_double res= (time_t) tp.tv_sec + (tp.tv_usec / 1000000.0);

    \ \ return s7_make_real (sc, res);

    }

    \;
  </cpp-chunk>

  <paragraph|glue_scheme_time>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_scheme_time (s7_scheme* sc) {

    \ \ s7_pointer cur_env= s7_curlet (sc);

    \;

    \ \ const char* s_current_second= "g_current-second";

    \ \ const char* d_current_second= "(g_current-second): () =\<gtr\> double, return the "

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "current unix timestamp in double";

    \ \ s7_define (sc, cur_env, s7_make_symbol (sc, s_current_second),

    \ \ \ \ \ \ \ \ \ \ \ \ \ s7_make_typed_function (sc, s_current_second, f_current_second, 0,

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0, false, d_current_second, NULL));

    }

    \;
  </cpp-chunk>

  <chapter|(scheme process-context)>

  <paragraph|g_get-environment-variable><index|g_get-environment-variable>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_get_environment_variable (s7_scheme* sc, s7_pointer args) {

    #ifdef _MSC_VER

    \ \ std::string path_sep= ";";

    #else

    \ \ std::string path_sep= ":";

    #endif

    \ \ std::string \ \ \ \ \ \ \ \ \ ret;

    \ \ tb_size_t \ \ \ \ \ \ \ \ \ \ \ size \ \ \ \ \ \ = 0;

    \ \ const char* \ \ \ \ \ \ \ \ \ key \ \ \ \ \ \ \ = s7_string (s7_car (args));

    \ \ tb_environment_ref_t environment= tb_environment_init ();

    \ \ if (environment) {

    \ \ \ \ size= tb_environment_load (environment, key);

    \ \ \ \ if (size \<gtr\>= 1) {

    \ \ \ \ \ \ tb_for_all_if (tb_char_t const*, value, environment, value) {

    \ \ \ \ \ \ \ \ ret.append (value).append (path_sep);

    \ \ \ \ \ \ }

    \ \ \ \ }

    \ \ }

    \ \ tb_environment_exit (environment);

    \ \ if (size == 0) { // env key not found

    \ \ \ \ return s7_make_boolean (sc, false);

    \ \ }

    \ \ else {

    \ \ \ \ return s7_make_string (sc, ret.substr (0, ret.size () - 1).c_str ());

    \ \ }

    }

    \;
  </cpp-chunk>

  <paragraph|g_command-line><index|g_command-line>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_command_line (s7_scheme* sc, s7_pointer args) {

    \ \ s7_pointer ret = s7_nil (sc);

    \ \ int \ \ \ \ \ \ \ size= command_args.size ();

    \ \ for (int i= size - 1; i \<gtr\>= 0; i--) {

    \ \ \ \ ret= s7_cons (sc, s7_make_string (sc, command_args[i].c_str ()), ret);

    \ \ }

    \ \ return ret;

    }

    \;
  </cpp-chunk>

  <paragraph|glue_scheme_process_context>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_unset_environment_variable (s7_scheme* sc, s7_pointer args) {

    \ \ const char* env_name= s7_string (s7_car (args));

    \ \ return s7_make_boolean (sc, tb_environment_remove (env_name));

    }

    \;

    inline void

    glue_scheme_process_context (s7_scheme* sc) {

    \ \ s7_pointer cur_env= s7_curlet (sc);

    \;

    \ \ const char* s_get_environment_variable= "g_get-environment-variable";

    \ \ const char* d_get_environment_variable=

    \ \ \ \ \ \ "(g_get-environemt-variable string) =\<gtr\> string";

    \ \ const char* s_command_line= "g_command-line";

    \ \ const char* d_command_line= "(g_command-line) =\<gtr\> string";

    \;

    \ \ s7_define (sc, cur_env, s7_make_symbol (sc, s_get_environment_variable),

    \ \ \ \ \ \ \ \ \ \ \ \ \ s7_make_typed_function (sc, s_get_environment_variable,

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ f_get_environment_variable, 1, 0, false,

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ d_get_environment_variable, NULL));

    \ \ s7_define (sc, cur_env, s7_make_symbol (sc, s_command_line),

    \ \ \ \ \ \ \ \ \ \ \ \ \ s7_make_typed_function (sc, s_command_line, f_command_line, 0, 0,

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ false, d_command_line, NULL));

    }

    \;
  </cpp-chunk>

  <chapter|(liii base64)>

  <section|协议>

  <\scm-chunk|goldfish/liii/base64.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/base64-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/base64.scm|true|true>
    (define-library (liii base64)

    (import (liii base)

    \ \ \ \ \ \ \ \ (liii bitwise))

    (export

    \ \ string-base64-encode bytevector-base64-encode base64-encode

    \ \ string-base64-decode bytevector-base64-decode base64-decode

    )

    (begin
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/base64-test.scm|true|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii base64))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|Base64编解码介绍>

  Base64编码是一种将任意字节序列编码为可打印字符的方式，其编码和解码的过程如下：

  <paragraph*|编码的长度计算：>

  Base64的编码长度与输入数据的长度相关，长度计算公式为：

  <equation*|<with|mode|text|length(output)>=<around*|\<lceil\>|<frac|<with|mode|text|length(input)>|3>|\<rceil\>>\<times\>4>

  其中，输入的每3个字节被转换为4个Base64字符。如果输入的字节数不是3的倍数，会在编码后用<code*|=>符号填充，保证输出长度始终是4的倍数。

  <paragraph*|输入数据的分组与填充：>

  <\big-table|<scm|<tabular|<tformat|<table|<row|<cell|b1>|<cell|b2>|<cell|b3>>|<row|<cell|0-255>|<cell|0-255>|<cell|0-255>>|<row|<cell|0-255>|<cell|0-255>|<cell|#f>>|<row|<cell|0-255>|<cell|#f>|<cell|#f>>>>>>>
    最后一组不足的元素需要设置为<scm|#f><label|table:16.1>
  </big-table>

  输入的字节流被分为每组3个字节进行编码。对于不足3个字节的最后一组，根据不同情况补充<code*|#f>（表示填充字节）。<smart-ref|table:16.1>展示了3种情况：

  <\itemize>
    <item>如果有3个字节，则正常处理。

    <item>如果有2个字节，则第三个字节补充为<code*|#f>。

    <item>如果只有1个字节，则后两个字节补充为<code*|#f>。
  </itemize>

  <paragraph*|映射规则：>

  每组3个字节 <math|<around*|[|b<rsub|1>,b<rsub|2>,b<rsub|3>|]>> 将映射为4个Base64字符 <math|<around*|[|c<rsub|1>,c<rsub|2>,c<rsub|3>,c<rsub|4>|]>>，其中，Base64字符的取值范围是字母、数字、<code*|+>、<code*|/>，以及可能的填充符号<code*|=>。映射的具体规则如下：

  <\itemize>
    <item>将3个字节（24位）按6位一组，分成4个部分，每个部分对应一个Base64字符。

    <item>如果不足3个字节（即有填充的情况），则最后一个或两个Base64字符会用<code*|=>替代。
  </itemize>

  <paragraph*|例子：>

  假设输入为"Man"，其ASCII值为<math|77,97,110>，其二进制表示为：

  <equation*|77=01001101,97=01100001,110=01101110>

  将24位二进制分为4组，每组6位：

  <equation*|010011,010110,000101,<with|mode|text|>101110>

  转换为Base64字符，分别对应<code*|T>, <code*|W>, <code*|F>, <code*|u>。因此，"Man"的Base64编码为<code*|TWFu>。

  解码时，过程反过来：将Base64字符转换为6位二进制，再拼接回原始的字节序列。

  Base64编码的特点是保持输入的可读性并使其适合传输，但相较于原始数据，会增加大约33%的大小。

  <section|实现>

  <paragraph|bytevector-base64-encode><index|bytevector-base64-encode>

  <paragraph|string-base64-encode><index|string-base64-encode>

  <paragraph|base64-encode><index|base64-encode>

  <\scm-chunk|goldfish/liii/base64.scm|true|true>
    (define-constant BYTE2BASE64_BV

    \ \ (string-\<gtr\>utf8 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"))

    \;

    (define-constant BASE64_PAD_BYTE

    \ \ (char-\<gtr\>integer #\\=))

    \;

    (define bytevector-base64-encode

    \ \ (typed-lambda ((bv bytevector?))

    \ \ \ \ (define (encode b1 b2 b3)

    \ \ \ \ \ \ (let* ((p1 b1)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (p2 (if b2 b2 0))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (p3 (if b3 b3 0))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (combined (bitwise-ior (ash p1 16) (ash p2 8) p3))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (c1 (bitwise-and (ash combined -18) #x3F))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (c2 (bitwise-and (ash combined -12) #x3F))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (c3 (bitwise-and (ash combined -6) #x3F))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (c4 (bitwise-and combined #x3F)))

    \ \ \ \ \ \ \ \ (values

    \ \ \ \ \ \ \ \ \ \ (BYTE2BASE64_BV c1)

    \ \ \ \ \ \ \ \ \ \ (BYTE2BASE64_BV c2)

    \ \ \ \ \ \ \ \ \ \ (if b2 (BYTE2BASE64_BV c3) BASE64_PAD_BYTE)

    \ \ \ \ \ \ \ \ \ \ (if b3 (BYTE2BASE64_BV c4) BASE64_PAD_BYTE))))

    \ \ \ \ 

    \ \ \ \ (let* ((input-N (bytevector-length bv))

    \ \ \ \ \ \ \ \ \ \ \ (output-N (* 4 (ceiling (/ input-N 3))))

    \ \ \ \ \ \ \ \ \ \ \ (output (make-bytevector output-N)))

    \ \ \ \ \ \ (let loop ((i 0) (j 0))

    \ \ \ \ \ \ \ \ (when (\<less\> i input-N)

    \ \ \ \ \ \ \ \ \ \ (let* ((b1 (bv i))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (b2 (if (\<less\> (+ i 1) input-N) (bv (+ i 1)) #f))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (b3 (if (\<less\> (+ i 2) input-N) (bv (+ i 2)) #f)))

    \ \ \ \ \ \ \ \ \ \ \ \ (receive (r1 r2 r3 r4) (encode b1 b2 b3)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (bytevector-u8-set! output j r1)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (bytevector-u8-set! output (+ j 1) r2)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (bytevector-u8-set! output (+ j 2) r3)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (bytevector-u8-set! output (+ j 3) r4)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 3) (+ j 4))))))

    \ \ \ \ \ \ output)))

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/base64.scm|true|true>
    (define string-base64-encode

    \ \ (typed-lambda ((str string?))

    \ \ \ \ (utf8-\<gtr\>string (bytevector-base64-encode (string-\<gtr\>utf8 str)))))

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/base64.scm|true|true>
    (define (base64-encode x)

    \ \ (cond ((string? x)

    \ \ \ \ \ \ \ \ \ (string-base64-encode x))

    \ \ \ \ \ \ \ \ ((bytevector? x)

    \ \ \ \ \ \ \ \ \ (bytevector-base64-encode x))

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (type-error "input must be string or bytevector"))))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/base64-test.scm|true|true>
    (check (base64-encode "") =\<gtr\> "")

    (check (base64-encode "a") =\<gtr\> "YQ==")

    (check (base64-encode "z") =\<gtr\> "eg==")

    (check (base64-encode "f") =\<gtr\> "Zg==")

    (check (base64-encode "fo") =\<gtr\> "Zm8=")

    (check (base64-encode "foo") =\<gtr\> "Zm9v")

    (check (base64-encode "foob") =\<gtr\> "Zm9vYg==")

    (check (base64-encode "fooba") =\<gtr\> "Zm9vYmE=")

    (check (base64-encode "foobar") =\<gtr\> "Zm9vYmFy")

    \;

    (check-catch 'type-error (base64-encode 1))

    \;
  </scm-chunk>

  <paragraph|bytevector-base64-decode><index|bytevector-base64-decode>

  <paragraph|string-base64-decode><index|string-base64-decode>

  <paragraph|base64-decode><index|base64-decode>

  <\scm-chunk|goldfish/liii/base64.scm|true|true>
    (define-constant BASE64_TO_BYTE_V

    \ \ (let1 byte2base64-N (bytevector-length BYTE2BASE64_BV)

    \ \ \ \ (let loop ((i 0) (v (make-vector 256 -1)))

    \ \ \ \ \ \ (if (\<less\> i byte2base64-N)

    \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ (vector-set! v (BYTE2BASE64_BV i) i)

    \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) v))

    \ \ \ \ \ \ \ \ \ \ v))))

    \;

    (define (bytevector-base64-decode bv)

    \ \ (define (decode c1 c2 c3 c4)

    \ \ \ \ (let* ((b1 (BASE64_TO_BYTE_V c1))

    \ \ \ \ \ \ \ \ \ \ \ (b2 (BASE64_TO_BYTE_V c2))

    \ \ \ \ \ \ \ \ \ \ \ (b3 (BASE64_TO_BYTE_V c3))

    \ \ \ \ \ \ \ \ \ \ \ (b4 (BASE64_TO_BYTE_V c4)))

    \ \ \ \ \ \ (if (or (negative? b1) (negative? b2)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (and (negative? b3) (!= c3 BASE64_PAD_BYTE))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (and (negative? b4) (!= c4 BASE64_PAD_BYTE)))

    \ \ \ \ \ \ \ \ \ \ (value-error "Invalid base64 input")

    \ \ \ \ \ \ \ \ \ \ (values

    \ \ \ \ \ \ \ \ \ \ \ \ (bitwise-ior (ash b1 2) (ash b2 -4))

    \ \ \ \ \ \ \ \ \ \ \ \ (bitwise-and (bitwise-ior (ash b2 4) (ash b3 -2)) #xFF)

    \ \ \ \ \ \ \ \ \ \ \ \ (bitwise-and (bitwise-ior (ash b3 6) b4) #xFF)

    \ \ \ \ \ \ \ \ \ \ \ \ (if (negative? b3) 1 (if (negative? b4) 2 3))))))

    \ \ 

    \ \ (let* ((input-N (bytevector-length bv))

    \ \ \ \ \ \ \ \ \ (output-N (* input-N 3/4))

    \ \ \ \ \ \ \ \ \ (output (make-bytevector output-N)))

    \;

    \ \ \ \ (unless (zero? (modulo input-N 4))

    \ \ \ \ \ \ (value-error "length of the input bytevector must be 4X"))

    \ \ \ \ 

    \ \ \ \ (let loop ((i 0) (j 0))

    \ \ \ \ \ \ (if (\<less\> i input-N)

    \ \ \ \ \ \ \ \ \ \ (receive (r1 r2 r3 cnt)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (decode (bv i) (bv (+ i 1)) (bv (+ i 2)) (bv (+ i 3)))

    \ \ \ \ \ \ \ \ \ \ \ \ (bytevector-u8-set! output j r1)

    \ \ \ \ \ \ \ \ \ \ \ \ (when (\<gtr\>= cnt 2)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (bytevector-u8-set! output (+ j 1) r2))

    \ \ \ \ \ \ \ \ \ \ \ \ (when (\<gtr\>= cnt 3)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (bytevector-u8-set! output (+ j 2) r3))

    \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 4) (+ j cnt)))

    \ \ \ \ \ \ \ \ \ \ (let ((final (make-bytevector j)))

    \ \ \ \ \ \ \ \ \ \ \ \ (vector-copy! final 0 output 0 j)

    \ \ \ \ \ \ \ \ \ \ \ \ final)))))

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/base64.scm|true|true>
    (define string-base64-decode

    \ \ (typed-lambda ((str string?))

    \ \ \ \ (utf8-\<gtr\>string (bytevector-base64-decode (string-\<gtr\>utf8 str)))))

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/base64.scm|true|true>
    (define (base64-decode x)

    \ \ (cond ((string? x)

    \ \ \ \ \ \ \ \ \ (string-base64-decode x))

    \ \ \ \ \ \ \ \ ((bytevector? x)

    \ \ \ \ \ \ \ \ \ (bytevector-base64-decode x))

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (type-error "input must be string or bytevector"))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/base64-test.scm|true|true>
    (check (base64-decode "") =\<gtr\> "")

    \;

    (check (base64-decode "YQ==") =\<gtr\> "a")

    (check (base64-decode "eg==") =\<gtr\> "z")

    (check (base64-decode "Zg==") =\<gtr\> "f")

    (check (base64-decode "Zm8=") =\<gtr\> "fo")

    (check (base64-decode "Zm9v") =\<gtr\> "foo")

    (check (base64-decode "Zm9vYg==") =\<gtr\> "foob")

    (check (base64-decode "Zm9vYmE=") =\<gtr\> "fooba")

    (check (base64-decode "Zm9vYmFy") =\<gtr\> "foobar")

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/base64.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/base64-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii sys)>

  <section|许可证>

  <\goldfish-chunk|goldfish/liii/sys.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </goldfish-chunk>

  <section|接口>

  <\goldfish-chunk|goldfish/liii/sys.scm|true|true>
    (define-library (liii sys)

    (export argv executable)

    (import (scheme process-context))

    (begin

    \;
  </goldfish-chunk>

  <section|测试>

  <\goldfish-chunk|tests/goldfish/liii/sys-test.scm|false|false>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii sys))

    \;

    (display (executable))

    (newline)

    \;

    (check-report)

    \;
  </goldfish-chunk>

  <section|实现>

  <paragraph|argv>

  <\goldfish-chunk|goldfish/liii/sys.scm|true|true>
    (define (argv) (command-line))

    \;
  </goldfish-chunk>

  <paragraph|executable><index|executable><typehint|() =\<gtr\> string?>

  <\goldfish-chunk|goldfish/liii/sys.scm|true|true>
    (define (executable) (g_executable))

    \;
  </goldfish-chunk>

  <subparagraph|C++实现>

  如何获得当前可执行文件对应的路径，在不同的操作系统上的实现不一样。

  <\cpp-chunk|src/goldfish.hpp|true|true>
    string

    goldfish_exe () {

    #ifdef TB_CONFIG_OS_WINDOWS

    \ \ char buffer[GOLDFISH_PATH_MAXN];

    \ \ GetModuleFileName (NULL, buffer, GOLDFISH_PATH_MAXN);

    \ \ return string (buffer);

    #elif TB_CONFIG_OS_MACOSX

    \ \ char \ \ \ \ \ \ \ buffer[PATH_MAX];

    \ \ uint32_t \ \ \ size= sizeof (buffer);

    \ \ if (_NSGetExecutablePath (buffer, &size) == 0) {

    \ \ \ \ char real_path[GOLDFISH_PATH_MAXN];

    \ \ \ \ if (realpath (buffer, real_path) != NULL) {

    \ \ \ \ \ \ return string (real_path);

    \ \ \ \ }

    \ \ }

    \ \ return "";

    #elif TB_CONFIG_OS_LINUX

    \ \ char \ \ \ buffer[GOLDFISH_PATH_MAXN];

    \ \ ssize_t len= readlink ("/proc/self/exe", buffer, sizeof (buffer) - 1);

    \ \ if (len != -1) {

    \ \ \ \ buffer[len]= '\\0';

    \ \ \ \ return std::string (buffer);

    \ \ }

    \ \ return "";

    #endif

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_executable (s7_scheme* sc, s7_pointer args) {

    \ \ string exe_path= goldfish_exe ();

    \ \ return s7_make_string (sc, exe_path.c_str ());

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_executable (s7_scheme* sc) {

    \ \ const char* name= "g_executable";

    \ \ const char* desc= "(g_executable) =\<gtr\> string";

    \ \ glue_define (sc, name, desc, f_executable, 0, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|glue_liii_sys>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_liii_sys (s7_scheme* sc) {

    \ \ glue_executable (sc);

    }

    \;
  </cpp-chunk>

  <section|结尾>

  <\goldfish-chunk|goldfish/liii/sys.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </goldfish-chunk>

  <chapter|(liii os)>

  <section|协议>

  <\goldfish-chunk|goldfish/liii/os.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define-library (liii os)

    (export

    \ \ os-arch os-type os-windows? os-linux? os-macos? os-temp-dir

    \ \ os-sep pathsep

    \ \ os-call ; system

    \ \ mkdir chdir rmdir remove getenv putenv unsetenv getcwd listdir access getlogin getpid)

    (import (scheme process-context)

    \ \ \ \ \ \ \ \ (liii base)

    \ \ \ \ \ \ \ \ (liii error)

    \ \ \ \ \ \ \ \ (liii string))

    (begin

    \;
  </goldfish-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|true|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii string)

    \ \ \ \ \ \ \ \ (liii os)

    \ \ \ \ \ \ \ \ (liii sys)

    \ \ \ \ \ \ \ \ (liii uuid)

    \ \ \ \ \ \ \ \ (scheme time))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|实现>

  <paragraph|os-arch><typehint|() =\<gtr\> boolean?>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (os-arch)

    \ \ (g_os-arch))

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_os_arch (s7_scheme* sc, s7_pointer args) {

    \ \ return s7_make_string (sc, TB_ARCH_STRING);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_os_arch (s7_scheme* sc) {

    \ \ const char* name= "g_os-arch";

    \ \ const char* desc= "(g_os-arch) =\<gtr\> string";

    \ \ glue_define (sc, name, desc, f_os_arch, 0, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|os-type><goldfish-lang|() =\<gtr\> boolean?>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (os-type)

    \ \ (g_os-type))

    \;
  </goldfish-chunk>

  <subparagraph|测试用例>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|true|true>
    (when (os-linux?)

    \ \ (check (os-type) =\<gtr\> "Linux"))

    \;

    (when (os-macos?)

    \ \ (check (os-type) =\<gtr\> "Darwin"))

    \;

    (when (os-windows?)

    \ \ (check (os-type) =\<gtr\> "Windows"))

    \;

    (when (not (os-windows?))

    \ \ (let ((t1 (current-second)))

    \ \ \ \ (os-call "sleep 1")

    \ \ \ \ (let ((t2 (current-second)))

    \ \ \ \ \ \ (check (\<gtr\>= (ceiling (- t2 t1)) 1) =\<gtr\> #t))))

    \;
  </scm-chunk>

  <subparagraph|C++实现>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_os_type (s7_scheme* sc, s7_pointer args) {

    #ifdef TB_CONFIG_OS_LINUX

    \ \ return s7_make_string (sc, "Linux");

    #endif

    #ifdef TB_CONFIG_OS_MACOSX

    \ \ return s7_make_string (sc, "Darwin");

    #endif

    #ifdef TB_CONFIG_OS_WINDOWS

    \ \ return s7_make_string (sc, "Windows");

    #endif

    \ \ return s7_make_boolean (sc, false);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_os_type (s7_scheme* sc) {

    \ \ const char* name= "g_os-type";

    \ \ const char* desc= "(g_os-type) =\<gtr\> string";

    \ \ glue_define (sc, name, desc, f_os_type, 0, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|os-linux?><goldfish-lang|() =\<gtr\> boolean?>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (os-linux?)

    \ \ (let ((name (os-type)))

    \ \ \ \ (and name (string=? name "Linux"))))

    \;
  </goldfish-chunk>

  <paragraph|os-macos?><goldfish-lang|() =\<gtr\> boolean?>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (os-macos?)

    \ \ (let ((name (os-type)))

    \ \ \ \ (and name (string=? name "Darwin"))))

    \;
  </goldfish-chunk>

  <paragraph|os-windows?><goldfish-lang|() =\<gtr\> boolean?>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (os-windows?)

    \ \ (let ((name (os-type)))

    \ \ \ \ (and name (string=? name "Windows"))))

    \;
  </goldfish-chunk>

  <paragraph|os-sep>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (os-sep)

    \ \ (if (os-windows?)

    \ \ \ \ #\\\\

    \ \ \ \ #\\/))

    \;
  </goldfish-chunk>

  <paragraph|pathsep>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (pathsep)

    \ \ (if (os-windows?)

    \ \ \ \ #\\;

    \ \ \ \ #\\:))

    \;
  </goldfish-chunk>

  <paragraph|%check-dir-andthen>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (%check-dir-andthen path f)

    \ \ (cond ((not (file-exists? path))

    \ \ \ \ \ \ \ \ \ (file-not-found-error

    \ \ \ \ \ \ \ \ \ \ \ (string-append "No such file or directory: '" path "'")))

    \ \ \ \ \ \ \ \ ((not (g_isdir path))

    \ \ \ \ \ \ \ \ \ (not-a-directory-error

    \ \ \ \ \ \ \ \ \ \ \ (string-append "Not a directory: '" path "'")))

    \ \ \ \ \ \ \ \ (else (f path))))

    \;
  </goldfish-chunk>

  <paragraph|os-call>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (os-call command)

    \ \ (g_os-call command))

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_os_call (s7_scheme* sc, s7_pointer args) {

    \ \ const char* \ \ \ \ \ \ cmd_c= s7_string (s7_car (args));

    \ \ tb_process_attr_t attr = {tb_null};

    \ \ attr.flags \ \ \ \ \ \ \ \ \ \ \ \ = TB_PROCESS_FLAG_NO_WINDOW;

    \ \ int ret;

    \;

    #if _MSC_VER

    \ \ ret= (int) std::system (cmd_c);

    #else

    \ \ wordexp_t p;

    \ \ ret= wordexp (cmd_c, &p, 0);

    \ \ if (ret != 0) {

    \ \ \ \ // failed after calling wordexp

    \ \ }

    \ \ else if (p.we_wordc == 0) {

    \ \ \ \ wordfree (&p);

    \ \ \ \ ret= EINVAL;

    \ \ }

    \ \ else {

    \ \ \ \ ret= (int) tb_process_run (p.we_wordv[0], (tb_char_t const**) p.we_wordv,

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ &attr);

    \ \ \ \ wordfree (&p);

    \ \ }

    #endif

    \ \ return s7_make_integer (sc, ret);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void glue_os_call(s7_scheme* sc) {

    \ \ const char* name = "g_os-call";

    \ \ const char* desc = "(g_os-call string) =\<gtr\> int, execute a shell command and return the exit code";

    \ \ glue_define(sc, name, desc, f_os_call, 1, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|system>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (system command)

    \ \ (g_system command))

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_system (s7_scheme* sc, s7_pointer args) {

    \ \ const char* cmd_c= s7_string (s7_car (args));

    \ \ int \ \ \ \ \ \ \ \ ret \ = (int) std::system (cmd_c);

    \ \ return s7_make_integer (sc, ret);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void glue_system(s7_scheme* sc) {

    \ \ const char* name = "g_system";

    \ \ const char* desc = "(g_system string) =\<gtr\> int, execute a shell command and return the exit code";

    \ \ glue_define(sc, name, desc, f_system, 1, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|access>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (access path mode)

    \ \ (cond ((eq? mode 'F_OK) (g_access path 0))

    \ \ \ \ \ \ \ \ ((eq? mode 'X_OK) (g_access path 128))

    \ \ \ \ \ \ \ \ ((eq? mode 'W_OK) (g_access path 2))

    \ \ \ \ \ \ \ \ ((eq? mode 'R_OK) (g_access path 1))

    \ \ \ \ \ \ \ \ (else (error 'value-error "Allowed mode 'F_OK, 'X_OK,'W_OK, 'R_OK"))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|true|true>
    (when (and (os-linux?) (not (string=? "root" (getlogin))))

    \ \ (check-true (access "/root" 'F_OK))

    \ \ (check-false (access "/root" 'R_OK))

    \ \ (check-false (access "/root" 'W_OK))

    \ \ (check-true (access (executable) 'X_OK)))

    \;
  </scm-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_access (s7_scheme* sc, s7_pointer args) {

    \ \ const char* path_c= s7_string (s7_car (args));

    \ \ int \ \ \ \ \ \ \ \ mode \ = s7_integer ((s7_cadr (args)));

    \ \ bool ret= false;

    \ \ if (mode == 0) {

    \ \ \ \ tb_file_info_t info;

    \ \ \ \ ret= tb_file_info (path_c, &info);

    \ \ } else {

    \ \ \ \ ret= tb_file_access (path_c, mode);

    \ \ }

    \ \ 

    \ \ return s7_make_boolean (sc, ret);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void glue_access(s7_scheme* sc) {

    \ \ const char* name = "g_access";

    \ \ const char* desc = "(g_access string integer) =\<gtr\> boolean, check file access permissions";

    \ \ glue_define(sc, name, desc, f_access, 2, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|getenv>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define* (getenv key (default #f))

    \ \ (let ((val (get-environment-variable key)))

    \ \ \ \ (if val

    \ \ \ \ \ \ \ \ val

    \ \ \ \ \ \ \ \ default)))

    \;
  </goldfish-chunk>

  <paragraph|putenv>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (putenv key value)

    \ \ (if (and (string? key) (string? value))

    \ \ \ \ \ \ (g_setenv key value)

    \ \ \ \ \ \ (error 'type-error "(putenv key value): key and value must be strings")))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|true|true>
    (check-true (putenv "TEST_VAR" "123")) \ \ \ \ \ \ ; 设置环境变量

    (check (getenv "TEST_VAR") =\<gtr\> "123") \ \ \ \ \ \ \ \ ; 验证设置成功

    (check-true (putenv "TEST_VAR" "456")) \ \ \ \ \ \ ; 修改环境变量

    (check (getenv "TEST_VAR") =\<gtr\> "456") \ \ \ \ \ \ \ \ ; 验证修改成功

    (check-true (unsetenv "TEST_VAR")) \ \ \ \ \ \ \ \ \ \ ; 删除环境变量

    (check (getenv "TEST_VAR") =\<gtr\> #f) \ \ \ \ \ \ \ \ \ \ \ ; 验证删除成功

    \;

    (check-catch 'type-error (putenv 123 "abc")) ; key 非字符串

    (check-catch 'type-error (putenv "ABC" 123)) ; value 非字符串

    \;
  </scm-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    // 实现 putenv 功能

    static s7_pointer

    f_set_environment_variable(s7_scheme* sc, s7_pointer args) {

    \ \ \ \ const char* key = s7_string(s7_car(args));

    \ \ \ \ const char* value = s7_string(s7_cadr(args));

    \ \ \ \ return s7_make_boolean(sc, tb_environment_set(key, value));

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_setenv(s7_scheme* sc) {

    \ \ \ \ const char* name = "g_setenv";

    \ \ \ \ const char* desc = "(g_setenv key value) =\<gtr\> boolean, set an environment variable";

    \ \ \ \ glue_define(sc, name, desc, f_set_environment_variable, 2, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|unsetenv>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (unsetenv key)

    \ \ (g_unsetenv key))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|true|true>
    (check (string-null? (getenv "PATH")) =\<gtr\> #f)

    (unsetenv "PATH")

    (check (getenv "PATH") =\<gtr\> #f)

    (unsetenv "home")

    (check (getenv "home") =\<gtr\> #f)

    (check (getenv "home" "value does not found") =\<gtr\> "value does not found")

    \;
  </scm-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_unsetenv (s7_scheme* sc) {

    \ \ const char* name= "g_unsetenv";

    \ \ const char* desc= "(g_unsetenv string): string =\<gtr\> boolean";

    \ \ glue_define (sc, name, desc, f_unset_environment_variable, 1, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|os-temp-dir>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (os-temp-dir)

    \ \ (let1 temp-dir (g_os-temp-dir)

    \ \ \ \ (string-remove-suffix temp-dir (string (os-sep)))))

    \;
  </goldfish-chunk>

  <subparagraph|测试用例>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|true|true>
    (when (os-windows?)

    \ \ (check (string-starts? (os-temp-dir) "C:") =\<gtr\> #t))

    \;

    (when (os-linux?)

    \ \ (check (os-temp-dir) =\<gtr\> "/tmp"))

    \;
  </scm-chunk>

  <subparagraph|C++实现>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_os_temp_dir (s7_scheme* sc, s7_pointer args) {

    \ \ tb_char_t path[GOLDFISH_PATH_MAXN];

    \ \ tb_directory_temporary (path, GOLDFISH_PATH_MAXN);

    \ \ return s7_make_string (sc, path);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_os_temp_dir (s7_scheme* sc) {

    \ \ const char* name= "g_os-temp-dir";

    \ \ const char* desc= "(g_os-temp-dir) =\<gtr\> string, get the temporary directory path";

    \ \ glue_define (sc, name, desc, f_os_temp_dir, 0, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|mkdir>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (mkdir path)

    \ \ (if (file-exists? path)

    \ \ \ \ (file-exists-error (string-append "File exists: '" path "'"))

    \ \ \ \ (g_mkdir path)))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|true|true>
    (when (not (os-windows?))

    \ \ (check-catch 'file-exists-error

    \ \ \ \ (mkdir "/tmp"))

    \ \ (check (begin

    \ \ \ \ \ \ \ \ \ \ \ (let ((test_dir "/tmp/test_124"))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (when (file-exists? test_dir)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (rmdir "/tmp/test_124"))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (mkdir "/tmp/test_124")))

    \ \ \ \ =\<gtr\> #t))

    \;
  </scm-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_mkdir (s7_scheme* sc, s7_pointer args) {

    \ \ const char* dir_c= s7_string (s7_car (args));

    \ \ return s7_make_boolean (sc, tb_directory_create (dir_c));

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void glue_mkdir(s7_scheme* sc) {

    \ \ const char* name = "g_mkdir";

    \ \ const char* desc = "(g_mkdir string) =\<gtr\> boolean, create a directory";

    \ \ glue_define(sc, name, desc, f_mkdir, 1, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|rmdir>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_rmdir (s7_scheme* sc, s7_pointer args) {

    \ \ const char* dir_c= s7_string (s7_car (args));

    \ \ return s7_make_boolean (sc, tb_directory_remove (dir_c));

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void glue_rmdir(s7_scheme* sc) {

    \ \ const char* name = "g_rmdir";

    \ \ const char* desc = "(g_rmdir string) =\<gtr\> boolean, remove a directory";

    \ \ glue_define(sc, name, desc, f_rmdir, 1, 0);

    }

    \;
  </cpp-chunk>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (rmdir path)

    \ \ (%check-dir-andthen path g_rmdir))

    \;
  </goldfish-chunk>

  <paragraph|remove>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (remove path)

    \ \ (cond

    \ \ \ \ ((not (string? path))

    \ \ \ \ \ (error 'type-error "(remove path): path must be string"))

    \ \ \ \ ((not (file-exists? path))

    \ \ \ \ \ (error 'file-not-found-error (string-append "File not found: " path)))

    \ \ \ \ ((g_isdir path) \ ; 检查是否为目录

    \ \ \ \ \ (error 'value-error "Cannot remove a directory (use 'rmdir' instead)"))

    \ \ \ \ (else

    \ \ \ \ \ (g_remove-file path))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|true|true>
    (when (or (os-macos?) (os-linux?))

    \ \ \ \ ;; 测试 remove

    \ \ (let ((test-file (string-append (os-temp-dir) "/test_remove.txt")))

    \ \ \ \ ;; 创建临时文件

    \ \ \ \ (with-output-to-file test-file

    \ \ \ \ \ \ (lambda () (display "test data")))

    \ \ \ \ ;; 验证文件存在

    \ \ \ \ (check-true (file-exists? test-file))

    \ \ \ \ ;; 删除文件

    \ \ \ \ (check-true (remove test-file))

    \ \ \ \ ;; 验证文件已删除

    \ \ \ \ (check-false (file-exists? test-file))))

    \;

    ;; 错误测试

    (check-catch 'type-error (remove 123)) \ \ \ \ \ \ \ \ \ \ \ \ \ \ ; path 非字符串

    (check-catch 'file-not-found-error (remove "/nonexistent/file")) ; 文件不存在

    \;

    ;; 测试 remove 对目录的提示

    (let ((test-dir (string-append (os-temp-dir) (string (os-sep)) "test_dir")))

    \ \ ;; 创建临时目录

    \ \ (when (not (file-exists? test-dir))

    \ \ \ \ (mkdir test-dir))

    \ \ ;; 尝试删除目录，应提示使用 rmdir

    \ \ (check-catch 'value-error (remove test-dir))

    \ \ ;; 清理

    \ \ (rmdir test-dir)

    \ \ (when (file-exists? test-dir)

    \ \ \ \ (display* test-dir " failed to remove \\n")))

    \;
  </scm-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_remove_file(s7_scheme* sc, s7_pointer args) {

    \ \ \ \ const char* path = s7_string(s7_car(args));

    \ \ \ \ bool success = tb_file_remove(path); // 直接调用 TBOX 删除文件

    \ \ \ \ return s7_make_boolean(sc, success);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_remove_file(s7_scheme* sc) {

    \ \ \ \ const char* name = "g_remove-file";

    \ \ \ \ const char* desc = "(g_remove-file path) =\<gtr\> boolean, delete a file";

    \ \ \ \ glue_define(sc, name, desc, f_remove_file, 1, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|chdir>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (chdir path)

    \ \ (if (file-exists? path)

    \ \ \ \ (g_chdir path)

    \ \ \ \ (file-not-found-error (string-append "No such file or directory: '" path "'"))))

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_chdir (s7_scheme* sc, s7_pointer args) {

    \ \ const char* dir_c= s7_string (s7_car (args));

    \ \ return s7_make_boolean (sc, tb_directory_current_set (dir_c));

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void glue_chdir(s7_scheme* sc) {

    \ \ const char* name = "g_chdir";

    \ \ const char* desc = "(g_chdir string) =\<gtr\> boolean, change the current working directory";

    \ \ glue_define(sc, name, desc, f_chdir, 1, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|listdir>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (listdir path)

    \ \ (%check-dir-andthen path g_listdir))

    \;
  </goldfish-chunk>

  <subparagraph|测试用例>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|true|true>
    (when (not (os-windows?))

    \ \ (check (\<gtr\> (vector-length (listdir "/usr")) 0) =\<gtr\> #t))

    \;

    (let* ((test-dir (string-append (os-temp-dir) (string (os-sep)) (uuid4)))

    \ \ \ \ \ \ \ (test-dir2 (string-append test-dir (string (os-sep))))

    \ \ \ \ \ \ \ (dir-a (string-append test-dir2 "a"))

    \ \ \ \ \ \ \ (dir-b (string-append test-dir2 "b"))

    \ \ \ \ \ \ \ (dir-c (string-append test-dir2 "c")))

    \ \ (mkdir test-dir)

    \ \ (mkdir dir-a)

    \ \ (mkdir dir-b)

    \ \ (mkdir dir-c)

    \ \ (let1 r (listdir test-dir)

    \ \ \ \ (check-true (in? "a" r))

    \ \ \ \ (check-true (in? "b" r))

    \ \ \ \ (check-true (in? "c" r)))

    \ \ (let1 r2 (listdir test-dir2)

    \ \ \ \ (check-true (in? "a" r2))

    \ \ \ \ (check-true (in? "b" r2))

    \ \ \ \ (check-true (in? "c" r2)))

    \ \ (rmdir dir-a)

    \ \ (rmdir dir-b)

    \ \ (rmdir dir-c)

    \ \ (rmdir test-dir))

    \;

    (when (os-windows?)

    \ \ (check (\<gtr\> (vector-length (listdir "C:")) 0) =\<gtr\> #t))

    \;
  </scm-chunk>

  <subparagraph|C++实现>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static tb_long_t

    tb_directory_walk_func (tb_char_t const* path, tb_file_info_t const* info,

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tb_cpointer_t priv) {

    \ \ // check

    \ \ tb_assert_and_check_return_val (path && info, TB_DIRECTORY_WALK_CODE_END);

    \;

    \ \ vector\<less\>string\<gtr\>* p_v_result= (vector\<less\>string\<gtr\>*) priv;

    \ \ p_v_result-\<gtr\>push_back (string (path));

    \ \ return TB_DIRECTORY_WALK_CODE_CONTINUE;

    }

    \;

    static s7_pointer

    f_listdir (s7_scheme* sc, s7_pointer args) {

    \ \ const char* \ \ \ path_c= s7_string (s7_car (args));

    \ \ vector\<less\>string\<gtr\> entries;

    \ \ s7_pointer \ \ \ \ ret= s7_make_vector (sc, 0);

    \ \ tb_directory_walk (path_c, 0, tb_false, tb_directory_walk_func, &entries);

    \;

    \ \ int \ \ \ entries_N \ \ = entries.size ();

    \ \ string path_s \ \ \ \ \ = string (path_c);

    \ \ int \ \ \ path_N \ \ \ \ \ = path_s.size ();

    \ \ int \ \ \ path_slash_N= path_N;

    \ \ char \ \ last_ch \ \ \ \ = path_s[path_N - 1];

    #if defined(TB_CONFIG_OS_WINDOWS)

    \ \ if (last_ch != '/' && last_ch != '\\\\') {

    \ \ \ \ path_slash_N= path_slash_N + 1;

    \ \ }

    #else

    \ \ if (last_ch != '/') {

    \ \ \ \ path_slash_N= path_slash_N + 1;

    \ \ }

    #endif

    \ \ for (int i= 0; i \<less\> entries_N; i++) {

    \ \ \ \ entries[i]= entries[i].substr (path_slash_N);

    \ \ }

    \ \ return string_vector_to_s7_vector (sc, entries);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_listdir (s7_scheme* sc) {

    \ \ const char* name= "g_listdir";

    \ \ const char* desc= "(g_listdir string) =\<gtr\> vector, list the contents of a directory";

    \ \ glue_define (sc, name, desc, f_listdir, 1, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|getcwd><index|getcwd>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (getcwd)

    \ \ (g_getcwd))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|true|true>
    (check-false (string-null? (getcwd)))

    \;
  </scm-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_getcwd (s7_scheme* sc, s7_pointer args) {

    \ \ tb_char_t path[GOLDFISH_PATH_MAXN];

    \ \ tb_directory_current (path, GOLDFISH_PATH_MAXN);

    \ \ return s7_make_string (sc, path);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_getcwd (s7_scheme* sc) {

    \ \ const char* name= "g_getcwd";

    \ \ const char* desc= "(g_getcwd) =\<gtr\> string, get the current working directory";

    \ \ glue_define (sc, name, desc, f_getcwd, 0, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|getlogin><index|getlogin>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (getlogin)

    \ \ (if (os-windows?)

    \ \ \ \ \ \ (getenv "USERNAME")

    \ \ \ \ \ \ (g_getlogin)))

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_getlogin (s7_scheme* sc, s7_pointer args) {

    #ifdef TB_CONFIG_OS_WINDOWS

    \ \ return s7_make_boolean (sc, false);

    #else

    \ \ uid_t \ \ \ \ \ \ \ \ \ uid= getuid ();

    \ \ struct passwd* pwd= getpwuid (uid);

    \ \ return s7_make_string (sc, pwd-\<gtr\>pw_name);

    #endif

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_getlogin (s7_scheme* sc) {

    \ \ const char* name= "g_getlogin";

    \ \ const char* desc= "(g_getlogin) =\<gtr\> string, get the current user's login name";

    \ \ glue_define (sc, name, desc, f_getlogin, 0, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|getpid><index|getpid>

  <\goldfish-chunk|goldfish/liii/os.scm|true|true>
    (define (getpid)

    \ \ (g_getpid))

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_getpid (s7_scheme* sc, s7_pointer args) {

    #ifdef TB_CONFIG_OS_WINDOWS

    \ \ return s7_make_integer (sc, (int) GetCurrentProcessId ());

    #else

    \ \ return s7_make_integer (sc, getpid ());

    #endif

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_getpid (s7_scheme* sc) {

    \ \ const char* name= "g_getpid";

    \ \ const char* desc= "(g_getpid) =\<gtr\> integer";

    \ \ glue_define (sc, name, desc, f_getpid, 0, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|glue_liii_os>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_liii_os (s7_scheme* sc) {

    \ \ glue_os_arch (sc);

    \ \ glue_os_type (sc);

    \ \ glue_os_call (sc);

    \ \ glue_system (sc);

    \ \ glue_access (sc);

    \ \ glue_setenv (sc);

    \ \ glue_unsetenv (sc);

    \ \ glue_getcwd (sc);

    \ \ glue_os_temp_dir (sc);

    \ \ glue_mkdir (sc);

    \ \ glue_rmdir (sc);

    \ \ glue_remove_file(sc);\ 

    \ \ glue_chdir (sc);

    \ \ glue_listdir (sc);

    \ \ glue_getlogin (sc);

    \ \ glue_getpid (sc);

    }

    \;
  </cpp-chunk>

  <section|结尾>

  <\goldfish-chunk|goldfish/liii/os.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/os-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii uuid)>

  <section|协议>

  <\goldfish-chunk|goldfish/liii/uuid.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </goldfish-chunk>

  <section|实现>

  <scm|(liii uuid)>是通过C++实现的，本节是相关的胶水代码。

  <paragraph|uuid4><index|g_uuid4><typehint|=\<gtr\> string?>

  <\goldfish-chunk|goldfish/liii/uuid.scm|true|false>
    (define-library (liii uuid)

    (export uuid4)

    (begin

    \;

    (define (uuid4) (g_uuid4))

    \;

    ) ; end of begin

    ) ; end of define-library

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_uuid4 (s7_scheme* sc, s7_pointer args) {

    \ \ tb_char_t \ \ \ \ \ \ \ uuid[37];

    \ \ const tb_char_t* ret= tb_uuid4_make_cstr (uuid, tb_null);

    \ \ return s7_make_string (sc, ret);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_uuid4 (s7_scheme* sc) {

    \ \ const char* name= "g_uuid4";

    \ \ const char* desc= "(g_uuid4) =\<gtr\> string";

    \ \ glue_define (sc, name, desc, f_uuid4, 0, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|glue_liii_uuid>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_liii_uuid (s7_scheme* sc) {

    \ \ glue_uuid4 (sc);

    }

    \;
  </cpp-chunk>

  <chapter|(liii path)>

  <section|协议>

  <\goldfish-chunk|goldfish/liii/path.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define-library (liii path)

    (export

    \ \ path-dir? path-file? path-exists?

    \ \ path-getsize path-read-text path-read-bytes path-write-text path-append-text path-touch

    \ \ path

    )

    (import (liii base) (liii error) (liii vector) (liii string) (liii list)

    \ \ \ \ \ \ \ \ (liii os))

    (begin

    \;
  </goldfish-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (import (liii path)

    \ \ \ \ \ \ \ \ (liii check)

    \ \ \ \ \ \ \ \ (liii os)

    \ \ \ \ \ \ \ \ (liii string))

    \;

    ; (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|实现>

  <paragraph|path-dir?>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (path-dir? path)

    \ \ (g_isdir path))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (check (path-dir? ".") =\<gtr\> #t)

    (check (path-dir? "..") =\<gtr\> #t)

    \;

    (when (not (os-windows?))

    \ \ (check (path-dir? "/") =\<gtr\> #t)

    \ \ (check (path-dir? "/tmp") =\<gtr\> #t)

    \ \ (check (path-dir? "/no_such_dir") =\<gtr\> #f))

    \;

    (when (os-windows?)

    \ \ (check (path-dir? "C:/") =\<gtr\> #t)

    \ \ (check (path-dir? "C:/no_such_dir/") =\<gtr\> #f))

    \;
  </scm-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_isdir (s7_scheme* sc, s7_pointer args) {

    \ \ const char* \ \ \ dir_c= s7_string (s7_car (args));

    \ \ tb_file_info_t info;

    \ \ bool \ \ \ \ \ \ \ \ \ \ ret= false;

    \ \ if (tb_file_info (dir_c, &info)) {

    \ \ \ \ switch (info.type) {

    \ \ \ \ case TB_FILE_TYPE_DIRECTORY:

    \ \ \ \ case TB_FILE_TYPE_DOT:

    \ \ \ \ case TB_FILE_TYPE_DOT2:

    \ \ \ \ \ \ ret= true;

    \ \ \ \ }

    \ \ }

    \ \ return s7_make_boolean (sc, ret);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_isdir (s7_scheme* sc) {

    \ \ const char* name= "g_isdir";

    \ \ const char* desc= "(g_isdir string) =\<gtr\> boolean";

    \ \ glue_define (sc, name, desc, f_isdir, 1, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|path-file?>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (path-file? path)

    \ \ (g_isfile path))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (check (path-file? ".") =\<gtr\> #f)

    (check (path-file? "..") =\<gtr\> #f)

    \;

    (when (os-linux?)

    \ \ (check (path-file? "/etc/passwd") =\<gtr\> #t))

    \;
  </scm-chunk>

  <subparagraph|C++实现>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_isfile (s7_scheme* sc, s7_pointer args) {

    \ \ const char* \ \ \ dir_c= s7_string (s7_car (args));

    \ \ tb_file_info_t info;

    \ \ bool \ \ \ \ \ \ \ \ \ \ ret= false;

    \ \ if (tb_file_info (dir_c, &info)) {

    \ \ \ \ switch (info.type) {

    \ \ \ \ case TB_FILE_TYPE_FILE:

    \ \ \ \ \ \ ret= true;

    \ \ \ \ }

    \ \ }

    \ \ return s7_make_boolean (sc, ret);

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_isfile (s7_scheme* sc) {

    \ \ const char* name= "g_isfile";

    \ \ const char* desc= "(g_isfile string) =\<gtr\> boolean";

    \ \ glue_define (sc, name, desc, f_isfile, 1, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|path-exists?>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (path-exists? path)

    \ \ (file-exists? path))

    \;
  </goldfish-chunk>

  <paragraph|path-getsize><index|path-getsize><scm|((path string?)) =\<gtr\> integer?>

  返回当前路径的文件大小。

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define path-getsize

    \ \ (typed-lambda ((path string?))

    \ \ \ \ (if (not (file-exists? path))

    \ \ \ \ \ \ (file-not-found-error

    \ \ \ \ \ \ \ \ (string-append "No such file or directory: '" path "'"))

    \ \ \ \ \ \ (g_path-getsize path))))

    \;
  </goldfish-chunk>

  \;

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (not (os-windows?))

    \ \ (check-true (\<gtr\> (path-getsize "/") 0))

    \ \ (check-true (\<gtr\> (path-getsize "/etc/hosts") 0)))

    \;

    (when (os-windows?)

    \ \ (check-true (\<gtr\> (path-getsize "C:") 0))

    \ \ (check-true (\<gtr\> (path-getsize "C:/Windows") 0))

    \ \ (check-true (\<gtr\> (path-getsize "C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts") 0)))

    \;
  </scm-chunk>

  返回指定路径的文件大小，如果该文件不存在，那么返回-1。

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_path_getsize (s7_scheme* sc, s7_pointer args) {

    \ \ const char* \ \ \ path_c= s7_string (s7_car (args));

    \ \ tb_file_info_t info;

    \ \ if (tb_file_info (path_c, &info)) {

    \ \ \ \ return s7_make_integer (sc, (int) info.size);

    \ \ }

    \ \ else {

    \ \ \ \ return s7_make_integer (sc, (int) -1);

    \ \ }

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_path_getsize (s7_scheme* sc) {

    \ \ const char* name= "g_path-getsize";

    \ \ const char* desc= "(g_path_getsize string): string =\<gtr\> integer";

    \ \ glue_define (sc, name, desc, f_path_getsize, 1, 0);

    }

    \;
  </cpp-chunk>

  <paragraph|path-read-text>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define path-read-text

    \ \ (typed-lambda ((path string?))

    \ \ \ \ (if (not (file-exists? path))

    \ \ \ \ \ \ (file-not-found-error

    \ \ \ \ \ \ \ \ (string-append "No such file or directory: '" path "'"))

    \ \ \ \ \ \ (g_path-read-text path))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (let ((file-name "中文文件名.txt")

    \ \ \ \ \ \ (file-content "你好，世界！"))

    \ \ (define temp-dir (os-temp-dir))

    \ \ (define file-path (string-append temp-dir (string (os-sep)) file-name))

    \ \ (path-write-text file-path file-content)

    \ \ (check (path-read-text file-path) =\<gtr\> file-content)

    \ \ (delete-file file-path))

    \;
  </scm-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer f_path_read_text(s7_scheme* sc, s7_pointer args) {

    \ \ const char* path = s7_string (s7_car (args));

    \ \ if (!path) {

    \ \ \ \ return s7_make_boolean(sc, false);

    \ \ }

    \;

    \ \ tb_file_ref_t file = tb_file_init(path, TB_FILE_MODE_RO);

    \ \ if (file == tb_null) {

    \ \ \ \ // TODO: warning on the tb_file_init failure

    \ \ \ \ return s7_make_boolean(sc, false);

    \ \ }

    \;

    \ \ tb_file_sync (file);

    \;

    \ \ tb_size_t size = tb_file_size(file);

    \ \ if (size == 0) {

    \ \ \ \ tb_file_exit (file);

    \ \ \ \ return s7_make_string (sc, "");

    \ \ }

    \;

    \ \ tb_byte_t* buffer = new tb_byte_t[size + 1];

    \ \ tb_size_t real_size = tb_file_read (file, buffer, size);

    \ \ buffer[real_size] = '\\0';

    \;

    \ \ tb_file_exit(file);

    \ \ std::string content (reinterpret_cast\<less\>char*\<gtr\>(buffer), real_size);

    \ \ delete[] buffer;

    \;

    \ \ return s7_make_string(sc, content.c_str());

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_path_read_text(s7_scheme* sc) {

    \ \ const char* name = "g_path-read-text";

    \ \ const char* desc = "(g_path-read-text path) =\<gtr\> string, read the content of the file at the given path";

    \ \ s7_define_function(sc, name, f_path_read_text, 1, 0, false, desc);

    }

    \;
  </cpp-chunk>

  <paragraph|path-read-bytes>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define path-read-bytes

    \ \ (typed-lambda ((path string?))

    \ \ \ \ (if (not (file-exists? path))

    \ \ \ \ \ \ (file-not-found-error

    \ \ \ \ \ \ \ \ (string-append "No such file or directory: '" path "'"))

    \ \ \ \ \ \ (g_path-read-bytes path))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    ; Test for path-read-bytes

    (let ((file-name "binary-test.dat")

    \ \ \ \ \ \ (file-content "Hello, binary world!"))

    \ \ (define temp-dir (os-temp-dir))

    \ \ (define file-path (string-append temp-dir (string (os-sep)) file-name))

    \ \ 

    \ \ ; Write a simple string to the file

    \ \ (path-write-text file-path file-content)

    \ \ 

    \ \ ; Read it back using path-read-bytes

    \ \ (let ((read-content (path-read-bytes file-path)))

    \ \ \ \ ; Check that it's a bytevector

    \ \ \ \ (check-true (bytevector? read-content))

    \ \ \ \ ; Check that it has the correct length

    \ \ \ \ (check (bytevector-length read-content) =\<gtr\> (string-length file-content))

    \ \ \ \ ; Check that the content matches when converted back to string

    \ \ \ \ (check (utf8-\<gtr\>string read-content) =\<gtr\> file-content))

    \ \ 

    \ \ (delete-file file-path))

    \;
  </scm-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    \;

    static s7_pointer f_path_read_bytes(s7_scheme* sc, s7_pointer args) {

    \ \ const char* path = s7_string(s7_car(args));

    \ \ if (!path) {

    \ \ \ \ return s7_make_boolean(sc, false);

    \ \ }

    \;

    \ \ tb_file_ref_t file = tb_file_init(path, TB_FILE_MODE_RO);

    \ \ if (file == tb_null) {

    \ \ \ \ return s7_make_boolean(sc, false);

    \ \ }

    \;

    \ \ tb_file_sync(file);

    \ \ tb_size_t size = tb_file_size(file);

    \ \ 

    \ \ if (size == 0) {

    \ \ \ \ tb_file_exit(file);

    \ \ \ \ // Create an empty bytevector with correct parameters

    \ \ \ \ return s7_make_byte_vector(sc, 0, 1, NULL); \ // 1 dimension, no dimension info

    \ \ }

    \;

    \ \ // Allocate buffer similar to f_path_read_text

    \ \ tb_byte_t* buffer = new tb_byte_t[size];

    \ \ tb_size_t real_size = tb_file_read(file, buffer, size);

    \ \ tb_file_exit(file);

    \;

    \ \ if (real_size != size) {

    \ \ \ \ delete[] buffer;

    \ \ \ \ return s7_make_boolean(sc, false); \ // Read failed

    \ \ }

    \;

    \ \ // Create a Scheme bytevector and copy data

    \ \ s7_pointer bytevector = s7_make_byte_vector(sc, real_size, 1, NULL); \ // 1 dimension, no dimension info

    \ \ tb_byte_t* bytevector_data = s7_byte_vector_elements(bytevector);

    \ \ memcpy(bytevector_data, buffer, real_size);

    \ \ 

    \ \ delete[] buffer;

    \ \ return bytevector; \ // Return the bytevector

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_path_read_bytes(s7_scheme* sc) {

    \ \ const char* name = "g_path-read-bytes";

    \ \ const char* desc = "(g_path-read-bytes path) =\<gtr\> bytevector, read the binary content of the file at the given path";

    \ \ s7_define_function(sc, name, f_path_read_bytes, 1, 0, false, desc);

    }

    \;
  </cpp-chunk>

  <paragraph|path-write-text>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define path-write-text

    \ \ (typed-lambda ((path string?) (content string?))

    \ \ \ \ (g_path-write-text path content)))

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_path_write_text (s7_scheme* sc, s7_pointer args) {

    \ \ const char* path = s7_string (s7_car (args));

    \ \ if (!path) {

    \ \ \ \ return s7_make_integer(sc, -1);

    \ \ }

    \;

    \ \ const char* content= s7_string (s7_cadr (args));

    \ \ if (!content) {

    \ \ \ \ return s7_make_integer(sc, -1);

    \ \ }

    \;

    \ \ tb_file_ref_t file = tb_file_init(path, TB_FILE_MODE_WO \| TB_FILE_MODE_CREAT \| TB_FILE_MODE_TRUNC);

    \ \ if (file == tb_null) {

    \ \ \ \ return s7_make_integer(sc, -1);

    \ \ }

    \;

    \ \ tb_filelock_ref_t lock = tb_filelock_init(file);

    \ \ if (tb_filelock_enter(lock, TB_FILELOCK_MODE_EX) == tb_false) {

    \ \ \ \ tb_filelock_exit(lock);

    \ \ \ \ tb_file_exit(file);

    \ \ \ \ return s7_make_integer(sc, -1);

    \ \ }

    \;

    \ \ tb_size_t content_size= strlen(content);

    \ \ tb_size_t written_size= tb_file_writ(file, reinterpret_cast\<less\>const tb_byte_t*\<gtr\>(content), content_size);

    \;

    \ \ bool release_success= tb_filelock_leave (lock);

    \ \ tb_filelock_exit (lock);

    \ \ bool exit_success= tb_file_exit(file);

    \;

    \ \ if (written_size == content_size && release_success && exit_success) {

    \ \ \ \ return s7_make_integer(sc, written_size);

    \ \ } else {

    \ \ \ \ return s7_make_integer(sc, -1);

    \ \ }

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void glue_path_write_text(s7_scheme* sc) {

    \ \ const char* name = "g_path-write-text";

    \ \ const char* desc = "(g_path-write-text path content) =\<gtr\> integer,\\

    write content to the file at the given path and return the number of bytes written, or -1 on failure";

    \ \ s7_define_function(sc, name, f_path_write_text, 2, 0, false, desc);

    }

    \;
  </cpp-chunk>

  <paragraph|path-append-text>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define path-append-text

    \ \ (typed-lambda ((path string?) (content string?))

    \ \ \ \ (g_path-append-text path content)))

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer

    f_path_append_text (s7_scheme* sc, s7_pointer args) {

    \ \ const char* path = s7_string (s7_car (args));

    \ \ if (!path) {

    \ \ \ \ return s7_make_integer(sc, -1);

    \ \ }

    \;

    \ \ const char* content = s7_string (s7_cadr (args));

    \ \ if (!content) {

    \ \ \ \ return s7_make_integer(sc, -1);

    \ \ }

    \;

    \ \ // 以追加模式打开文件

    \ \ tb_file_ref_t file = tb_file_init(path, TB_FILE_MODE_WO \| TB_FILE_MODE_CREAT \| TB_FILE_MODE_APPEND);

    \ \ if (file == tb_null) {

    \ \ \ \ return s7_make_integer(sc, -1);

    \ \ }

    \;

    \ \ tb_filelock_ref_t lock = tb_filelock_init(file);

    \ \ if (tb_filelock_enter(lock, TB_FILELOCK_MODE_EX) == tb_false) {

    \ \ \ \ tb_filelock_exit(lock);

    \ \ \ \ tb_file_exit(file);

    \ \ \ \ return s7_make_integer(sc, -1);

    \ \ }

    \;

    \ \ tb_size_t content_size = strlen(content);

    \ \ tb_size_t written_size = tb_file_writ(file, reinterpret_cast\<less\>const tb_byte_t*\<gtr\>(content), content_size);

    \;

    \ \ bool release_success = tb_filelock_leave(lock);

    \ \ tb_filelock_exit(lock);

    \ \ bool exit_success = tb_file_exit(file);

    \;

    \ \ if (written_size == content_size && release_success && exit_success) {

    \ \ \ \ return s7_make_integer(sc, written_size);

    \ \ } else {

    \ \ \ \ return s7_make_integer(sc, -1);

    \ \ }

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void glue_path_append_text(s7_scheme* sc) {

    \ \ const char* name = "g_path-append-text";

    \ \ const char* desc = "(g_path-append-text path content) =\<gtr\> integer,\\

    append content to the file at the given path and return the number of bytes written, or -1 on failure";

    \ \ s7_define_function(sc, name, f_path_append_text, 2, 0, false, desc);

    }

    \;
  </cpp-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    ;; 测试 path-append-text

    (let ((file-name "append-test.txt")

    \ \ \ \ \ \ (initial-content "Initial content\\n")

    \ \ \ \ \ \ (append-content "Appended content\\n"))

    \ \ (define temp-dir (os-temp-dir))

    \ \ (define file-path (string-append temp-dir (string (os-sep)) file-name))

    \ \ 

    \ \ ;; 先写入初始内容

    \ \ (path-write-text file-path initial-content)

    \ \ 

    \ \ ;; 验证初始内容

    \ \ (check (path-read-text file-path) =\<gtr\> initial-content)

    \ \ 

    \ \ ;; 追加内容

    \ \ (path-append-text file-path append-content)

    \ \ 

    \ \ ;; 验证追加后的内容

    \ \ (check (path-read-text file-path) =\<gtr\> (string-append initial-content append-content))

    \ \ 

    \ \ ;; 清理

    \ \ (delete-file file-path))

    \;

    ;; 测试追加到不存在的文件

    (let ((file-name "append-new-file.txt")

    \ \ \ \ \ \ (content "Content for new file\\n"))

    \ \ (define temp-dir (os-temp-dir))

    \ \ (define file-path (string-append temp-dir (string (os-sep)) file-name))

    \ \ 

    \ \ ;; 确保文件不存在

    \ \ (when (file-exists? file-path)

    \ \ \ \ (delete-file file-path))

    \ \ 

    \ \ ;; 追加到不存在的文件

    \ \ (path-append-text file-path content)

    \ \ 

    \ \ ;; 验证内容

    \ \ (when (or (os-macos?) (os-linux?))

    \ \ \ \ (check (path-read-text file-path) =\<gtr\> content))

    \ \ 

    \ \ ;; 清理

    \ \ (delete-file file-path))

    \;
  </scm-chunk>

  <paragraph|path-touch>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (path-touch path)

    \ \ (g_path-touch path))

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer f_path_touch(s7_scheme* sc, s7_pointer args) {

    \ \ const char* path = s7_string(s7_car(args));

    \ \ if (!path) {

    \ \ \ \ return s7_make_boolean(sc, false);

    \ \ }

    \ \ \ \ 

    \ \ tb_bool_t success = tb_file_touch(path, 0, 0);

    \;

    \ \ if (success == tb_true) {

    \ \ \ \ return s7_make_boolean(sc, true);

    \ \ } else {

    \ \ \ \ return s7_make_boolean(sc, false);

    \ \ }

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_path_touch(s7_scheme* sc) {

    \ \ const char* name = "g_path-touch";

    \ \ const char* desc = "(g_path-touch path) =\<gtr\> boolean, create empty file or update modification time";

    \ \ s7_define_function(sc, name, f_path_touch, 1, 0, false, desc);

    }

    \;
  </cpp-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (let ((test-file (string-append (os-temp-dir) "/test_touch.txt")))

    \ \ ;; Ensure file doesn't exist initially

    \ \ (when (file-exists? test-file)

    \ \ \ \ (delete-file test-file))

    \ \ 

    \ \ ;; Test creating new file

    \ \ (check-true (path-touch test-file))

    \ \ (check-true (file-exists? test-file))

    \ \ 

    \ \ ;; Test updating existing file

    \ \ (let ((old-size (path-getsize test-file)))

    \ \ \ \ (check-true (path-touch test-file))

    \ \ \ \ (check (= (path-getsize test-file) old-size) =\<gtr\> #t))

    \ \ 

    \ \ ;; Clean up

    \ \ (delete-file test-file))

    \;
  </scm-chunk>

  <paragraph|glue_path>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_liii_path (s7_scheme* sc) {

    \ \ glue_isfile (sc);

    \ \ glue_isdir (sc);

    \ \ glue_path_getsize (sc);

    \ \ glue_path_read_text (sc);

    \ \ glue_path_read_bytes (sc);

    \ \ glue_path_write_text (sc);

    \ \ glue_path_append_text (sc);

    \ \ glue_path_touch (sc);

    }

    \;
  </cpp-chunk>

  <section|path样本类>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define-case-class path ()

    \ \ (define parts #("."))

    \ \ (define type 'posix)

    \ \ (define drive "")

    \ \ 

    \ \ (define (%set-parts! v)

    \ \ \ \ (if (rich-vector :is-type-of v)

    \ \ \ \ \ \ \ \ (set! parts (v :collect))

    \ \ \ \ \ \ \ \ (set! parts v)))

    \ \ 

    \ \ (define (%set-type! s)

    \ \ \ \ (set! type s))

    \ \ 

    \ \ (define (%set-drive! s)

    \ \ \ \ (set! drive s))

    \ \ 

    \ \ (define (%get-parts) parts)

    \ \ (define (%get-type) type)

    \ \ (define (%get-drive) drive)

    \ \ 

    \ \ (define (%copy)

    \ \ \ \ (let1 p (path)

    \ \ \ \ \ \ (p :set-parts! parts)

    \ \ \ \ \ \ (p :set-type! type)

    \ \ \ \ \ \ (p :set-drive! drive)

    \ \ \ \ \ \ p))

    \;

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (check ((path) :get-type) =\<gtr\> 'posix)

    (check ((path) :get-parts) =\<gtr\> #("."))

    \;
  </scm-chunk>

  <subsection|构造器>

  <paragraph|path@of-drive>

  在Windows系统上，盘符只有26中可能。

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (@of-drive ch)

    \ \ (when (not (char? ch))

    \ \ \ \ (type-error "path@of-drive must take char? as input"))

    \ \ \ \ (let1 r (path)

    \ \ \ \ \ \ \ \ (r :set-type! 'windows)

    \ \ \ \ \ \ \ \ (r :set-drive! ($ ch :to-upper :make-string))

    \ \ \ \ \ \ \ \ (r :set-parts! #())

    \ \ \ \ \ \ \ \ r))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (check (path :of-drive #\\D :to-string) =\<gtr\> "D:\\\\")

    (check (path :of-drive #\\d :to-string) =\<gtr\> "D:\\\\")

    \;
  </scm-chunk>

  <paragraph|path@root>

  返回根目录。

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (@root)

    \ \ (let1 r (path)

    \ \ \ \ \ \ \ \ (r :set-parts! #("/"))

    \ \ \ \ \ \ \ \ r))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (check (path :root :to-string) =\<gtr\> "/")

    \;
  </scm-chunk>

  <paragraph|path@from-parts>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (@from-parts x)\ 

    \ \ \ (let1 r (path)

    \ \ \ \ \ (r :set-parts! x)

    \ \ \ \ \ r))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (or (os-macos?) (os-linux?))

    \ \ (check (path :from-parts #("/" "tmp")) =\<gtr\> (path :/ "tmp"))

    \ \ (check (path :from-parts #("/" "tmp" "test")) =\<gtr\> (path :/ "tmp" :/ "test"))

    \ \ (check (path :from-parts #("/", "tmp") :to-string) =\<gtr\> "/tmp"))

    \;
  </scm-chunk>

  <paragraph|path@/>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (@/ x)\ 

    \ \ \ (if (path :is-type-of x)

    \ \ \ \ \ \ \ (path :root :/ x)

    \ \ \ \ \ \ \ (cond ((and (string-ends? x ":") (= (string-length x) 2))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (path :of-drive (x 0)))

    \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ ((string=? x "/") (path :root))

    \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (path :from-parts (vector-append (vector (string (os-sep))) (vector x)))))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (os-windows?)

    \ \ (check (path :/ "C:" :to-string) =\<gtr\> "C:\\\\"))

    \;

    (when (not (os-windows?))

    \ \ (check (path :/ "root" :to-string) =\<gtr\> "/root"))

    \;
  </scm-chunk>

  <paragraph|path@apply>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (@apply s)

    \ \ (cond ((and (or (os-linux?) (os-macos?))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (string-starts? s "/"))

    \ \ \ \ \ \ \ \ \ (path :/ (@apply ($ s :drop 1 :get))))

    \ \ \ \ \ \ \ \ ((and (os-windows?)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (= (string-length s) 2)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (char=? (s 1) #\\:))

    \ \ \ \ \ \ \ \ \ (path :of-drive (s 0)))

    \ \ \ \ \ \ \ \ ((and (os-windows?) (\<gtr\>= (string-length s) 3)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (char=? (s 1) #\\:)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (char=? (s 2) #\\\\))

    \ \ \ \ \ \ \ \ \ (path :of-drive (s 0)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :/ (@apply ($ s :drop 3 :get))))

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (let loop ((iter s))

    \ \ \ \ \ \ \ \ \ \ \ (cond ((or (string-null? iter) (string=? iter "."))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (path))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((not (char=? (iter 0) (os-sep)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (path :from-parts ($ iter :split (string (os-sep)))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop ($ iter :drop 1 :get))))))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (os-windows?)

    \ \ (check (path "a\\\\b") =\<gtr\> (path :./ "a" :/ "b"))

    \ \ (check (path "C:\\\\") =\<gtr\> (path :of-drive #\\C))

    \ \ (check (path "C:\\\\Users") =\<gtr\> (path :of-drive #\\C :/ "Users")))

    \;

    (when (or (os-linux?) (os-macos?))

    \ \ (check (path "a/b") =\<gtr\> (path :./ "a" :/ "b"))

    \ \ (check (path "/tmp") =\<gtr\> (path :/ "tmp"))

    \ \ (check (path "/tmp/tmp2") =\<gtr\> (path :/ "tmp" :/ "tmp2")))

    \;
  </scm-chunk>

  <paragraph|path@from-env>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (@from-env name)

    \ \ (path (getenv name)))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (os-linux?)

    \ \ (check (path :from-env "HOME" :to-string) =\<gtr\> (path :home :to-string)))

    \;

    (when (os-windows?)

    \ \ (check (path :from-env "USERPROFILE" :to-string) =\<gtr\> (path :home :to-string)))

    \;
  </scm-chunk>

  <subsection|选择器>

  <paragraph|path%name>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%name)

    \ \ (if (string=? "." ($ parts :last))

    \ \ \ \ \ \ ""

    \ \ \ \ \ \ ($ parts :last)))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (check (path "file.txt" :name) =\<gtr\> "file.txt")

    (check (path "archive.tar.gz" :name) =\<gtr\> "archive.tar.gz")\ 

    (check (path ".hidden" :name) =\<gtr\> ".hidden")\ 

    (check (path "noext" :name) =\<gtr\> "noext") \ \ \ 

    (check (path "" :name) =\<gtr\> "") \ ; 空路径

    (check (path "." :name) =\<gtr\> "") \ ; 当前目录

    (check (path ".." :name) =\<gtr\> "..") \ ; 上级目录

    \;

    (when (or (os-macos?) (os-linux?))

    \ \ (check (path "/path/to/file.txt" :name) =\<gtr\> "file.txt"))

    \;
  </scm-chunk>

  \;

  <paragraph|path%stem>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%stem)

    \ \ (define last-part-str\ 

    \ \ \ \ (if (\<gtr\> (vector-length parts) 0)

    \ \ \ \ \ \ \ \ (vector-ref parts (- (vector-length parts) 1))

    \ \ \ \ \ \ \ \ ""))

    \ \ 

    \ \ (define (drop-suffix str)

    \ \ \ \ (let* ((rich-str ($ str))

    \ \ \ \ \ \ \ \ \ \ \ (rich-splits (rich-str :split ".")) \ ; 按点分割

    \ \ \ \ \ \ \ \ \ \ \ (count (rich-splits :count))) \ ; 获取分割数量

    \ \ \ \ \ \ (cond ((\<less\>= count 1) str) \ ; 无后缀或单一部分

    \ \ \ \ \ \ \ \ \ \ \ \ ((string=? str ".") "") \ ; 当前目录特殊处理

    \ \ \ \ \ \ \ \ \ \ \ \ ((string=? str "..") "..") ; 上级目录特殊处理

    \ \ \ \ \ \ \ \ \ \ \ \ ((and (string=? (rich-splits 0) "") \ ; 以点开头

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (= count 2)) \ ; 且只有一个点（纯隐藏文件）

    \ \ \ \ \ \ \ \ \ \ \ \ \ str) \ ; 保留完整文件名

    \ \ \ \ \ \ \ \ \ \ \ \ (else \ ; 正常多后缀情况

    \ \ \ \ \ \ \ \ \ \ \ \ \ (rich-splits :take (- count 1) :make-string ".")))))

    \ \ 

    \ \ (drop-suffix (%name)))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (check (path "file.txt" :stem) =\<gtr\> "file")

    (check (path "archive.tar.gz" :stem) =\<gtr\> "archive.tar") \ ; 只去掉最后一个后缀

    (check (path ".hidden" :stem) =\<gtr\> ".hidden") \ ; 隐藏文件保留完整名称

    (check (path "noext" :stem) =\<gtr\> "noext") \ ; 无后缀名保留完整名称

    (check (path "" :stem) =\<gtr\> "") \ ; 空路径

    (check (path "." :stem) =\<gtr\> "") \ ; 当前目录

    (check (path ".." :stem) =\<gtr\> "..") \ ; 上级目录

    (when (or (os-linux?) (os-macos?))

    \ \ (check (path "/path/to/file.txt" :stem) =\<gtr\> "file")) \ 

    \;
  </scm-chunk>

  <paragraph|path%suffix>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%suffix)

    \ \ (let* ((name (%name))

    \ \ \ \ \ \ \ \ \ (rich-str ($ name))

    \ \ \ \ \ \ \ \ \ (rich-splits (rich-str :split "."))

    \ \ \ \ \ \ \ \ \ (count (rich-splits :count)))

    \ \ \ \ (cond ((\<less\>= count 1) "") \ ; 无后缀

    \ \ \ \ \ \ \ \ \ \ ((string=? name ".") "") \ ; 当前目录

    \ \ \ \ \ \ \ \ \ \ ((string=? name "..") "") ; 上级目录

    \ \ \ \ \ \ \ \ \ \ ((and (string=? (rich-splits 0) "") \ ; 以点开头

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (= count 2)) \ ; 且只有一个点（纯隐藏文件）

    \ \ \ \ \ \ \ \ \ \ \ "")

    \ \ \ \ \ \ \ \ \ \ (else\ 

    \ \ \ \ \ \ \ \ \ \ \ (string-append "." (rich-splits :last)))))) \ ; 返回最后一部分

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (check (path "file.txt" :suffix) =\<gtr\> ".txt")

    (check (path "archive.tar.gz" :suffix) =\<gtr\> ".gz") \ ; 只保留最后一个后缀

    (check (path ".hidden" :suffix) =\<gtr\> "") \ 

    (check (path "noext" :suffix) =\<gtr\> "") \ 

    (check (path "/path/to/file.txt" :suffix) =\<gtr\> ".txt") \ ; 绝对路径

    (check (path "C:/path/to/file.txt" :suffix) =\<gtr\> ".txt") \ ; Windows路径

    (check (path "" :suffix) =\<gtr\> "") \ ; 空路径

    (check (path "." :suffix) =\<gtr\> "") \ ; 当前目录

    (check (path ".." :suffix) =\<gtr\> "") \ ; 上级目录

    \;
  </scm-chunk>

  <subsection|谓词>

  <paragraph|path%equals>

  重写define-case-class自动生成equals函数。

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%equals that)

    \ \ (if (path :is-type-of that)

    \ \ \ \ \ \ (string=? (%to-string) (that :to-string))

    \ \ \ \ \ \ #f))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (check-true ((path "/tmp/test") :equals (path "/tmp/test")))

    \;
  </goldfish-chunk>

  <paragraph|path%file?>

  判断当前的路径是否是文件。注意哪怕文件没有后缀名，例如<with|font-family|tt|/tmp/test>,其中test是个无后缀名的文件，<with|font-family|tt|file?>依旧可以判断其为file返回<with|font-family|tt|#t>。同样，如果<with|font-family|tt|/tmp/test>,其中test是个空文件夹，<with|font-family|tt|file?>依旧可以判断其非file返回<with|font-family|tt|#f>。此api设计参考Python, 示例如下：

  <\session|python|default>
    <\input>
      \<gtr\>\<gtr\>\<gtr\>\ 
    <|input>
      from pathlib import Path
    </input>

    <\input>
      \<gtr\>\<gtr\>\<gtr\>\ 
    <|input>
      import os
    </input>

    <\input>
      \<gtr\>\<gtr\>\<gtr\>\ 
    <|input>
      # Change to home directory

      home_dir = os.path.expanduser("~")

      os.chdir(home_dir)
    </input>

    <\input>
      \<gtr\>\<gtr\>\<gtr\>\ 
    <|input>
      os.mkdir("emptydir")
    </input>

    <\unfolded-io>
      \<gtr\>\<gtr\>\<gtr\>\ 
    <|unfolded-io>
      Path("emptydir").is_dir()
    <|unfolded-io>
      True
    </unfolded-io>

    <\folded-io>
      \<gtr\>\<gtr\>\<gtr\>\ 
    <|folded-io>
      Path("emptydir").is_file()
    <|folded-io>
      False
    </folded-io>

    <\input>
      \<gtr\>\<gtr\>\<gtr\>\ 
    <|input>
      Path("emptydir").rmdir()
    </input>
  </session>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%file?)

    \ \ (path-file? (%to-string)))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (or (os-linux?) (os-macos?))

    \ \ (check-false (path :/ "tmp" :file?))

    \ \ (chdir "/tmp")

    \ \ (mkdir "tmpxxxx")\ 

    \ \ (check-false (path :from-parts #("/" "tmp" "/" "tmpxxxx") :file?))

    \ \ (rmdir "tmpxxxx"))

    \;
  </scm-chunk>

  <paragraph|path%dir?>

  判断当前的路径是否是目录。注意在Goldfish Scheme中，不存在的路径均被视为非目录。

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%dir?)

    \ \ (path-dir? (%to-string)))\ 

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (or (os-linux?) (os-macos?))

    \ \ (check-true (path :/ "tmp" :dir?))

    \ \ (check-true (path :/ "tmp/" :dir?))

    \ \ (check-false (path :from-parts #("/" "tmpxxxx") :dir?))

    \ \ (check-true (path :from-parts #("/" "tmp" "") :dir?))

    \ \ (chdir "/tmp")

    \ \ (mkdir "tmpxxxx")

    \ \ (check-true (path :from-parts #("/" "tmp" "/" "tmpxxxx" "") :dir?))

    \ \ (rmdir "tmpxxxx"))

    \;
  </scm-chunk>

  <paragraph|path%absolute?>

  判断当前的路径是否是绝对路径。

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%absolute?)

    \ \ \ (case type

    \ \ \ \ \ ((posix) (string-starts? (parts 0) "/"))

    \ \ \ \ 

    \ \ \ \ \ ((windows) (not ($ drive :empty?)))

    \ \ \ \ 

    \ \ \ \ \ (else

    \ \ \ \ \ \ \ (value-error

    \ \ \ \ \ \ \ \ \ (string-append "path%absolute?: unknown type" (symbol-\<gtr\>string type))))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (check-false ((path) :absolute?))

    (check (path :/ "C:" :get-type) =\<gtr\> 'windows)

    (check (path :/ "C:" :get-parts) =\<gtr\> #())

    (check-true (path :/ "C:" :absolute?))

    (check-true (path :from-parts #("/" "tmp") :absolute?))

    (check-false (path :from-parts #("tmp") :absolute?))

    \;
  </scm-chunk>

  \;

  <paragraph|path%relative?>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%relative)

    \ \ (not (%absolute?)))

    \;
  </goldfish-chunk>

  <paragraph|path%exists?>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%exists?)

    \ \ (path-exists? (%to-string)))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (or (os-linux?) (os-macos?))

    \ \ (check-true (path :/ "tmp" :exists?)))

    \;
  </scm-chunk>

  <subsection|转换器>

  <paragraph|path%to-string>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%to-string)

    \ \ (case type

    \ \ \ \ ((posix)

    \ \ \ \ \ (let1 s ($ parts :make-string (string (os-sep)))

    \ \ \ \ \ \ \ \ (if (and (\<gtr\> ($ s :length) 1) (string-starts? s (string (os-sep))))

    \ \ \ \ \ \ \ \ \ \ \ \ (string-drop s 1)

    \ \ \ \ \ \ \ \ \ \ \ \ s)))

    \ \ \ \ ((windows)

    \ \ \ \ \ (let1 s ($ parts :make-string "\\\\")

    \ \ \ \ \ \ \ (if (string-null? drive)

    \ \ \ \ \ \ \ \ \ \ \ s

    \ \ \ \ \ \ \ \ \ \ \ (string-append drive ":\\\\" s))))

    \ \ \ \ (else (value-error "path%to-string: unknown type" type))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (not (os-windows?))

    \ \ (check (path :/ "etc" :/ "passwd" :to-string) =\<gtr\> "/etc/passwd"))

    \;

    (when (os-windows?)

    \ \ (check (path :of-drive #\\C :to-string) =\<gtr\> "C:\\\\"))

    \;
  </scm-chunk>

  <subsection|实用方法>

  <paragraph|path%read-text>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%read-text)

    \ \ (path-read-text (%to-string)))

    \;
  </goldfish-chunk>

  <paragraph|path%write-text>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (typed-define (%write-text (content string?))

    \ \ (path-write-text (%to-string) content))

    \;
  </goldfish-chunk>

  <paragraph|path%append-text>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (typed-define (%append-text (content string?))

    \ \ (path-append-text (%to-string) content))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    ;; path%append-text 测试

    (let ((p (path :temp-dir :/ "append_test.txt")))

    \ \ ;; 确保文件不存在

    \ \ (when (p :exists?) (p :unlink))

    \ \ 

    \ \ ;; 测试追加到新文件

    \ \ (p :append-text "First line\\n")

    \ \ (when (or (os-linux?) (os-macos?))

    \ \ \ \ (check (p :read-text) =\<gtr\> "First line\\n"))

    \ \ 

    \ \ ;; 测试追加到已有文件

    \ \ (p :append-text "Second line\\n")

    \ \ (when (or (os-linux?) (os-macos?))

    \ \ \ \ (check (p :read-text) =\<gtr\> "First line\\nSecond line\\n"))

    \ \ 

    \ \ ;; 清理

    \ \ (p :unlink))

    \;
  </scm-chunk>

  <paragraph|path%list>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%list)

    \ \ (box (listdir (%to-string))))

    \;
  </goldfish-chunk>

  <paragraph|path%list-path>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%list-path)

    \ \ ((box (listdir (%to-string)))

    \ \ \ :map (lambda (x) ((%this) :/ x))))

    \;
  </goldfish-chunk>

  注意到在不同系统里换行符的标准是不一样的

  <\enumerate>
    <item><strong|不同系统的换行符标准>：

    <\itemize>
      <item>Unix/Linux/macOS: 使用<nbsp><code*|\\n><nbsp>(LF)

      <item>Windows: 使用<nbsp><code*|\\r\\n><nbsp>(CRLF)
    </itemize>

    <item><strong|问题表现>：

    <\itemize>
      <item>在Windows上写入<code*|\\n>时，系统可能会自动转换为<code*|\\r\\n>

      <item>但读取时可能保持原始<code*|\\n>或转换为系统标准

      <item>导致字符串比较失败
    </itemize>
  </enumerate>

  以下为一个案例：

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (let ((p (path :temp-dir :/ "append_test.txt"))

    \ \ \ \ \ \ (p-windows (path :temp-dir :/ "append_test_windows.txt")))

    \ \ ;; 确保文件不存在

    \ \ (when (p :exists?) (p :unlink))

    \ \ (when (p-windows :exists?) (p-windows :unlink))

    \ \ 

    \ \ (p :append-text "Line 1\\n")

    \ \ (p-windows :append-text "Line 1\\r\\n")

    \ \ (when (or (os-linux?) (os-macos?))

    \ \ \ \ (check (p :read-text) =\<gtr\> "Line 1\\n"))

    \ \ (when (os-windows?)

    \ \ \ \ (check (p-windows :read-text) =\<gtr\> "Line 1\\r\\n"))

    \ \ 

    \ \ ;; 清理

    \ \ (p :unlink)

    \ \ (p-windows :unlink))
  </scm-chunk>

  <paragraph|path%touch>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%touch)

    \ \ (path-touch (%to-string)))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (let1 test-file (string-append (os-temp-dir) (string (os-sep)) "test_touch.txt")

    \ \ ;; Ensure file doesn't exist initially

    \ \ (when (file-exists? test-file)

    \ \ \ \ (delete-file test-file))

    \ \ 

    \ \ ;; Test creating new file with path object

    \ \ (let1 p (path test-file)

    \ \ \ \ (check-false (p :exists?))

    \ \ \ \ (check-true (p :touch))

    \ \ \ \ (check-true (p :exists?)))

    \ \ 

    \ \ ;; Clean up

    \ \ (delete-file test-file))

    \;

    ;; Test with very long path

    (let ((long-name (make-string 200 #\\x))

    \ \ \ \ \ \ (temp-dir (os-temp-dir)))

    \ \ (let ((p (path temp-dir :/ long-name)))

    \ \ \ \ (check-true (p :touch))

    \ \ \ \ (check-true (p :exists?))

    \ \ \ \ (p :unlink)))

    \;
  </scm-chunk>

  <subsection|修改器>

  <paragraph|path%/>

  在当前路径下追加目录、文件或者路径。

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (%/ x)

    \ \ (cond ((string? x)

    \ \ \ \ \ \ \ \ \ (let1 new-path (%copy)

    \ \ \ \ \ \ \ \ \ \ \ \ (new-path :set-parts! (vector-append parts (vector x)))

    \ \ \ \ \ \ \ \ \ \ \ \ new-path))

    \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ ((path :is-type-of x)

    \ \ \ \ \ \ \ \ \ (cond ((x :absolute?)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (value-error "path to append must not be absolute path: " (x :to-string)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((string=? (x :to-string) ".")

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (%this))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else (let ((new-path (%copy))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (x-parts (x :get-parts)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (os-windows?)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (new-path :set-parts! x-parts)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (new-path :set-parts! (vector-append (vector (string (os-sep))) x-parts)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ new-path))))

    \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ (else (type-error "only string?, path is allowed"))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (not (os-windows?))

    \ \ (check (path :/ "etc" :/ "host" :to-string) =\<gtr\> "/etc/host")

    \ \ (check (path :/ (path "a/b")) =\<gtr\> (path "/a/b")))

    \;

    (check-catch 'value-error (path :/ (path "/a/b")))

    \;
  </scm-chunk>

  <paragraph|path%parent>

  返回当前路径的父目录

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (%parent) \ \ 

    \ \ (define (parts-drop-right parts x)

    \ \ \ \ \ (let1 path-vec ($ parts :drop-right x)

    \ \ \ \ \ \ \ (let1 new-path (%copy)

    \ \ \ \ \ \ \ \ \ (if (path-vec :empty?)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (if (os-windows?)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (new-path :set-parts! #(""))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (new-path :set-parts! #(".")))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (new-path :set-parts! (path-vec :append #(""))))

    \ \ \ \ \ \ \ \ \ new-path)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ (cond

    \ \ \ \ ((or (equal? #("/") parts) (equal? #(".") parts))

    \ \ \ \ \ (%this))

    \ \ \ \ ((or (os-macos?) (os-linux?))

    \ \ \ \ \ (let1 last-part (($ parts) :take-right 1 :collect)

    \ \ \ \ \ \ \ \ \ \ \ (if (equal? last-part #(""))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (parts-drop-right parts 2)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (parts-drop-right parts 1))))

    \ \ \ \ ((os-windows?)

    \ \ \ \ \ (if ($ parts :empty?)

    \ \ \ \ \ \ \ \ \ (%this)

    \ \ \ \ \ \ \ \ \ (let1 last-part (($ parts) :take-right 1 :collect)

    \ \ \ \ \ \ \ \ \ \ \ (if (equal? last-part #(""))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (parts-drop-right parts 2)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (parts-drop-right parts 1)))))

    \ \ \ \ 

    \ \ \ \ (else (??? "Unsupported platform"))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (or (os-linux?) (os-macos?))

    \ \ (check (path "/" :parent :to-string) =\<gtr\> "/")

    \ \ (check (path "" :parent :to-string) =\<gtr\> ".")

    \ \ (check (path "/tmp/" :parent :to-string) =\<gtr\> "/")

    \ \ (check (path "/tmp/test" :parent :parent :to-string) =\<gtr\> "/")

    \ \ (check (path "tmp/test" :parent :to-string) =\<gtr\> "tmp/")

    \ \ (check (path "tmp" :parent :to-string) =\<gtr\> ".")

    \ \ (check (path "tmp" :parent :parent :to-string) =\<gtr\> "."))

    \;

    (when (os-windows?)

    \ \ (check (path "C:" :parent :to-string) =\<gtr\> "C:\\\\")

    \ \ (check (path "C:\\\\Users" :parent :to-string) =\<gtr\> "C:\\\\")

    \ \ (check (path "a\\\\b" :parent :to-string) =\<gtr\> "a\\\\"))

    \;
  </scm-chunk>

  <paragraph|path%rmdir>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define (%rmdir)

    \ \ (rmdir (%to-string)))

    \;
  </goldfish-chunk>

  <paragraph|path%unlink>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (define* (%unlink (missing-ok #f)) \ ; 使用define*定义可选参数

    \ \ (let ((path-str (%to-string)))

    \ \ \ \ (cond

    \ \ \ \ \ \ ((file-exists? path-str) \ ; 文件存在时总是删除

    \ \ \ \ \ \ \ (remove path-str))

    \ \ \ \ \ \ (missing-ok \ ; 文件不存在时根据missing-ok决定

    \ \ \ \ \ \ \ #t) \ \ \ \ \ \ \ \ ; missing-ok为#t时静默返回#t

    \ \ \ \ \ \ (else \ \ \ \ \ \ \ ; missing-ok为#f时抛出错误

    \ \ \ \ \ \ \ (error 'file-not-found-error\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (string-append "File not found: " path-str))))))

    \;

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (or (os-macos?) (os-linux?))

    \ \ \ \ ;; 测试删除文件

    \ \ (let ((test-file (string-append (os-temp-dir) "/test_delete.txt")))

    \ \ \ \ ;; 创建临时文件

    \ \ \ \ (with-output-to-file test-file

    \ \ \ \ \ \ (lambda () (display "test data")))

    \ \ \ \ ;; 验证文件存在

    \ \ \ \ (check-true (file-exists? test-file))

    \ \ \ \ ;; 删除文件（使用 remove）

    \ \ \ \ (check-true (remove test-file))

    \ \ \ \ ;; 验证文件已删除

    \ \ \ \ (check-false (file-exists? test-file))))

    \;

    (when (or (os-macos?) (os-linux?))

    \ \ ;; 测试删除目录

    \ \ (let ((test-dir (string-append (os-temp-dir) "/test_delete_dir")))

    \ \ \ \ ;; 创建临时目录

    \ \ \ \ (mkdir test-dir)

    \ \ \ \ ;; 验证目录存在

    \ \ \ \ (check-true (file-exists? test-dir))

    \ \ \ \ ;; 删除目录（使用 rmdir）

    \ \ \ \ (check-true (rmdir test-dir))

    \ \ \ \ ;; 验证目录已删除

    \ \ \ \ (check-false (file-exists? test-dir))))

    \;

    (when (or (os-macos?) (os-linux?))

    \ \ ;; 测试 path 对象的 :unlink 和 :rmdir

    \ \ (let ((test-file (string-append (os-temp-dir) "/test_path_unlink.txt")))

    \ \ \ \ (with-output-to-file test-file

    \ \ \ \ \ \ (lambda () (display "test data")))

    \ \ \ \ (check-true ((path test-file) :unlink))

    \ \ \ \ (check-false (file-exists? test-file))))

    \;

    (when (or (os-macos?) (os-linux?))

    \ \ (let ((test-dir (string-append (os-temp-dir) "/test_path_rmdir")))

    \ \ \ \ (mkdir test-dir)

    \ \ \ \ (check-true ((path test-dir) :rmdir))

    \ \ \ \ (check-false (file-exists? test-dir))))

    \;

    (when (or (os-macos?) (os-linux?))

    \ \ ;; 测试各种调用方式

    \ \ (let ((test-file "/tmp/test_unlink.txt"))

    \ \ \ \ ;; 默认行为 (missing-ok=#f)

    \ \ \ \ (check-catch 'file-not-found-error

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((path test-file) :unlink))

    \ \ 

    \ \ \ \ ;; 显式指定 missing-ok=#t

    \ \ \ \ (check-true ((path test-file) :unlink #t))

    \ \ 

    \ \ \ \ ;; 文件存在时的测试

    \ \ \ \ (with-output-to-file test-file

    \ \ \ \ \ \ (lambda () (display "test")))

    \ \ \ \ (check-true ((path test-file) :unlink))

    \ \ \ \ (check-false (file-exists? test-file))))

    \;
  </scm-chunk>

  <subsection|静态方法>

  <paragraph|path@./>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (@./ x)

    \ \ (let1 p (path x)

    \ \ \ \ \ \ \ \ (if (p :absolute?)

    \ \ \ \ \ \ \ \ \ \ \ \ (value-error "path@./: only accecpt relative path")

    \ \ \ \ \ \ \ \ \ \ \ \ (path x))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (check (path :./ "a" :to-string) =\<gtr\> "a")

    \;

    (when (not (os-windows?))

    \ \ (check (path :./ "a" :/ "b" :/ "c" :to-string) =\<gtr\> "a/b/c"))

    \;
  </scm-chunk>

  <paragraph|path@cwd>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (@cwd)

    \ \ (path (getcwd)))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (or (os-linux?) (os-macos?))

    \ \ (check-true (path :cwd :dir?)))

    \;
  </scm-chunk>

  <paragraph|path@home>

  获取当前系统的家目录，在macOS和Linux上采用HOME环境变量，在Windows上采用HOMEDRIVE和HOMEPATH的组合。

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (@home)

    \ \ (cond ((or (os-linux?) (os-macos?))

    \ \ \ \ \ \ \ \ \ (path (getenv "HOME")))

    \ \ \ \ \ \ \ \ ((os-windows?)

    \ \ \ \ \ \ \ \ \ (path :of-drive ((getenv "HOMEDRIVE") 0)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :/ (path (getenv "HOMEPATH"))))

    \ \ \ \ \ \ \ \ (else (value-error "path@home: unknown type"))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    (when (or (os-linux?) (os-macos?))

    \ \ (check ((path :home) :to-string) =\<gtr\> (getenv "HOME")))

    \;

    (when (os-windows?)

    \ \ (check (path :home)

    \ \ \ =\<gtr\> \ \ \ (path :/ (getenv "HOMEDRIVE") :/ "Users" :/ (getenv "USERNAME"))))

    \;
  </scm-chunk>

  <paragraph|path@temp-dir>

  获取当前系统临时目录。

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    (chained-define (@temp-dir)

    \ \ (path (os-temp-dir)))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|true>
    ;; 测试 path@temp-dir 方法

    (let1 temp-path (path :temp-dir)

    \ \ ;; 验证返回的是 path 对象

    \ \ (check-true (path :is-type-of temp-path))

    \;

    \ \ ;; 验证路径存在且是目录

    \ \ (check-true (temp-path :exists?))

    \ \ (check-true (temp-path :dir?))

    \;

    \ \ ;; 验证路径与 os-temp-dir 一致

    \ \ (check (temp-path :to-string) =\<gtr\> (os-temp-dir))

    \;

    \ \ ;; 验证在不同平台下的基本特征

    \ \ (when (os-windows?)

    \ \ \ \ (check-true (string-starts? (temp-path :to-string) "C:\\\\")))

    \;

    \ \ (when (or (os-linux?) (os-macos?))

    \ \ \ \ (check-true (string-starts? (temp-path :to-string) "/"))))

    \;

    ;; 测试可以基于临时目录创建文件

    (let ((temp-file (path :temp-dir :/ "test_file.txt")))

    \ \ ;; 写入测试文件

    \ \ (temp-file :write-text "test content")

    \ \ 

    \ \ ;; 验证文件存在

    \ \ (check-true (temp-file :exists?))

    \ \ (check-true (temp-file :file?))

    \ \ 

    \ \ ;; 清理

    \ \ (temp-file :unlink))

    \;
  </scm-chunk>

  <subsection|path样本类结尾>

  <\goldfish-chunk|goldfish/liii/path.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <section|结尾>

  <\scm-chunk|tests/goldfish/liii/path-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <\goldfish-chunk|goldfish/liii/path.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </goldfish-chunk>

  <chapter|(liii datetime)>

  <section|许可证>

  <\goldfish-chunk|goldfish/liii/datetime.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </goldfish-chunk>

  <section|接口>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (define-library (liii datetime)

    (export datetime date years)

    (begin

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/datetime-test.scm|false|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii datetime))

    \;
  </goldfish-chunk>

  \;

  <section|years>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (define-object years

    \;
  </goldfish-chunk>

  <paragraph|years@leap?>

  判断某一年是否是闰年。

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (define (@leap? year)

    \ \ (when (not (integer? year))

    \ \ \ \ (type-error "years@leap? must accept integer"))

    \ \ (or (and (zero? (modulo year 4))\ 

    \ \ \ \ \ \ \ \ \ \ \ (not (zero? (modulo year 100))))

    \ \ \ \ \ \ (zero? (modulo year 400))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/datetime-test.scm|true|true>
    (check-true (years :leap? 2024))

    (check-false (years :leap? 2025))

    (check-true (years :leap? 2000))

    (check-false (years :leap? 1000))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <section|datetime>

  \;

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (define-case-class datetime

    \ \ ((year integer?)

    \ \ \ (month integer?)

    \ \ \ (day integer?)

    \ \ \ (hour integer? 0)

    \ \ \ (minute integer? 0)

    \ \ \ (second integer? 0)

    \ \ \ (micro-second integer? 0))

    \;
  </goldfish-chunk>

  <subsection|静态方法>

  <paragraph|datetime@now>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (chained-define (@now)

    \ \ (let ((time-vec (g_datetime-now)))

    \ \ \ \ (datetime\ 

    \ \ \ \ \ \ :year (vector-ref time-vec 0)

    \ \ \ \ \ \ :month (vector-ref time-vec 1)

    \ \ \ \ \ \ :day (vector-ref time-vec 2)

    \ \ \ \ \ \ :hour (vector-ref time-vec 3)

    \ \ \ \ \ \ :minute (vector-ref time-vec 4)

    \ \ \ \ \ \ :second (vector-ref time-vec 5)

    \ \ \ \ \ \ :micro-second (vector-ref time-vec 6))))

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer f_datetime_now(s7_scheme* sc, s7_pointer args) {

    \ \ // Get current time using tbox for year, month, day, etc.

    \ \ tb_time_t now = tb_time();

    \ \ 

    \ \ // Get local time

    \ \ tb_tm_t lt = {0};

    \ \ if (!tb_localtime(now, &lt)) {

    \ \ \ \ return s7_f(sc);

    \ \ }

    \ \ 

    \ \ // Use C++ chrono to get microseconds

    \ \ std::uint64_t micros = 0;

    #ifdef TB_CONFIG_OS_WINDOWS

    \ \ // On Windows, ensure we properly handle chrono

    \ \ FILETIME ft;

    \ \ ULARGE_INTEGER uli;

    \ \ GetSystemTimeAsFileTime(&ft);

    \ \ uli.LowPart = ft.dwLowDateTime;

    \ \ uli.HighPart = ft.dwHighDateTime;

    \ \ // Convert to microseconds and get modulo

    \ \ micros = (uli.QuadPart / 10) % 1000000; // Convert from 100-nanosecond intervals to microseconds

    #else

    \ \ // Standard approach for other platforms

    \ \ auto now_chrono = std::chrono::system_clock::now();

    \ \ auto duration = now_chrono.time_since_epoch();

    \ \ micros = std::chrono::duration_cast\<less\>std::chrono::microseconds\<gtr\>(duration).count() % 1000000;

    #endif

    \ \ 

    \ \ // Create a vector with the time components - vector is easier to index than list in Scheme

    \ \ s7_pointer time_vec = s7_make_vector(sc, 7);

    \ \ 

    \ \ // Fill the vector with values

    \ \ s7_vector_set(sc, time_vec, 0, s7_make_integer(sc, lt.year)); \ \ \ \ \ \ // year

    \ \ s7_vector_set(sc, time_vec, 1, s7_make_integer(sc, lt.month)); \ \ \ \ \ // month

    \ \ s7_vector_set(sc, time_vec, 2, s7_make_integer(sc, lt.mday)); \ \ \ \ \ \ // day

    \ \ s7_vector_set(sc, time_vec, 3, s7_make_integer(sc, lt.hour)); \ \ \ \ \ \ // hour

    \ \ s7_vector_set(sc, time_vec, 4, s7_make_integer(sc, lt.minute)); \ \ \ \ // minute

    \ \ s7_vector_set(sc, time_vec, 5, s7_make_integer(sc, lt.second)); \ \ \ \ // second

    \ \ s7_vector_set(sc, time_vec, 6, s7_make_integer(sc, micros)); \ \ \ \ \ \ \ // micro-second

    \ \ 

    \ \ return time_vec;

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void glue_datetime_now(s7_scheme* sc) {

    \ \ \ \ const char* name = "g_datetime-now";

    \ \ \ \ const char* desc = "(g_datetime-now) =\<gtr\> datetime, create a datetime object with current time";

    \ \ \ \ s7_define_function(sc, name, f_datetime_now, 0, 0, false, desc);

    }

    \;
  </cpp-chunk>

  <\goldfish-chunk|tests/goldfish/liii/datetime-test.scm|true|true>
    (let ((now (datetime :now)))

    \ \ (check-true (datetime :is-type-of now))

    \ \ (check-true (\<gtr\>= (now 'year) 2023)) \ ; Assuming test is run in 2023 or later

    \ \ (check-true (\<less\>= 1 (now 'month) 12))

    \ \ (check-true (\<less\>= 1 (now 'day) 31))

    \ \ (check-true (\<less\>= 0 (now 'hour) 23))

    \ \ (check-true (\<less\>= 0 (now 'minute) 59))

    \ \ (check-true (\<less\>= 0 (now 'second) 59))

    \ \ (check-true (\<less\>= 0 (now 'micro-second) 999999)))

    \;

    ;; Test microsecond functionality

    (let ((dt1 (datetime :now))

    \ \ \ \ \ \ (dt2 (datetime :now)))

    \ \ ;; Two close timestamps should have different microsecond values

    \ \ (check-true (integer? (dt1 'micro-second)))

    \ \ (check-true (integer? (dt2 'micro-second)))

    \ \ (check-true (\<less\>= 0 (dt1 'micro-second) 999999))

    \ \ (check-true (\<less\>= 0 (dt2 'micro-second) 999999)))

    \;
  </goldfish-chunk>

  <subsection|转换器>

  <paragraph|datetime%to-string>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (define (%to-string)

    \ \ (define (pad2 n) \ ; 补零到 2 位

    \ \ \ \ (if (\<less\> n 10)

    \ \ \ \ \ \ \ \ (string-append "0" (number-\<gtr\>string n))

    \ \ \ \ \ \ \ \ (number-\<gtr\>string n)))

    \ \ (define (pad6 n) \ ; 补零到 6 位（微秒）

    \ \ \ \ (let ((s (number-\<gtr\>string n)))

    \ \ \ \ \ \ (string-append (make-string (- 6 (string-length s)) #\\0) s)))

    \ \ 

    \ \ (let ((date-part (string-append (number-\<gtr\>string year) "-"

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (pad2 month) "-"

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (pad2 day)))

    \ \ \ \ \ \ \ \ (time-part (string-append (pad2 hour) ":"

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (pad2 minute) ":"

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (pad2 second))))

    \ \ \ \ (if (zero? micro-second)

    \ \ \ \ \ \ \ \ (string-append date-part " " time-part)

    \ \ \ \ \ \ \ \ (string-append date-part " " time-part "." (pad6 micro-second)))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/datetime-test.scm|true|true>
    (check ((datetime :year 2025 :month 1 :day 1) :to-string)

    \ \ =\<gtr\> "2025-01-01 00:00:00")

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/datetime-test.scm|true|true>
    (check ((datetime :year 2025 :month 1 :day 1 :micro-second 111111) :to-string)

    \ \ =\<gtr\> "2025-01-01 00:00:00.111111")

    \;

    (check ((datetime :year 2025 :month 1 :day 1 :micro-second 1) :to-string)

    \ \ =\<gtr\> "2025-01-01 00:00:00.000001")

    \;

    (check ((datetime :year 2025 :month 1 :day 1 :micro-second 999999) :to-string)

    \ \ =\<gtr\> "2025-01-01 00:00:00.999999")

    \;
  </goldfish-chunk>

  <paragraph|datetime%plus-days>

  <code*|plus-days><nbsp>是<nbsp><code*|datetime><nbsp>类的方法，用于在现有日期时间基础上<nbsp><strong|加减指定天数>，返回调整后的新<nbsp><code*|datetime><nbsp>对象。特性：

  <\itemize>
    <item>支持正数（未来日期）和负数（过去日期）

    <item>自动处理跨月、跨年的日期边界（如 2023-03-31 +1天 \<rightarrow\> 2023-04-01）

    <item>保留原始时间部分（时、分、秒、微秒）不变

    <item>返回新对象，原始对象保持不变（immutable）
  </itemize>

  <subsubsection*|实现细节>

  算法核心通过递归循环调整天数，处理逻辑分为两部分：

  <paragraph*|1. 增加天数（<code*|days-to-add><nbsp>为正）>

  <\itemize>
    <item><strong|同一月内>：若目标天数 \<leq\> 当月总天数，直接相加

    例：<code*|2023-02-10 +5天 \<rightarrow\> 2023-02-15>

    <item><strong|跨月处理> a. 计算当月剩余天数（总天数 - 当前日）b. 若剩余天数不足，进入下一月并将天数设为1 c. 递归处理剩余天数

    例：<code*|2023-01-31 +1天 \<rightarrow\> 2023-02-01>
  </itemize>

  <paragraph*|2. 减少天数（<code*|days-to-add><nbsp>为负）>

  <\itemize>
    <item><strong|同一月内>：若当前日 \<geq\> 要减的天数绝对值，直接相减

    例：<code*|2023-05-15 -5天 \<rightarrow\> 2023-05-10>

    <item><strong|跨月处理>：a. 跳到上一月，获取该月总天数 b. 从月总天数倒推调整 c. 递归处理剩余天数

    例：<code*|2023-03-01 -1天 \<rightarrow\> 2023-02-28（非闰年）>
  </itemize>

  <paragraph*|辅助逻辑>

  <\itemize>
    <item><strong|闰年判断>：

    <code|(or (and (整除4 不整除100) (整除400))>

    <item><strong|月份天数表>：

    <\itemize>
      <item>30天：4,6,9,11月

      <item>31天：1,3,5,7,8,10,12月

      <item>2月：28天（闰年29天）
    </itemize>
  </itemize>

  <paragraph*|边界示例>

  <\code>
    (datetime 2020 2 28)

    \ \<rightarrow\> +3天 \<rightarrow\> 2020-03-02（2020是闰年）

    \;

    (datetime 2023 12 31)

    \ \<rightarrow\> +1天 \<rightarrow\> 2024-01-01

    \;

    (datetime 2023 1 1) \<rightarrow\> -1天 \<rightarrow\> 2022-12-31
  </code>

  <subsubsection*|设计特点>

  <\itemize>
    <item><strong|不可变性>：生成新对象，原始数据保持不变

    <item><strong|递归优化>：逐月处理，避免复杂日期计算库依赖

    <item><strong|微秒保留>：时间部分（时/分/秒/微秒）完全继承原对象
  </itemize>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (define (%plus-days days-to-add)

    \ \ 

    \ \ (define (days-in-month m y)

    \ \ \ \ (cond ((member m '(4 6 9 11)) 30)

    \ \ \ \ \ \ \ \ \ \ ((= m 2) (if (years :leap? y) 29 28))

    \ \ \ \ \ \ \ \ \ \ (else 31)))

    \ \ 

    \ \ (let loop ((y year)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (m month)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (d day)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (remaining-days days-to-add))

    \ \ \ \ (cond

    \ \ \ \ \ \ ;; No more days to add

    \ \ \ \ \ \ ((zero? remaining-days)

    \ \ \ \ \ \ \ (datetime :year y

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :month m

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :day d

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :hour hour

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :minute minute

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :second second

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :micro-second micro-second))

    \ \ \ \ \ \ 

    \ \ \ \ \ \ ;; Adding days (positive)

    \ \ \ \ \ \ ((\<gtr\> remaining-days 0)

    \ \ \ \ \ \ \ (let ((days-in-current-month (days-in-month m y)))

    \ \ \ \ \ \ \ \ \ (if (\<less\>= (+ d remaining-days) days-in-current-month)

    \ \ \ \ \ \ \ \ \ \ \ \ \ ;; Simple case: result is within the same month

    \ \ \ \ \ \ \ \ \ \ \ \ \ (loop y m (+ d remaining-days) 0)

    \ \ \ \ \ \ \ \ \ \ \ \ \ ;; Complex case: need to move to next month

    \ \ \ \ \ \ \ \ \ \ \ \ \ (let ((next-month (if (= m 12) 1 (+ m 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (next-year (if (= m 12) (+ y 1) y)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop next-year\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ next-month\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 1\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (- (+ remaining-days d) days-in-current-month 1))))))

    \ \ \ \ \ \ 

    \ \ \ \ \ \ ;; Subtracting days (negative)

    \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ (if (\<gtr\> d (abs remaining-days))

    \ \ \ \ \ \ \ \ \ \ \ ;; Simple case: result is within the same month

    \ \ \ \ \ \ \ \ \ \ \ (loop y m (+ d remaining-days) 0)

    \ \ \ \ \ \ \ \ \ \ \ ;; Complex case: need to move to previous month

    \ \ \ \ \ \ \ \ \ \ \ (let* ((prev-month (if (= m 1) 12 (- m 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (prev-year (if (= m 1) (- y 1) y))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (days-in-prev-month (days-in-month prev-month prev-year)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (loop prev-year\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ prev-month\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ days-in-prev-month\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (+ remaining-days d))))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/datetime-test.scm|true|true>
    ;; Test plus-days with positive days

    (check ((datetime :year 2024 :month 1 :day 1) :plus-days 10)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 1 :day 11))

    \;

    (check ((datetime :year 2024 :month 1 :day 31) :plus-days 1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 2 :day 1))

    \;

    (check ((datetime :year 2024 :month 1 :day 1) :plus-days 31)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 2 :day 1))

    \;

    (check ((datetime :year 2024 :month 2 :day 28) :plus-days 1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 2 :day 29)) ; 2024 is a leap year

    \;

    (check ((datetime :year 2024 :month 2 :day 29) :plus-days 1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 3 :day 1))

    \;

    (check ((datetime :year 2023 :month 2 :day 28) :plus-days 1)\ 

    \ \ =\<gtr\> (datetime :year 2023 :month 3 :day 1)) ; 2023 is not a leap year

    \;

    (check ((datetime :year 2024 :month 12 :day 31) :plus-days 1)\ 

    \ \ =\<gtr\> (datetime :year 2025 :month 1 :day 1))

    \;

    (check ((datetime :year 2024 :month 1 :day 1) :plus-days 366)\ 

    \ \ =\<gtr\> (datetime :year 2025 :month 1 :day 1)) ; 2024 is a leap year

    \;

    ;; Test plus-days with negative days

    (check ((datetime :year 2024 :month 1 :day 11) :plus-days -10)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 1 :day 1))

    \;

    (check ((datetime :year 2024 :month 2 :day 1) :plus-days -1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 1 :day 31))

    \;

    (check ((datetime :year 2024 :month 3 :day 1) :plus-days -1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 2 :day 29)) \ ; 2024 is a leap year

    \;

    (check ((datetime :year 2023 :month 3 :day 1) :plus-days -1)\ 

    \ \ =\<gtr\> (datetime :year 2023 :month 2 :day 28)) \ ; 2023 is not a leap year

    \;

    (check ((datetime :year 2025 :month 1 :day 1) :plus-days -1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 12 :day 31))

    \;

    (check ((datetime :year 2025 :month 1 :day 1) :plus-days -365)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 1 :day 2)) ; 2024 is a leap year

    \;

    ;; Test plus-days with zero

    (check ((datetime :year 2024 :month 1 :day 1) :plus-days 0)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 1 :day 1))

    \;

    ;; Test preserving time components

    (let ((dt (datetime :year 2024 :month 1 :day 1\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :hour 12 :minute 30 :second 45 :micro-second 123456)))

    \ \ (check (dt :plus-days 10)\ 

    \ \ \ \ =\<gtr\> (datetime :year 2024 :month 1 :day 11\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :hour 12 :minute 30 :second 45 :micro-second 123456)))

    \;
  </goldfish-chunk>

  <paragraph|datetime%plus-months>

  <code*|%plus-months><nbsp>是<nbsp><code*|datetime><nbsp>类的方法，用于在现有日期时间基础上<nbsp><strong|加减指定月数>，返回调整后的新<nbsp><code*|datetime><nbsp>对象。特性：

  <\itemize>
    <item>支持正数（未来日期）和负数（过去日期）

    <item>自动处理跨年、跨月的月份计算（如<nbsp><code*|2023-12 +1月 \<rightarrow\> 2024-01>）

    <item>智能调整日期：

    <\itemize>
      <item>若原日期是某月最后一天（如31日），调整后月份无该日期时，自动设为该月最后一天

      例：<code*|2023-01-31 +1月 \<rightarrow\> 2023-02-28>（非闰年）
    </itemize>

    <item>保留原始时间部分（时、分、秒、微秒）不变

    <item>返回新对象，原始对象保持不变（immutable）
  </itemize>

  实现思路：

  <\itemize>
    <item><strong|<code*|total-months>>：将原日期转换为“绝对月数”（从公元1年1月开始计数）：

    <code|绝对月数 = (year \<times\> 12) + (month - 1) + months-to-add>

    <itemize|<item><code*|month -1><nbsp>是因为月份从1开始，但计算时需要从0开始对齐。>

    <item><strong|<code*|new-year><nbsp>和<nbsp><code*|new-month>>：通过除法和取余拆分回年份和月份：

    <\itemize>
      <item><code*|new-year = total-months \<div\> 12>（商）

      <item><code*|new-month = total-months % 12 + 1>（余数加1，恢复1-based月份）
    </itemize>
  </itemize>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (define (%plus-months months-to-add)

    \ \ (define (days-in-month m y)

    \ \ \ \ (cond ((member m '(4 6 9 11)) 30)

    \ \ \ \ \ \ \ \ \ \ ((= m 2) (if (years :leap? y) 29 28))

    \ \ \ \ \ \ \ \ \ \ (else 31)))

    \ \ 

    \ \ ;; Calculate new year and month

    \ \ (let* ((total-months (+ (+ (* year 12) month -1) months-to-add))

    \ \ \ \ \ \ \ \ \ (new-year (quotient total-months 12))

    \ \ \ \ \ \ \ \ \ (new-month (+ (remainder total-months 12) 1))

    \ \ \ \ \ \ \ \ \ ;; Adjust day if necessary

    \ \ \ \ \ \ \ \ \ (days-in-new-month (days-in-month new-month new-year))

    \ \ \ \ \ \ \ \ \ (new-day (min day days-in-new-month)))

    \ \ \ \ 

    \ \ \ \ (datetime :year new-year

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :month new-month

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :day new-day

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :hour hour

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :minute minute

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :second second

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :micro-second micro-second)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/datetime-test.scm|true|true>
    ;; Test plus-months with positive months

    (check ((datetime :year 2024 :month 1 :day 15) :plus-months 1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 2 :day 15))

    \;

    (check ((datetime :year 2024 :month 12 :day 15) :plus-months 1)\ 

    \ \ =\<gtr\> (datetime :year 2025 :month 1 :day 15))

    \;

    (check ((datetime :year 2024 :month 1 :day 15) :plus-months 12)\ 

    \ \ =\<gtr\> (datetime :year 2025 :month 1 :day 15))

    \;

    (check ((datetime :year 2024 :month 1 :day 15) :plus-months 24)\ 

    \ \ =\<gtr\> (datetime :year 2026 :month 1 :day 15))

    \;

    ;; Test date adjustment for month end dates

    (check ((datetime :year 2024 :month 1 :day 31) :plus-months 1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 2 :day 29)) ; Feb 2024 has 29 days (leap year)

    \;

    (check ((datetime :year 2023 :month 1 :day 31) :plus-months 1)\ 

    \ \ =\<gtr\> (datetime :year 2023 :month 2 :day 28)) ; Feb 2023 has 28 days (non-leap year)

    \;

    (check ((datetime :year 2024 :month 1 :day 31) :plus-months 2)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 3 :day 31)) ; March has 31 days

    \;

    (check ((datetime :year 2024 :month 1 :day 31) :plus-months 3)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 4 :day 30)) ; April has 30 days

    \;

    ;; Test plus-months with negative months

    (check ((datetime :year 2024 :month 3 :day 15) :plus-months -1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 2 :day 15))

    \;

    (check ((datetime :year 2024 :month 1 :day 15) :plus-months -1)\ 

    \ \ =\<gtr\> (datetime :year 2023 :month 12 :day 15))

    \;

    (check ((datetime :year 2024 :month 12 :day 15) :plus-months -12)\ 

    \ \ =\<gtr\> (datetime :year 2023 :month 12 :day 15))

    \;

    ;; Test date adjustment for month end dates with negative months

    (check ((datetime :year 2024 :month 3 :day 31) :plus-months -1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 2 :day 29)) ; Feb 2024 has 29 days (leap year)

    \;

    (check ((datetime :year 2023 :month 3 :day 31) :plus-months -1)\ 

    \ \ =\<gtr\> (datetime :year 2023 :month 2 :day 28)) ; Feb 2023 has 28 days (non-leap year)

    \;

    ;; Test plus-months with zero

    (check ((datetime :year 2024 :month 1 :day 15) :plus-months 0)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 1 :day 15))

    \;

    ;; Test preserving time components

    (let ((dt (datetime :year 2024 :month 1 :day 15\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :hour 12 :minute 30 :second 45 :micro-second 123456)))

    \ \ (check (dt :plus-months 1)\ 

    \ \ \ \ =\<gtr\> (datetime :year 2024 :month 2 :day 15\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :hour 12 :minute 30 :second 45 :micro-second 123456)))

    \;
  </goldfish-chunk>

  <paragraph|datetime%plus-years>

  闰年处理逻辑与<verbatim|python>一致

  <\code>
    (check ((datetime :year 2024 :month 2 :day 29) :plus-years 1)\ 

    \ \ =\<gtr\> (datetime :year 2025 :month 2 :day 28))
  </code>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (define (%plus-years years-to-add)

    \ \ (define (days-in-month m y)

    \ \ \ \ (cond ((member m '(4 6 9 11)) 30)

    \ \ \ \ \ \ \ \ \ \ ((= m 2) (if (years :leap? y) 29 28))

    \ \ \ \ \ \ \ \ \ \ (else 31)))

    \ \ 

    \ \ ;; Calculate new year

    \ \ (let* ((new-year (+ year years-to-add))

    \ \ \ \ \ \ \ \ \ ;; Adjust day if necessary (for Feb 29 in leap years)

    \ \ \ \ \ \ \ \ \ (days-in-new-month (days-in-month month new-year))

    \ \ \ \ \ \ \ \ \ (new-day (min day days-in-new-month)))

    \ \ \ \ 

    \ \ \ \ (datetime :year new-year

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :month month

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :day new-day

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :hour hour

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :minute minute

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :second second

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :micro-second micro-second)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/datetime-test.scm|true|true>
    ;; Test plus-years with positive years

    (check ((datetime :year 2024 :month 1 :day 15) :plus-years 1)\ 

    \ \ =\<gtr\> (datetime :year 2025 :month 1 :day 15))

    \;

    (check ((datetime :year 2024 :month 2 :day 29) :plus-years 1)\ 

    \ \ =\<gtr\> (datetime :year 2025 :month 2 :day 28))

    \;

    (check ((datetime :year 2024 :month 2 :day 29) :plus-years 1)\ 

    \ \ =\<gtr\> (datetime :year 2025 :month 2 :day 28)) ; Feb 29 -\<gtr\> Feb 28 (non-leap year)

    \;

    (check ((datetime :year 2024 :month 2 :day 29) :plus-years 4)\ 

    \ \ =\<gtr\> (datetime :year 2028 :month 2 :day 29)) ; Feb 29 -\<gtr\> Feb 29 (leap year)

    \;

    (check ((datetime :year 2024 :month 2 :day 29) :plus-years 100)\ 

    \ \ =\<gtr\> (datetime :year 2124 :month 2 :day 29)) ; 2124 is also a leap year

    \;

    ;; Test plus-years with negative years

    (check ((datetime :year 2025 :month 1 :day 15) :plus-years -1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 1 :day 15))

    \;

    (check ((datetime :year 2025 :month 2 :day 28) :plus-years -1)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 2 :day 28))

    \;

    (check ((datetime :year 2025 :month 2 :day 28) :plus-years -5)\ 

    \ \ =\<gtr\> (datetime :year 2020 :month 2 :day 28)) ; 2020 is a leap year

    \;

    ;; Test plus-years with zero

    (check ((datetime :year 2024 :month 1 :day 15) :plus-years 0)\ 

    \ \ =\<gtr\> (datetime :year 2024 :month 1 :day 15))

    \;

    ;; Test preserving time components

    (let ((dt (datetime :year 2024 :month 1 :day 15\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :hour 12 :minute 30 :second 45 :micro-second 123456)))

    \ \ (check (dt :plus-years 1)\ 

    \ \ \ \ =\<gtr\> (datetime :year 2025 :month 1 :day 15\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :hour 12 :minute 30 :second 45 :micro-second 123456)))

    \;
  </goldfish-chunk>

  <subparagraph|结尾>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <section|date>

  \;

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (define-case-class date

    \ \ ((year integer?)

    \ \ \ (month integer?)

    \ \ \ (day integer?))

    \;
  </goldfish-chunk>

  <subsection|静态方法>

  <paragraph|date@now>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (chained-define (@now)

    \ \ (let ((time-vec (g_date-now)))

    \ \ \ \ (date\ 

    \ \ \ \ \ \ :year (vector-ref time-vec 0)

    \ \ \ \ \ \ :month (vector-ref time-vec 1)

    \ \ \ \ \ \ :day (vector-ref time-vec 2))))

    \;
  </goldfish-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static s7_pointer f_date_now(s7_scheme* sc, s7_pointer args) {

    \ \ // Get current time using tbox for year, month, day, etc.

    \ \ tb_time_t now = tb_time();

    \ \ 

    \ \ // Get local time

    \ \ tb_tm_t lt = {0};

    \ \ if (!tb_localtime(now, &lt)) {

    \ \ \ \ return s7_f(sc);

    \ \ }

    \ \ 

    \ \ // Create a vector with the time components - vector is easier to index than list in Scheme

    \ \ s7_pointer time_vec = s7_make_vector(sc, 3);

    \ \ 

    \ \ // Fill the vector with values

    \ \ s7_vector_set(sc, time_vec, 0, s7_make_integer(sc, lt.year)); \ \ \ \ \ \ // year

    \ \ s7_vector_set(sc, time_vec, 1, s7_make_integer(sc, lt.month)); \ \ \ \ \ // month

    \ \ s7_vector_set(sc, time_vec, 2, s7_make_integer(sc, lt.mday)); \ \ \ \ \ \ // day

    \ \ 

    \ \ return time_vec;

    }

    \;
  </cpp-chunk>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void glue_date_now(s7_scheme* sc) {

    \ \ \ \ const char* name = "g_date-now";

    \ \ \ \ const char* desc = "(g_date-now) =\<gtr\> date, create a date object with current date";

    \ \ \ \ s7_define_function(sc, name, f_date_now, 0, 0, false, desc);

    }

    \;
  </cpp-chunk>

  <\goldfish-chunk|tests/goldfish/liii/datetime-test.scm|true|true>
    (check-true (\<gtr\> ((date :now) 'year) 2023))

    \;
  </goldfish-chunk>

  <subsection|转换器>

  <paragraph|date%to-string>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    (define (%to-string)

    \ \ (define (pad2 n) \ ; 补零到 2 位

    \ \ \ \ (if (\<less\> n 10)

    \ \ \ \ \ \ \ \ (string-append "0" (number-\<gtr\>string n))

    \ \ \ \ \ \ \ \ (number-\<gtr\>string n)))

    \ \ 

    \ \ (let ((date-part (string-append (number-\<gtr\>string year) "-"

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (pad2 month) "-"

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (pad2 day))))

    \ \ \ \ \ \ \ date-part))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/datetime-test.scm|true|true>
    (check ((date :year 2025 :month 1 :day 1) :to-string)

    \ \ =\<gtr\> "2025-01-01")

    \;

    (check ((date :year 2025 :month 12 :day 1) :to-string)

    \ \ =\<gtr\> "2025-12-01")

    \;

    (check ((date :year 2025 :month 3 :day 4) :to-string)

    \ \ =\<gtr\> "2025-03-04")

    \;

    (check ((date :year 2025 :month 4 :day 12) :to-string)

    \ \ =\<gtr\> "2025-04-12")

    \;
  </goldfish-chunk>

  \;

  <paragraph|glue_datetime>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    inline void

    glue_liii_datetime (s7_scheme* sc) {

    \ \ glue_datetime_now (sc);

    \ \ glue_date_now (sc);

    }

    \;
  </cpp-chunk>

  <subparagraph|结尾>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <section|结尾>

  <\goldfish-chunk|goldfish/liii/datetime.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/datetime-test.scm|true|false>
    (check-report)

    \;
  </goldfish-chunk>

  <chapter|(liii argparse)>

  <section|协议>

  <\scm-chunk|goldfish/liii/argparse.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/argparse-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/argparse.scm|true|true>
    (define-library (liii argparse)

    (import (liii base)

    \ \ \ \ \ \ \ \ (liii error)

    \ \ \ \ \ \ \ \ (liii list)

    \ \ \ \ \ \ \ \ (liii string)

    \ \ \ \ \ \ \ \ (liii hash-table)

    \ \ \ \ \ \ \ \ (liii alist)

    \ \ \ \ \ \ \ \ (liii sys))

    (export make-argument-parser)

    (begin

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/argparse-test.scm|true|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii argparse))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <subparagraph|测试命令行参数的类型>

  <\scm-chunk|tests/goldfish/liii/argparse-test.scm|true|true>
    (let ((parser (make-argument-parser)))

    \ \ (parser 'add-argument

    \ \ \ \ '((name . "name") (type . string) (short . "n") (default . "anonymous")))

    \ \ (check (parser 'name) =\<gtr\> "anonymous")

    \ \ (parser 'parse-args '("--name" "john"))

    \ \ (check (parser 'name) =\<gtr\> "john"))

    \;
  </scm-chunk>

  <subparagraph|测试命令行参数的两种形式>

  <\scm-chunk|tests/goldfish/liii/argparse-test.scm|true|true>
    (let ((parser (make-argument-parser)))

    \ \ (parser 'add-argument

    \ \ \ \ '((name . "width") (type . number) (short . "width") (default . 80)))

    \;

    \ \ (check (parser 'get-argument "width") =\<gtr\> 80)

    \;

    \ \ (parser 'parse-args '("--width" "100"))

    \ \ (check (parser 'get-argument "width") =\<gtr\> 100)

    \ \ (check (parser 'width) =\<gtr\> 100)

    \;

    \ \ (parser 'parse-args '("-width" "60"))

    \ \ (check (parser 'width) =\<gtr\> 60))

    \;

    (let ((parser (make-argument-parser)))

    \ \ (parser 'add-argument

    \ \ \ \ '((name . "height") (type . number) (default . 60))) \ ; without short name

    \ \ (parser 'parse-args '("--height" "120"))

    \ \ (check (parser 'get-argument "height") =\<gtr\> 120))

    \;
  </scm-chunk>

  <subparagraph|测试多个命令行参数多种类型>

  <\scm-chunk|tests/goldfish/liii/argparse-test.scm|true|true>
    (let ((parser (make-argument-parser)))

    \ \ (parser 'add-argument

    \ \ \ \ '((name . "width") (type . number) (short . "w") (default . 80)))

    \ \ (parser 'add-argument\ 

    \ \ \ \ '((name . "title") (type . string) (default . "Untitled")))

    \ \ (parser 'parse-args '("-w" "100" "--title" "My Document"))

    \ \ (check (parser 'get-argument "width") =\<gtr\> 100)

    \ \ (check (parser 'get-argument "title") =\<gtr\> "My Document"))

    \;
  </scm-chunk>

  <section|实现>

  <paragraph|make-arg-record>

  <todo|使用define-record-type>

  <\scm-chunk|goldfish/liii/argparse.scm|true|true>
    (define (make-arg-record name type short-name default)

    \ \ (list name type short-name default default))

    \;
  </scm-chunk>

  <paragraph|convert-value>

  将给定值转化为给定类型。

  <\scm-chunk|goldfish/liii/argparse.scm|true|true>
    (define (convert-value value type)

    \ \ (case type

    \ \ \ \ ((number)\ 

    \ \ \ \ \ (if (number? value)

    \ \ \ \ \ \ \ \ \ value

    \ \ \ \ \ \ \ \ \ (let ((num (string-\<gtr\>number value)))

    \ \ \ \ \ \ \ \ \ \ \ (if num\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ num

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (error "Invalid number format" value)))))

    \ \ \ \ ((string)\ 

    \ \ \ \ \ (if (string? value)

    \ \ \ \ \ \ \ \ \ value

    \ \ \ \ \ \ \ \ \ (error "Value is not a string")))

    \ \ \ \ (else (error "Unsupported type" type))))

    \;
  </scm-chunk>

  <paragraph|arg-type?>

  命令行参数的类型必须是<scm|symbol>类型的Scheme字面量。目前命令行参数仅支持两种类型：

  <\description>
    <item*|string>如果没有指定，那么参数类型默认是字符串类型。

    <item*|number>在传入参数时，参数的值是字符串，我们会调用<scm|number-\<gtr\>string>将字符串转化为Scheme的number类型。
  </description>

  \;

  <\scm-chunk|goldfish/liii/argparse.scm|true|true>
    (define (arg-type? type)

    \ \ (unless (symbol? type)

    \ \ \ \ (type-error "type of the argument must be symbol"))

    \ \ (in? type '(string number)))

    \;
  </scm-chunk>

  <paragraph|add-argument>

  新增命令行参数。

  <\scm-chunk|goldfish/liii/argparse.scm|true|true>
    (define (%add-argument args-ht args)

    \ \ (let* ((options (car args))

    \ \ \ \ \ \ \ \ \ (name (alist-ref options 'name

    \ \ \ \ \ \ \ \ \ \ \ (lambda () (value-error "name is required for an option"))))

    \ \ \ \ \ \ \ \ \ (type (alist-ref/default options 'type 'string))

    \ \ \ \ \ \ \ \ \ (short-name (alist-ref/default options 'short #f))

    \ \ \ \ \ \ \ \ \ (default (alist-ref/default options 'default #f))

    \ \ \ \ \ \ \ \ \ (arg-record (make-arg-record name type short-name default)))

    \ \ \ \ (unless (string? name)

    \ \ \ \ \ \ (type-error "name of the argument must be string"))

    \ \ \ \ (unless (arg-type? type)

    \ \ \ \ \ \ (value-error "Invalid type of the argument" type))

    \ \ \ \ (unless (or (not short-name) (string? short-name))

    \ \ \ \ \ \ (type-error "short name of the argument must be string if given"))

    \ \ \ \ (hash-table-set! args-ht name arg-record)

    \ \ \ \ (when short-name

    \ \ \ \ \ \ \ \ \ \ (hash-table-set! args-ht short-name arg-record))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/argparse-test.scm|true|true>
    (let1 parser (make-argument-parser)

    \ \ (check-catch 'type-error (parser 'add-argument '((name name))))

    \ \ (check-catch 'value-error (parser 'add-argument '())))

    \;
  </scm-chunk>

  <paragraph|get-argument>

  获得命令行参数对应的值。

  <\scm-chunk|goldfish/liii/argparse.scm|true|true>
    (define (%get-argument args-ht args)

    \ \ (let ((found (hash-table-ref/default args-ht (car args) #f)))

    \ \ \ \ (if found

    \ \ \ \ \ \ \ \ (fifth found)

    \ \ \ \ \ \ \ \ (error "Argument not found" (car args)))))

    \;
  </scm-chunk>

  \;

  \;

  <paragraph|parse-args>

  解析命令行参数。

  <subparagraph|long-form?>

  判断是否形如<shell|--help>、<shell|--version>等形式。

  <\scm-chunk|goldfish/liii/argparse.scm|true|true>
    (define (long-form? arg)

    \ \ (and (string? arg)\ 

    \ \ \ \ \ \ \ (\<gtr\>= (string-length arg) 3)

    \ \ \ \ \ \ \ (string-starts? arg "--")))

    \;
  </scm-chunk>

  <subparagraph|short-form?>

  判断是否形如<shell|-w>、<shell|-help>等形式。

  <\scm-chunk|goldfish/liii/argparse.scm|true|true>
    (define (short-form? arg)

    \ \ (and (string? arg)

    \ \ \ \ \ \ \ (\<gtr\>= (string-length arg) 2)

    \ \ \ \ \ \ \ (char=? (string-ref arg 0) #\\-)))

    \;
  </scm-chunk>

  <subparagraph|retrieve-args>

  如果在代码中传入的参数是空列表，那么默认使用命令行参数。

  <\scm-chunk|goldfish/liii/argparse.scm|true|true>
    (define (retrieve-args args)

    \ \ (if (null? args)

    \ \ \ \ \ \ (cddr (argv))

    \ \ \ \ \ \ (car args)))

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/argparse.scm|true|true>
    (define (%parse-args args-ht prog-args)

    \ \ (let loop ((args (retrieve-args prog-args)))

    \ \ \ \ (if (null? args)

    \ \ \ \ \ \ \ \ args-ht

    \ \ \ \ \ \ \ \ (let ((arg (car args)))

    \ \ \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ \ \ ((long-form? arg)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (let* ((name (substring arg 2))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (found (hash-table-ref args-ht name)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if found

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (null? (cdr args))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (error "Missing value for argument" name)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let ((value (convert-value (cadr args) (cadr found))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (set-car! (cddddr found) value))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (cddr args))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (value-error (string-append "Unknown option: --" name)))))

    \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ \ \ \ \ ((short-form? arg)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (let* ((name (substring arg 1))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (found (hash-table-ref args-ht name)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if found

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (null? (cdr args))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (error "Missing value for argument" name)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let ((value (convert-value (cadr args) (cadr found))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (set-car! (cddddr found) value))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (cddr args))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (value-error (string-append "Unknown option: -" name)))))

    \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ \ \ \ \ (else (loop (cdr args))))))))

    \;
  </scm-chunk>

  \;

  <paragraph|make-argument-parser><index|make-argument-parser>

  构造argparser，用于解析命令行参数。

  <\scm-chunk|goldfish/liii/argparse.scm|true|true>
    (define (make-argument-parser)

    \ \ (let ((args-ht (make-hash-table)))

    \ \ \ \ (lambda (command . args)

    \ \ \ \ \ \ (case command

    \ \ \ \ \ \ \ \ ((add) (%add-argument args-ht args))

    \ \ \ \ \ \ \ \ ((add-argument) (%add-argument args-ht args))

    \ \ \ \ \ \ \ \ ((get) (%get-argument args-ht args))

    \ \ \ \ \ \ \ \ ((get-argument) (%get-argument args-ht args))

    \ \ \ \ \ \ \ \ ((parse) (%parse-args args-ht args))

    \ \ \ \ \ \ \ \ ((parse-args) (%parse-args args-ht args))

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ (if (and (null? args) (symbol? command))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (%get-argument args-ht (list (symbol-\<gtr\>string command)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (error "Unknown parser command" command)))))))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/argparse.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/argparse-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii logging)>

  <section|许可证>

  <\goldfish-chunk|goldfish/liii/logging.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </goldfish-chunk>

  <section|接口>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define-library (liii logging)

    (import (liii path)

    \ \ \ \ \ \ \ \ (liii datetime))

    (export logging)

    (begin

    \;
  </goldfish-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|false|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii logging)

    \ \ \ \ \ \ \ \ (liii string)

    \ \ \ \ \ \ \ \ (liii lang)

    \ \ \ \ \ \ \ \ (liii path))

    \;
  </scm-chunk>

  <section|日志级别>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define-constant NOTSET 0)

    (define-constant DEBUG 10)

    (define-constant INFO 20)

    (define-constant WARNING 30)

    (define-constant ERROR 40)

    (define-constant CRITICAL 50)

    \;
  </goldfish-chunk>

  <section|实现>

  <verbatim|logging>的构造器使用工厂模式，如果输入的日志模块名一样，返回同一个实例。我们使用<verbatim|logging-registry>（数据类型为<verbatim|hash-table>）来保证同一个模块名（logging name），返回的是同一个<verbatim|logger>。

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define loggers-registry (make-hash-table))
  </goldfish-chunk>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define-class logging

    \ \ ((name string? "default")

    \ \ \ (log-path string? "")

    \ \ \ (level integer? WARNING))

    \ \ 

    \;
  </goldfish-chunk>

  <paragraph|logging%set-path!>

  我们重写<verbatim|set-path!>使其支持<verbatim|path>样本类对象作为输入

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%set-path! p)

    \ \ (cond ((string? p)

    \ \ \ \ \ \ \ \ \ (set! log-path p))

    \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ ((path :is-type-of p)

    \ \ \ \ \ \ \ \ \ (set! log-path (p :to-string)))

    \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (type-error "path should be a string or path object"))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|true|true>
    ;; Test set-path! with path object support

    (let ((log (logging "test-path-support")))

    \ \ ;; Test with string path

    \ \ (log :set-path! "/tmp/test.log")

    \ \ (check (log :get-log-path) =\<gtr\> "/tmp/test.log")

    \ \ ;; Test with invalid input should throw type-error

    \ \ (check-catch 'type-error ((logging "app") :set-path! 123))

    \ \ ;; Test with path object

    \ \ (let ((p (path :temp-dir :/ "test-path-object.log")))

    \ \ \ \ (log :set-path! p)

    \ \ \ \ (check (log :get-log-path) =\<gtr\> (p :to-string))))

    \;
  </scm-chunk>

  <paragraph|logging%set-level!>

  我们重写<verbatim|set-level!>使其支持<verbatim|rich-integer>样本类对象作为输入

  <\scm-chunk|goldfish/liii/logging.scm|true|true>
    (define (%set-level! l)

    \ \ (define (check-valid-level val)

    \ \ \ \ (member val '(0 10 20 30 40 50)))

    \ \ 

    \ \ (cond ((integer? l)\ 

    \ \ \ \ \ \ \ \ \ (if (check-valid-level l)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (set! level l)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (value-error "invalid level number" l)))

    \;

    \ \ \ \ \ \ \ \ ((rich-integer :is-type-of l)\ 

    \ \ \ \ \ \ \ \ \ (if (check-valid-level (l :get))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (set! level (l :get))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (value-error "invalid level number" (l :get))))

    \;

    \ \ \ \ \ \ \ \ (else\ 

    \ \ \ \ \ \ \ \ \ (type-error "level should be an integer"))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|true|true>
    (check-catch 'type-error ((logging "app") :set-level! "invalid level"))

    (check-catch 'value-error ((logging "app") :set-level! 60))

    (let* ((logging-get-rich-level (logging "get-rich-level")))

    \ (logging-get-rich-level :set-level! ($ 50))

    \ (check (logging-get-rich-level :get-level) =\<gtr\> "CRITICAL"))

    \;
  </scm-chunk>

  <subsection|构造器>

  <\scm-chunk|goldfish/liii/logging.scm|true|true>
    (define (@apply p-name)

    \ \ ;; Check if logger with this name already exists in registry

    \ \ (let ((existing-logger (hash-table-ref loggers-registry p-name)))

    \ \ \ \ (if (eq? existing-logger #f)

    \ \ \ \ \ \ \ \ ;; If not, create a new logger and store in registry

    \ \ \ \ \ \ \ \ (let ((new-logger (logging)))

    \ \ \ \ \ \ \ \ \ \ (new-logger :set-name! p-name)

    \ \ \ \ \ \ \ \ \ \ (hash-table-set! loggers-registry p-name new-logger)

    \ \ \ \ \ \ \ \ \ \ new-logger)

    \ \ \ \ \ \ \ \ ;; If exists, return existing logger

    \ \ \ \ \ \ \ \ existing-logger)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|true|true>
    ;; Test @apply: Verify that the same logger instance is returned for the same name

    (let ((logger1 (logging "test-module"))

    \ \ \ \ \ \ (logger2 (logging "test-module")))

    \ \ (check-true (eq? logger1 logger2)))

    \;

    ;; Test @apply: Verify that different logger instances are returned for different names

    (let ((logger1 (logging "module-a"))

    \ \ \ \ \ \ (logger2 (logging "module-b")))

    \ \ (check-false (eq? logger1 logger2)))

    \;
  </scm-chunk>

  <paragraph|print>

  打印日志。如果路径为空，那么直接输出到控制台；如果路径不为空，那么直接将日志追加到路径中。

  <\warning>
    我们会在输入的字符串的尾部新增一个换行符，以保证每一行日志都会自动换行。同时每行日志都会在开头打印当时的时间戳。
  </warning>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (format-timestamp)

    \ \ (let ((now (datetime :now)))

    \ \ \ \ (now :to-string)))

    \;

    (define (print-log level-name . args)

    \ \ (let* ((timestamp (format-timestamp))

    \ \ \ \ \ \ \ \ \ (prefix (string-append timestamp " [" level-name "] " name ": "))

    \ \ \ \ \ \ \ \ \ (message (apply string-append\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (map (lambda (arg)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (string? arg)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ arg\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (arg :get)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ args))))

    \ \ \ \ (let ((line (string-append prefix message "\\n")))

    \ \ \ \ \ \ (if (string=? log-path "")

    \ \ \ \ \ \ \ \ \ \ (display line)

    \ \ \ \ \ \ \ \ \ \ (path-append-text log-path line)))))

    \;
  </goldfish-chunk>

  <paragraph|logging%get-level>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%get-level)

    \ \ (cond

    \ \ \ \ ((= level 0) "NOTSET")

    \ \ \ \ ((= level 10) "DEBUG")

    \ \ \ \ ((= level 20) "INFO")

    \ \ \ \ ((= level 30) "WARNING")

    \ \ \ \ ((= level 40) "ERROR")

    \ \ \ \ ((= level 50) "CRITICAL")))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|true|true>
    (check ((logging "app") :get-level) =\<gtr\> "WARNING")

    (let* ((logging-get-level (logging "app-get-level")))

    \ \ (logging-get-level :set-level! 50)

    \ \ (check (logging-get-level :get-level) =\<gtr\> "CRITICAL"))

    \;
  </scm-chunk>

  <paragraph|logging%debug?>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%debug?)

    \ \ (\<less\>= level DEBUG))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|true|true>
    (check-false ((logging "app") :debug?))

    \;
  </scm-chunk>

  <paragraph|logging%info?>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%info?)

    \ \ (\<less\>= level INFO))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|true|true>
    (check-false ((logging "app") :info?))

    \;
  </scm-chunk>

  <paragraph|logging%warning?>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%warning?)

    \ \ (\<less\>= level WARNING))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|true|true>
    (check-true ((logging "app") :warning?))

    \;
  </scm-chunk>

  <paragraph|logging%error?>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%error?)

    \ \ (\<less\>= level ERROR))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|true|true>
    (check-true ((logging "app") :error?))

    \;
  </scm-chunk>

  <paragraph|logging%critical?>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%critical?)

    \ \ (\<less\>= level CRITICAL))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|true|true>
    (check-true ((logging "app") :critical?))

    \;
  </scm-chunk>

  <paragraph|logging%debug>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%debug . args)

    \ \ (when (%debug?)

    \ \ \ \ (apply print-log "DEBUG" args)))

    \;
  </goldfish-chunk>

  <paragraph|logging%info>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%info . args)

    \ \ (when (%info?)

    \ \ \ \ (apply print-log "INFO" args)))

    \;
  </goldfish-chunk>

  <paragraph|logging%warning>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%warning . args)

    \ \ (when (%warning?)

    \ \ \ \ (apply print-log "WARNING" args)))

    \;
  </goldfish-chunk>

  <paragraph|logging%error>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%error . args)

    \ \ (when (%error?)

    \ \ \ \ (apply print-log "ERROR" args)))

    \;
  </goldfish-chunk>

  <paragraph|logging%critical>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    (define (%critical . args)

    \ \ (when (%critical?)

    \ \ \ \ (apply print-log "CRITICAL" args)))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|true|true>
    ;; Test logging with rich-string messages

    (let ((log (logging "rich-string-test")))

    \ \ (log :set-level! 10) ;; DEBUG level

    \ \ 

    \ \ ;; Test using $ to create a rich-string and logging it

    \ \ (define log-output (log :info ($ "User ID: " :+ 12345 :+ " logged in from " :+ "192.168.1.1")))

    \ \ (check-true (string-contains log-output "User ID: 12345 logged in from 192.168.1.1"))

    \ \ 

    \ \ ;; Test for multi-parameters

    \ \ (define log-output2 (log :info "User ID: " "12345" " logged in from " "192.168.1.1"))

    \ \ (check-true (string-contains log-output2 "User ID: 12345 logged in from 192.168.1.1"))

    \ \ 

    \ \ ;; Test with Unicode characters in rich-string

    \ \ (define unicode-msg ($ "用户: " :+ "admin" :+ " 登录成功 \<checkmark\>"))

    \ \ (define log-output3 (log :error unicode-msg))

    \ \ (check-true (string-contains log-output3 " 登录成功 \<checkmark\>")))\ 

    \;

    ;; Test that debug logging doesn't happen when level is too high

    (let ((log (logging "high-level")))

    \ \ (log :set-level! 30) ;; WARNING level

    \ \ (check-false (log :debug?))

    \ \ (check-false (log :info?))

    \ \ (check-true (log :warning?))

    \ \ (check-true (log :error?))

    \ \ (check-true (log :critical?))\ 

    \ \ 

    \ \ ;; These shouldn't produce output

    \ \ (check (log :debug "This debug message shouldn't appear") =\<gtr\> #\<less\>unspecified\<gtr\>)

    \ \ (check (log :info "This info message shouldn't appear") =\<gtr\> #\<less\>unspecified\<gtr\>)

    \ \ 

    \ \ ;; These should produce output

    \ \ (check-true (string-contains (log :warning "This warning should appear") "This warning should appear"))

    \ \ (check-true (string-contains (log :error "This error should appear") "This error should appear"))

    \ \ (check-true (string-contains (log :critical "This critical message should appear") "This critical message should appear")))

    \;
  </scm-chunk>

  \;

  <subparagraph|结尾>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <section|结尾>

  <\goldfish-chunk|goldfish/liii/logging.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/logging-test.scm|true|false>
    (check-report)
  </scm-chunk>

  <chapter|C++部分结尾>

  <section|许可证>

  <\cpp-chunk|src/goldfish.cpp|false|true>
    //

    // Copyright (C) 2024 The Goldfish Scheme Authors

    //

    // Licensed under the Apache License, Version 2.0 (the "License");

    // you may not use this file except in compliance with the License.

    // You may obtain a copy of the License at

    //

    // http://www.apache.org/licenses/LICENSE-2.0

    //

    // Unless required by applicable law or agreed to in writing, software

    // distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    // WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    // License for the specific language governing permissions and limitations

    // under the License.

    //

    \;
  </cpp-chunk>

  <section|入口>

  金鱼Scheme的入口是非常精简的，主要的逻辑在<shell|src/goldfish.hpp>里面。这样做的好处在于方便复用hpp文件中的源代码。

  <\cpp-chunk|src/goldfish.cpp|true|false>
    #include "goldfish.hpp"

    #include \<less\>string\<gtr\>

    \;

    int

    main (int argc, char** argv) {

    #ifdef TB_CONFIG_OS_WINDOWS

    \ \ SetConsoleOutputCP (65001);

    #endif

    \ \ std::string \ \ \ \ \ gf_lib_dir \ = goldfish::find_goldfish_library ();

    \ \ const char* gf_lib \ \ \ \ \ = gf_lib_dir.c_str ();

    \ \ s7_scheme* sc= goldfish::init_goldfish_scheme (gf_lib);

    \ \ return goldfish::repl_for_community_edition (sc, argc, argv);

    }
  </cpp-chunk>

  <section|胶水代码汇总接口>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    void

    glue_for_community_edition (s7_scheme* sc) {

    \ \ glue_goldfish (sc);

    \ \ glue_scheme_time (sc);

    \ \ glue_scheme_process_context (sc);

    \ \ glue_liii_sys (sc);

    \ \ glue_liii_os (sc);

    \ \ glue_liii_path (sc);

    \ \ glue_liii_datetime (sc);

    \ \ glue_liii_uuid (sc);

    }

    \;
  </cpp-chunk>

  <section|命令行>

  <paragraph|显示帮助>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static void

    display_help () {

    \ \ cout \<less\>\<less\> "Goldfish Scheme " \<less\>\<less\> GOLDFISH_VERSION \<less\>\<less\> " by LiiiLabs" \<less\>\<less\> endl;

    \ \ cout \<less\>\<less\> "--version\\t"

    \ \ \ \ \ \ \ \<less\>\<less\> "Display version" \<less\>\<less\> endl;

    \ \ cout \<less\>\<less\> "-m default\\t"

    \ \ \ \ \ \ \ \<less\>\<less\> "Allowed mode: default, liii, sicp, r7rs, s7" \<less\>\<less\> endl;

    \ \ cout \<less\>\<less\> "-e \ \ \ \ \ \ \\t"

    \ \ \ \ \ \ \ \<less\>\<less\> "Load the scheme code on the command line" \<less\>\<less\> endl

    \ \ \ \ \ \ \ \<less\>\<less\> "\\t\\teg. -e '(begin (display ‘Hello) (+ 1 2))'" \<less\>\<less\> endl;

    \ \ cout \<less\>\<less\> "-l FILE \ \\t"

    \ \ \ \ \ \ \ \<less\>\<less\> "Load the scheme code on path" \<less\>\<less\> endl;

    \ \ cout \<less\>\<less\> "FILE \ \ \ \ \\t"

    \ \ \ \ \ \ \ \<less\>\<less\> "Load the scheme code on path and print the evaluated result" \<less\>\<less\> endl;

    }

    \;
  </cpp-chunk>

  <paragraph|显示版本>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static void

    display_version () {

    \ \ cout \<less\>\<less\> "Goldfish Scheme " \<less\>\<less\> GOLDFISH_VERSION \<less\>\<less\> " by LiiiLabs" \<less\>\<less\> endl;

    \ \ cout \<less\>\<less\> "based on S7 Scheme " \<less\>\<less\> S7_VERSION \<less\>\<less\> " (" \<less\>\<less\> S7_DATE \<less\>\<less\> ")" \<less\>\<less\> endl;

    }

    \;
  </cpp-chunk>

  <paragraph|错误的命令行选项>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static void

    display_for_invalid_options () {

    \ \ cerr \<less\>\<less\> "Invalid command line options!" \<less\>\<less\> endl \<less\>\<less\> endl;

    \ \ display_help ();

    }

    \;
  </cpp-chunk>

  <paragraph|执行文件中的代码>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static void

    goldfish_eval_file (s7_scheme* sc, string path, bool quiet) {

    \ \ s7_pointer result= s7_load (sc, path.c_str ());

    \ \ if (!result) {

    \ \ \ \ cerr \<less\>\<less\> "Failed to load " \<less\>\<less\> path \<less\>\<less\> endl;

    \ \ \ \ exit (-1);

    \ \ }

    \ \ if (!quiet) {

    \ \ \ \ cout \<less\>\<less\> path \<less\>\<less\> " =\<gtr\> " \<less\>\<less\> s7_object_to_c_string (sc, result) \<less\>\<less\> endl;

    \ \ }

    }

    \;
  </cpp-chunk>

  <paragraph|执行命令行中以字符串形式传入的代码>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    static void

    goldfish_eval_code (s7_scheme* sc, string code) {

    \ \ s7_pointer x= s7_eval_c_string (sc, code.c_str ());

    \ \ cout \<less\>\<less\> s7_object_to_c_string (sc, x) \<less\>\<less\> endl;

    }

    \;
  </cpp-chunk>

  <paragraph|金鱼Scheme的初始化>

  <\enumerate>
    <item>初始化S7 Scheme

    <item>为S7 Scheme设置load path

    <item>初始化tbox

    <item>初始化胶水代码
  </enumerate>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    s7_scheme*

    init_goldfish_scheme (const char* gf_lib) {

    \ \ s7_scheme* sc= s7_init ();

    \ \ s7_add_to_load_path (sc, gf_lib);

    \;

    \ \ if (!tb_init (tb_null, tb_null)) exit (-1);

    \;

    \ \ glue_for_community_edition (sc);

    \ \ return sc;

    }

    \;
  </cpp-chunk>

  <paragraph|金鱼Scheme的运行模式>

  <code*|-m>帮助您指定预加载的标准库。

  <\description>
    <item*|default><code*|-m default>等价于<code*|-m liii>

    <item*|liii>预加载<code*|(liii base)>和<code*|(liii error)>的金鱼Scheme

    <item*|sicp>预加载<code*|(srfi sicp)>和<code*|(scheme base)>的S7 Scheme

    <item*|r7rs>预加载<code*|(scheme base)>的S7 Scheme

    <item*|s7>无任何无加载库的S7 Scheme
  </description>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    void

    customize_goldfish_by_mode (s7_scheme* sc, string mode,

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const char* boot_file_path) {

    \ \ if (mode != "s7") {

    \ \ \ \ s7_load (sc, boot_file_path);

    \ \ }

    \;

    \ \ if (mode == "default" \|\| mode == "liii") {

    \ \ \ \ s7_eval_c_string (sc, "(import (liii base) (liii error) (liii lang))");

    \ \ }

    \ \ else if (mode == "scheme") {

    \ \ \ \ s7_eval_c_string (sc, "(import (liii base) (liii error))");

    \ \ }

    \ \ else if (mode == "sicp") {

    \ \ \ \ s7_eval_c_string (sc, "(import (scheme base) (srfi sicp))");

    \ \ }

    \ \ else if (mode == "r7rs") {

    \ \ \ \ s7_eval_c_string (sc, "(import (scheme base))");

    \ \ }

    \ \ else if (mode == "s7") {

    \ \ }

    \ \ else {

    \ \ \ \ cerr \<less\>\<less\> "No such mode: " \<less\>\<less\> mode \<less\>\<less\> endl;

    \ \ \ \ exit (-1);

    \ \ }

    }

    \;
  </cpp-chunk>

  <paragraph|REPL>

  <subparagraph|find_goldfish_library>

  定位Goldfish的函数库的目录，如果不存在，直接以-1为返回值退出，如果存在，则返回目录对应的完整路径。

  <\description>
    <item*|开发者模式>在这种模式下，Goldfish的可执行文件的路径是<shell|$(projectdir)/bin/goldfish>，而函数库的路径是<shell|$(projectdir)/goldfish)>。这种情况仅用于开发或者集成Goldfish。

    <item*|Linux>

    <\description>
      <item*|/usr/bin/goldfish>

      <item*|/usr/local/goldfish>

      这两种情况可以通过相对路径分别定位到Goldfish的函数库目录是<shell|/usr/share/goldfish>和<shell|/usr/local/share/goldfish>。

      <item*|/bin/goldfish>

      在这种情况下，我们直接将函数库目录设置为<shell|/usr/share/goldfish>。
    </description>
  </description>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    string

    find_goldfish_library () {

    \ \ string exe_path= goldfish_exe ();

    \;

    \ \ tb_char_t \ \ \ \ \ \ \ data_bin[TB_PATH_MAXN]= {0};

    \ \ tb_char_t const* ret_bin=

    \ \ \ \ \ \ tb_path_directory (exe_path.c_str (), data_bin, sizeof (data_bin));

    \;

    \ \ tb_char_t \ \ \ \ \ \ \ data_root[TB_PATH_MAXN]= {0};

    \ \ tb_char_t const* gf_root=

    \ \ \ \ \ \ tb_path_directory (ret_bin, data_root, sizeof (data_root));

    \;

    \ \ tb_char_t \ \ \ \ \ \ \ data_lib[TB_PATH_MAXN]= {0};

    \ \ tb_char_t const* gf_lib= tb_path_absolute_to (gf_root, "share/goldfish",

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ data_lib, sizeof (data_lib));

    #ifdef TB_CONFIG_OS_LINUX

    \ \ if (strcmp (gf_root, "/") == 0) {

    \ \ \ \ gf_lib= "/usr/share/goldfish";

    \ \ }

    #endif

    \;

    \ \ if (!tb_file_access (gf_lib, TB_FILE_MODE_RO)) {

    \ \ \ \ gf_lib=

    \ \ \ \ \ \ \ \ tb_path_absolute_to (gf_root, "goldfish", data_lib, sizeof (data_lib));

    \ \ \ \ if (!tb_file_access (gf_lib, TB_FILE_MODE_RO)) {

    \ \ \ \ \ \ cerr \<less\>\<less\> "The load path for Goldfish standard library does not exist"

    \ \ \ \ \ \ \ \ \ \ \ \<less\>\<less\> endl;

    \ \ \ \ \ \ exit (-1);

    \ \ \ \ }

    \ \ }

    \;

    \ \ return string (gf_lib);

    }

    \;
  </cpp-chunk>

  <subparagraph|find_goldfish_boot>

  定位Goldfish用于启动的Scheme脚本文件，如果不存在，直接以-1为返回值退出，如果存在，则返回改文件对应的完整路径。关于<shell|boot.scm>的具体细节，见<smart-ref|chapter:scheme_boot>。

  <\cpp-chunk|src/goldfish.hpp|true|true>
    string

    find_goldfish_boot (const char* gf_lib) {

    \ \ tb_char_t \ \ \ \ \ \ \ data_boot[TB_PATH_MAXN]= {0};

    \ \ tb_char_t const* gf_boot= tb_path_absolute_to (gf_lib, "scheme/boot.scm",

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ data_boot, sizeof (data_boot));

    \;

    \ \ if (!tb_file_access (gf_boot, TB_FILE_MODE_RO)) {

    \ \ \ \ cerr \<less\>\<less\> "The boot.scm for Goldfish Scheme does not exist" \<less\>\<less\> endl;

    \ \ \ \ exit (-1);

    \ \ }

    \ \ return string (gf_boot);

    }

    \;
  </cpp-chunk>

  <subparagraph|repl_for_community_edition>

  <\cpp-chunk|src/goldfish.hpp|true|true>
    int

    repl_for_community_edition (s7_scheme* sc, int argc, char** argv) {

    \ \ string \ \ \ \ \ gf_lib_dir \ = find_goldfish_library ();

    \ \ const char* gf_lib \ \ \ \ \ = gf_lib_dir.c_str ();

    \ \ string \ \ \ \ \ gf_boot_path= find_goldfish_boot (gf_lib);

    \ \ const char* gf_boot \ \ \ \ = gf_boot_path.c_str ();

    \;

    \ \ vector\<less\>string\<gtr\> all_args (argv, argv + argc);

    \ \ int \ \ \ \ \ \ \ \ \ \ \ all_args_N= all_args.size ();

    \ \ for (int i= 0; i \<less\> all_args_N; i++) {

    \ \ \ \ command_args.push_back (all_args[i]);

    \ \ }

    \;

    \ \ // zero args

    \ \ vector\<less\>string\<gtr\> args (argv + 1, argv + argc);

    \ \ if (args.size () == 0) {

    \ \ \ \ display_help ();

    \ \ \ \ exit (0);

    \ \ }

    \;

    \ \ const char* errmsg= NULL;

    \ \ s7_pointer \ old_port=

    \ \ \ \ \ \ s7_set_current_error_port (sc, s7_open_output_string (sc));

    \ \ int gc_loc= -1;

    \ \ if (old_port != s7_nil (sc)) gc_loc= s7_gc_protect (sc, old_port);

    \;

    \ \ // -m: Load the standard library by mode

    \ \ string mode_flag= "-m";

    \ \ string mode \ \ \ \ = "default";

    \ \ int \ \ \ args_N \ \ = args.size ();

    \ \ int \ \ \ i;

    \ \ for (i= 0; i \<less\> args_N; i++) {

    \ \ \ \ if (args[i] == mode_flag) {

    \ \ \ \ \ \ break;

    \ \ \ \ }

    \ \ }

    \ \ if (i \<less\> args_N && i + 1 \<gtr\>= args_N) {

    \ \ \ \ cerr \<less\>\<less\> "No mode specified after -m" \<less\>\<less\> endl;

    \ \ \ \ exit (-1);

    \ \ }

    \ \ if (i \<less\> args_N) {

    \ \ \ \ mode= args[i + 1];

    \ \ \ \ args.erase (args.begin () + i);

    \ \ \ \ args.erase (args.begin () + i);

    \ \ }

    \;

    \ \ customize_goldfish_by_mode (sc, mode, gf_boot);

    \;

    \ \ // Command options

    \ \ if (args.size () == 1 && args[0].size () \<gtr\> 0 && args[0][0] == '-') {

    \ \ \ \ if (args[0] == "--version") {

    \ \ \ \ \ \ display_version ();

    \ \ \ \ }

    \ \ \ \ else {

    \ \ \ \ \ \ display_for_invalid_options ();

    \ \ \ \ }

    \ \ }

    \ \ else if (args.size () \<gtr\>= 2 && args[0] == "-e") {

    \ \ \ \ goldfish_eval_code (sc, args[1]);

    \ \ }

    \ \ else if (args.size () \<gtr\>= 2 && args[0] == "-l") {

    \ \ \ \ goldfish_eval_file (sc, args[1], true);

    \ \ }

    \ \ else if (args.size () \<gtr\>= 1 && args[0].size () \<gtr\> 0 && args[0][0] != '-') {

    \ \ \ \ goldfish_eval_file (sc, args[0], false);

    \ \ }

    \ \ else {

    \ \ \ \ display_for_invalid_options ();

    \ \ }

    \;

    \ \ errmsg= s7_get_output_string (sc, s7_current_error_port (sc));

    \ \ if ((errmsg) && (*errmsg)) cout \<less\>\<less\> errmsg;

    \ \ s7_close_output_port (sc, s7_current_error_port (sc));

    \ \ s7_set_current_error_port (sc, old_port);

    \ \ if (gc_loc != -1) s7_gc_unprotect_at (sc, gc_loc);

    \;

    \ \ if ((errmsg) && (*errmsg)) return -1;

    \ \ else return 0;

    }

    \;
  </cpp-chunk>

  <paragraph|goldfish命名空间的结束>

  <\cpp-chunk|src/goldfish.hpp|true|false>
    } // namespace goldfish
  </cpp-chunk>

  \;

  \;
</body>

<\initial>
  <\collection>
    <associate|font-base-size|12>
    <associate|info-flag|paper>
    <associate|page-height|auto>
    <associate|page-medium|papyrus>
    <associate|page-orientation|landscape>
    <associate|page-screen-margin|false>
    <associate|page-type|a4>
    <associate|page-width|auto>
    <associate|par-columns|1>
    <associate|par-par-sep|0.3333fn>
    <associate|save-aux|false>
  </collection>
</initial>
