<TMU|<tuple|1.0.5|1.2.9.7>>

<style|<tuple|generic|chinese>>

<\body>
  <\session|scheme|default>
    <\unfolded-io|Scheme] >
      (g_chdir "D:/texstudio/document/goldfish-range-map/goldfish")
    <|unfolded-io>
      #t
    </unfolded-io>

    <\input|Scheme] >
      \;
    </input>

    <\unfolded-io|Scheme] >
      (range 0 3 1 #t)
    <|unfolded-io>
      {gensym}-34735
    </unfolded-io>

    <\unfolded-io|Scheme] >
      (range :inclusive 1 3 0)
    <|unfolded-io>
      {gensym}-34735
    </unfolded-io>

    <\unfolded-io|Scheme] >
      (define r (range :inclusive 1 3)))
    <|unfolded-io>
      r
    </unfolded-io>

    <\unfolded-io|Scheme] >
      (r 'start)
    <|unfolded-io>
      1
    </unfolded-io>

    <\unfolded-io|Scheme] >
      (define-library (liii range)

      (import (liii lang))

      (export range)

      (begin

      \;

      (define-case-class range

      \ \ ((start integer?) (end integer?) (step integer?) (inclusive? boolean?) (map-func procedure?))

      \;

      (define* (@inclusive start end (step 1) (map-func (lambda (x) (* x x))))

      \ \ (range start end step #t map-func))

      \;

      \;

      (define (%empty?)

      \ \ (or (and (\<gtr\> start end) (\<gtr\> step 0))

      \ \ \ \ \ \ (and (\<less\> start end) (\<less\> step 0))

      \ \ \ \ \ \ (and (= start end) (not inclusive?))))

      \;

      ; 添加打印range所有元素的功能\ 

      (define (%map)

      \ \ (define current start)

      \ \ (let loop ((current start))\ 

      \ \ \ \ \ \ \ (cond\ 

      \ \ \ \ \ \ \ \ \ ((%empty?) (display "empty range\\n"))\ 

      \ \ \ \ \ \ \ \ \ ((or (and (\<gtr\> step 0) (\<gtr\> current end))\ 

      \ \ \ \ \ \ \ \ \ \ \ \ \ \ (and (\<less\> step 0) (\<less\> current end)))\ 

      \ \ \ \ \ \ \ \ \ \ (newline))\ 

      \ \ \ \ \ \ \ \ \ (else\ 

      \ \ \ \ \ \ \ \ \ \ \ (display (map-func current))\ 

      \ \ \ \ \ \ \ \ \ \ \ (display " ")\ 

      \ \ \ \ \ \ \ \ \ \ \ (loop (+ current step)))))

      \ \ )

      \;

      ) ; define-case-class

      ) ; begin

      ) ; define-library
    <|unfolded-io>
      (inlet 'range range)
    </unfolded-io>

    <\unfolded-io|Scheme] >
      (define map-func (lambda (x) (* x x)))
    <|unfolded-io>
      map-func
    </unfolded-io>

    <\unfolded-io|Scheme] >
      (define r (range :inclusive 1 3 map-func))
    <|unfolded-io>
      <errput|unbound variable type-error in ((unless (integer? step) (type-error (format #f "In funtion #\<~a ~a\>: argument *~a* must be *~a*! \ \ \ **Got ~a**" make-case-class-range '(start end step inclusive?) 'step "integer" (object-\>string step)))) (unless (boolean? inclusive?) (type-error (format #f "In funtion #\<~a ~a\>: argument *~a* must be *~a*! \ \ \ **Got ~a**" make-case-class-range '(start end step inclusive?) 'inclusive? "boolean" (object-\>string inclusive?)))) (define {gensym}-34735 #f) (define (%this . xs) (if (null? xs) {gensym}-34735 (apply {gensym}-34735 xs))) (define (%is-instance-of x) (eq? x 'range)) (define (%equals that) (unless (case-class? that) (type-error (format #f "In funtion #\<~a ~a\>: argument *~a* must be *~a*! \ \ \ **Got ~a**" %equals '(that) 'that "case-class" (object-\>string that)))) (and (that :is-instance-of 'range) (equal? start (that 'start)) (equal? end (that 'end)) (equal? step (that 'step)) (equal? inclusive? (that 'inclusive?)))) (define (%apply . args) (cond ((null? args) (value-error range "Apply on zero args is not implemented")) ((equal? ((symbol-\>string (car args)) 0) #\\:) (value-error range "No such method: " (car args))) (else (value-error range "No such field: " (car args))))) (define (%to-string) (let ((field-strings (list (string-append ":start" " " (object-\>string start)) (string-append ":end" " " (object-\>string end)) (string-append ":step" " " (object-\>string step)) (string-append ":inclusive?" " " (object-\>string inclusive?))))) (let loop ((strings field-strings) (acc "")) (if (null? strings) (string-append "(" "range" " " acc ")") (loop (cdr strings) (if (zero? (string-length acc)) (car strings) (string-append acc " " (car strings)))))))) (define (%empty?) (or (and (\> start end) (\> step 0)) (and (\< start end) (\< step 0)) (and (= start end) (not inclusive?)))) (define (instance-dispatcher) (lambda (msg . args) (cond ((eq? msg :is-instance-of) (apply %is-instance-of args)) ((eq? msg :equals) (apply %equals args)) ((eq? msg :to-string) (%to-string)) ((eq? msg :this) (apply %this args)) ((eq? msg :start) (range (car args) end step inclusive?)) ((eq? msg :end) (range start (car args) step inclusive?)) ((eq? msg :step) (range start end (car args) inclusive?)) ((eq? msg :inclusive?) (range start end step (car args))) ((is-normal-function? msg) (case msg ((:empty?) (apply %empty? args)) (else (value-error range "No such method: " msg)))) ((eq? msg 'start) start) ((eq? msg 'end) end) ((eq? msg 'step) step) ((eq? msg 'inclusive?) inclusive?) (else (apply %apply (cons msg args)))))) (set! {gensym}-34735 (instance-dispatcher)) {gensym}-34735)>
    </unfolded-io>

    <\unfolded-io|Scheme] >
      (r :empty?)
    <|unfolded-io>
      #f
    </unfolded-io>

    <\unfolded-io|Scheme] >
      (r :map)
    <|unfolded-io>
      <errput|unbound variable value-error in (value-error range "No such method: " msg)>
    </unfolded-io>

    <\input|Scheme] >
      \;
    </input>
  </session>
</body>

<\initial>
  <\collection>
    <associate|page-medium|paper>
    <associate|page-screen-margin|false>
  </collection>
</initial>
