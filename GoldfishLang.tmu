<TMU|<tuple|1.0.5|1.2.9.7>>

<style|<tuple|book|goldfish|literate|reduced-margins|python|padded-paragraphs|chinese>>

<\body>
  <\hide-preamble>
    <assign|r7rs|<flag|R7RS|dark cyan>>

    <assign|srfi|<flag|SRFI|dark red>>

    <assign|font|math=Latin Modern Math,cjk=Noto CJK SC,CMU>

    <assign|typehint|<macro|body|<goldfish-lang|<arg|body>>>>
  </hide-preamble>

  <chapter|(liii lang)>

  <section|许可证>

  <\goldfish-chunk|goldfish/liii/lang.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </goldfish-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define-library (liii lang)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    (import (only (liii oop) define-case-class display* == @ typed-define case-class? chained-define define-object define-class != chain-apply object-\<gtr\>string)

    \ \ \ \ \ \ \ \ (only (liii string) string-join string-null? string-starts? string-contains string-trim string-trim-right string-trim-both string-remove-prefix string-remove-suffix string-pad string-pad-right)

    \ \ \ \ \ \ \ \ (only (liii vector) vector= vector-every vector-any vector-filter reverse-list-\<gtr\>vector vector-index vector-index-right vector-fold vector-fold-right)

    \ \ \ \ \ \ \ \ (only (liii sort) list-stable-sort vector-stable-sort)

    \ \ \ \ \ \ \ \ (only (liii list) length=? iota take filter count drop every any take-right drop-right fold fold-right reduce take-while drop-while list-index)

    \ \ \ \ \ \ \ \ (only (liii hash-table) hash-table-update!/default hash-table-for-each hash-table-ref/default hash-table-contains? hash-table-delete! hash-table-count)

    \ \ \ \ \ \ \ \ (only (liii bitwise) bitwise-and bitwise-ior arithmetic-shift))

    \;

    (export

    \ \ @ typed-define define-case-class define-object define-class

    \ \ case-class? == != chained-define display* object-\<gtr\>string

    \ \ option none either left right

    \ \ rich-integer rich-float rich-char rich-string

    \ \ rich-list rich-vector array rich-hash-table

    \ \ box $

    )

    (begin

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii lang)

    \ \ \ \ \ \ \ \ (liii cut)

    \ \ \ \ \ \ \ \ (liii case))

    \;

    ;(check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|部分应用>

  <paragraph*|@>

  宏<scm|@>提供类似Scala语法的部分应用（Partial Application）功能，详情参考SFRI 26中宏<scm|cute>的说明。

  宏<scm|@>的关键在于<strong|宏展开时的静态求值>，而非运行时的动态绑定。简短的来说，<scm|@>只在宏展开时求值并绑定占位符，而不是每次被调用时重新求值。

  \;

  <subparagraph|通过示例和机制分步解释>

  <\goldfish-code>
    (let ((a 10))

    \ \ (define add10 (@ + a _)) \ ; a 在宏展开时被求值为 10

    \ \ (set! a 100)

    \ \ (add10 5)) ; =\<gtr\> 15（而不是 105）
  </goldfish-code>

  <\description>
    <item*|宏展开阶段 >

    当 <scm|(@ + a _)> 被展开时，宏会立即对非占位符参数（此处为 <scm|a>）进行求值。此时 <scm|a> 的值为 <scm|10>，所以宏生成的代码类似：

    <\goldfish-code>
      (define add10 (lambda (x) (+ 10 x))) ; a 被替换为固定值 10
    </goldfish-code>

    占位符 <scm|_> 对应后续传入的参数。

    <item*|运行时阶段 >

    即使后续通过 <scm|(set! a 100)> 修改了 <code*|<scm|a>>，<scm|add10> 内部已经固定为 <scm|10>，因此 <scm|(add10 5)> 等价于 <scm|(+ 10 5)>，结果为 <scm|15>。
  </description>

  \;

  <subparagraph|与普通闭包的区别>

  <\description>
    <item*|若不用 <scm|@>，直接使用 <scm|lambda> >

    <\goldfish-code>
      (let ((a 10))

      \ \ (define add10 (lambda (x) (+ a x))) ; 闭包捕获变量 a 的引用

      \ \ (set! a 100)

      \ \ (add10 5)) ; 结果为 105
    </goldfish-code>

    <item*|闭包行为 >

    <scm|lambda> 捕获的是变量 <scm|a> 的引用，而非其当前值。因此 <scm|a><verbatim|> 的修改会影响闭包的结果。
  </description>

  \;

  <subparagraph|宏 <scm|@> 的核心机制>

  <\description>
    <item*|静态求值 >

    在宏展开阶段，所有非占位符参数（如 <code*|<scm|a>>）会被立即求值，结果直接嵌入生成的代码中。这类似于 <strong|“值捕获”>。

    <item*|占位符 <scm|_ >>

    表示参数位置由后续调用时传入的值填充，类似 Scala 的 <scm|_> 占位符。例如 <scm|(@ f _ b _)> 会生成一个接受两个参数的函数。

    <item*|与 <scm|cute> 宏的区别 >

    <scm|cute> 宏支持更复杂的模式（如 <scm|\<...\>> 表示未定参数序列），而 <scm|@> 仅支持固定位置的 <scm|_>，且不延迟求值。
  </description>

  \;

  <subparagraph|设计意义>

  <\description>
    <item*|性能优化 >

    若部分参数是常量或昂贵的计算，<scm|@> 可避免重复求值。

    <item*|语义确定性 >

    部分应用的结果在定义时即固定，不受后续环境变化影响。
  </description>

  <subparagraph|测试用例>

  测试：基本部分应用

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((@ + _ 2) 1) =\<gtr\> 3)

    (check ((@ list 1 _ 3 _ 5) 2 4) =\<gtr\> (list 1 2 3 4 5))

    (check ((@ list _ _) 'a 'b) =\<gtr\> (list 'a 'b))

    \;
  </goldfish-chunk>

  测试：只宏展开时求值并绑定占位符

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check

    \ \ (let ((a 10))

    \ \ \ \ (define add (@ + (* a 2) _)) \ 

    \ \ \ \ (set! a 100)

    \ \ \ \ (add 5))

    =\<gtr\> 25)

    \;

    (let ((x 5))

    \ \ (check\ 

    \ \ \ \ ((@ cons (+ x 1) _) 'y)\ 

    \ \ \ =\<gtr\> (cons 6 'y)))

    \;
  </goldfish-chunk>

  测试：无占位符时生成的函数无参数

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (procedure? (@ list 1 2)) =\<gtr\> #t)

    (check ((@ list 1 2)) =\<gtr\> '(1 2))

    \;
  </goldfish-chunk>

  测试：函数作为占位符参数

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((@ _ 'a 'b) list) =\<gtr\> (list 'a 'b))

    (check ((@ map _ '(1 2 3)) (lambda (x) (+ x 1))) =\<gtr\> '(2 3 4))

    (check ((@ apply _ '(1 2 3)) +) =\<gtr\> 6)

    \;
  </goldfish-chunk>

  测试：嵌套<scm|@>宏

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((@ (@ + _ 1) _) 2) =\<gtr\> 3)

    (check ((@ _ _) (@ * _ 2) 3) =\<gtr\> 6)

    \;
  </goldfish-chunk>

  <section|定义函数>

  <paragraph|typed-define>

  \;

  <subparagraph|概述>

  <scm|typed-define> 是一个宏，用于在 Goldfish Scheme 中定义带有类型检查和默认值的函数。它允许你在定义函数时指定每个参数的类型和可选的默认值，并在函数调用时自动进行类型检查。如果参数类型不匹配，<scm|typed-define> 会抛出一个类型错误。

  \;

  <subparagraph|函数签名>

  <\goldfish-code>
    (typed-define (name (param1 type1? [default1]) (param2 type2? [default2]) ...) body ...)
  </goldfish-code>

  <\description>
    <item*|name >函数的名称。

    <item*|param1, param2, ... >函数的参数名。

    <item*|type1?, type2?, ... >参数的谓词函数，用于检查参数的类型。例如，<scm|integer?> 用于检查参数是否为整数。

    <item*|<strong|[default1], [default2], ...> >可选的默认值。如果调用函数时未提供该参数，则使用默认值。

    <item*|body >函数的主体部分。
  </description>

  \;

  <subparagraph|功能>

  <\description>
    <item*|类型检查 >

    在函数调用时，<scm|typed-define> 会自动检查每个参数的类型是否符合预期。如果不符合，会抛出一个类型错误。

    <item*|默认值 >

    如果参数有默认值，调用函数时可以省略该参数，函数会自动使用默认值。

    <item*|错误信息 >

    如果类型检查失败，<scm|typed-define> 会生成详细的错误信息，指出哪个参数的类型不匹配。
  </description>

  \;

  <subparagraph|设计意义>\ 

  <\description>
    <item*|类型安全>

    <scm|typed-define> 提供了编译时的类型检查，确保函数在运行时不会因为类型错误而崩溃。

    <item*|灵活性>

    通过支持默认值，<scm|typed-define> 使得函数调用更加灵活，减少了冗余代码。

    <item*|可读性>

    通过显式地指定参数类型和默认值，代码的可读性和可维护性得到了提升。
  </description>

  \;

  <subparagraph|实现细节>

  <scm|typed-define> 在宏展开时会生成类型检查代码，并在运行时对每个参数进行类型验证。如果参数类型不匹配，会抛出一个类型错误，错误信息中会包含参数名、期望的类型和实际的值。

  <subparagraph|测试用例>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (typed-define (person (name string? "Bob") (age integer?))

    \ \ (string-append name " is " (number-\<gtr\>string age) " years old"))

    \;

    (check (person :age 21) =\<gtr\> "Bob is 21 years old")

    (check (person :name "Alice" :age 25) =\<gtr\> "Alice is 25 years old")

    (check-catch 'type-error (person :name 123 :age 25))

    \;
  </goldfish-chunk>

  <section|样本类>

  本节函数和相关功能如下表所示：

  <\big-table|<tabular|<tformat|<cwith|1|1|1|-1|cell-tborder|0ln>|<cwith|1|1|1|-1|cell-bborder|1ln>|<cwith|2|2|1|-1|cell-tborder|1ln>|<cwith|1|1|1|1|cell-lborder|0ln>|<cwith|1|1|2|2|cell-rborder|0ln>|<cwith|1|1|1|-1|cell-background|>|<table|<row|<cell|函数名>|<cell|功能>>|<row|<cell|<scm|define-case-class>>|<cell|用于定义数据+行为的不可变样本类（支持类型化字段和方法）>>|<row|<cell|<scm|define-object>>|<cell|用于定义纯行为的不可变对象（仅包含方法）>>|<row|<cell|<scm|define-class>>|<cell|用于定义可变成员变量类的宏>>|<row|<cell|<scm|case-class?>>|<cell|用于判断某个对象是否为样本类>>|<row|<cell|<scm|==> 和 <scm|!=>>|<cell|样本类的相等性判断函数>>|<row|<cell|<scm|chained-define>>|<cell|简化了在样本类中定义方法的语法，使方法可以链式调用>>|<row|<cell|<scm|display*>>|<cell|正确处理样本类对象>>|<row|<cell|<scm|object-<textgreater|>string>>|<cell|样本类的字符串表示函数>>|<row|<cell|<verbatim|box>>|<cell|将基础类型的值装箱为样本类的函数>>|<row|<cell|<scm|$>>|<cell|用于简化样本类的创建和操作>>>>>>
    样本类相关函数和功能
  </big-table>

  <paragraph|define-case-class><index|define-case-class>

  <scm|define-case-class>是一个宏，用于在 Goldfish Scheme 中定义类似 Scala 的样本类（Case Class）。样本类是不可变的数据结构，支持字段访问、方法调用、链式操作以及自动生成的实例方法（如 <with|font-family|tt|equals>、<with|font-family|tt|to-string> 等）。

  样本类对象实际上是函数，该函数的第一个参数可以是字段或者是方法，字段统一使用<scm|'field>表示，方法统一使用<scm|:method>表示，需要注意方法名和字段名不能重复。实例方法采用<scm|%>作为前缀，静态方法采用<scm|@>作为前缀，内部方法没有<scm|@>和<scm|%>前缀。比如<scm|(bob :to-string)>实际上调用的是bob对象的实例方法<scm|%to-string>。静态方法只能通过样本类名调用，例如<scm|(person :default)>。实例方法只能通过该样本类构造的实例调用，例如 <scm|(bob :to-string)>。内部方法只能在定义实例方法时调用。

  <subparagraph|函数签名>

  <\goldfish-code>
    (define-case-class class-name

    \ \ ((field1 type1?) (field2 type2?) ...)

    \ \ (define private-field1 ...) ; 内部字段

    \;

    \ \ (define (@static-method-name ...) ...) \ ; 静态方法

    \ \ (define (%instance-method-name ...) ...) \ ; 实例方法

    \ \ (define (internal-method-name ...) ...) \ ; 内部方法

    \ \ ...

    )
  </goldfish-code>

  <\description>
    <item*|class-name >样本类的名称。

    <item*|<with|font-series|bold|field1, field2, ...> >样本类的字段名。

    <item*|<with|font-series|bold|type1?, type2?, ...> >字段的类型谓词函数，用于类型检查。例如，<scm|string?> 用于检查字段是否为字符串。

    <item*|@static-method-name >静态方法，以 <scm|@> 开头，只能通过类名调用。

    <item*|<with|font-series|bold|%instance-method-name> >实例方法，以 <scm|%> 开头，只能通过实例调用。

    <item*|internal-method-name >内部方法，没有前缀，只能在样本类内部调用。
  </description>

  \;

  <subparagraph|示例>

  <\goldfish-code>
    (define-case-class my-vector ((vec vector?) (size integer?))

    \ \ (define (@empty) (my-vector #() 0))

    \;

    \ \ (define (check-bound n)

    \ \ \ \ (when (or (\<less\> n 0) (\<gtr\>= n size))

    \ \ \ \ \ \ (value-error "out of bound")))

    \;

    \ \ (define (%at n)

    \ \ \ \ (check-bound n)

    \ \ \ \ (vector-ref vec n)))

    \;

    (let1 vec (my-vector #(1 2 3) 3)

    \ \ (check (my-vector :empty) =\<gtr\> (my-vector #() 0))

    \ \ (check (vec :at 0) =\<gtr\> 1)

    \ \ (check-catch 'value-error (vec :at 3)))
  </goldfish-code>

  在此例中，<scm|@empty> 是一个静态方法，<scm|%at> 是一个实例方法，<scm|check-bound> 是一个内部方法。

  实例方法将第一个参数之外剩下的参数作为参数传入，我们通过只处理部分参数，递归处理未处理参数的方式，可以实现方法调用链。比如

  <\goldfish-code>
    (l :filter positive? :filter zero?)

    =\<gtr\> ((l :filter positve?) :filter zero?)
  </goldfish-code>

  在这个filter方法的实现中，<scm|%filter>这个实例方法只处理第一个参数，得到的结果仍旧是一个样本类对象，再使用得到的样本类对象处理剩余的参数。

  <scm|define-case-class>会自动生成两种实例方法。

  其中一种是固定命名的实例方法：<scm|%equals>、<scm|%is-instance-of>、<scm|%to-string>和<scm|%apply>。其中<scm|%apply>是一个特殊方法，如果第一个参数没有命中字段或者方法，那么<scm|(person 1 2 3)>实际等价于<scm|(person :apply 1 2 3)>。

  另外一种是将字段名用做实例方法名，表示拷贝一个对象，并修改相应的字段。在下面的示例中，<scm|bob_2024>这个对象的实例方法接受一个整数作为输入，返回的是新的对象<scm|bob_2025>，这两个对象是完全不同的对象，他们的区别仅仅在于age字段的值。

  <\goldfish-code>
    (define person ((name string?) (age integer?)))

    (define bob_2024 (person "Bob" 24))

    (define bob_2025 (bob_2024 :age (+ 1 (bob_2024 'age))))
  </goldfish-code>

  样本类的默认构造函数有类型校验，但不做任何值校验。如果需要做值校验，那么需要使用同名的函数覆盖<scm|define-case-class>生成的默认实现。该同名函数可称为该样本类的伴生函数。

  <subparagraph|功能>

  <\description>
    <item*|字段访问 >样本类的字段可以通过字段名直接访问，例如 (<scm|instance 'field-name>)。

    <item*|方法调用 >样本类支持实例方法和静态方法。实例方法通过 :<scm|method-name> 调用，静态方法通过 <scm|class-name :method-name> 调用。

    <item*|链式操作 >实例方法支持链式调用，例如 (<scm|instance :method1 :method2>)。

    <item*|自动生成方法 ><scm|define-case-class> 会自动生成以下实例方法：

    <\itemize-minus>
      <item><scm|%equals>: 用于比较两个样本类实例是否相等。

      <item><scm|%to-string>: 用于将样本类实例转换为字符串。

      <item><scm|%apply>: 用于处理未命中的字段或方法调用。
    </itemize-minus>

    <item*|类型检查 >样本类的构造函数会自动检查字段的类型，如果类型不匹配，会抛出类型错误。
  </description>

  \;

  <subparagraph|设计意义>

  <\description>
    <item*|不可变性 >样本类的实例是不可变的，确保了数据的一致性和线程安全。

    <item*|链式操作 >支持链式调用，使得代码更加简洁和易读。

    <item*|类型安全 >构造函数会自动进行类型检查，确保字段的类型正确。

    <item*|拓展性 >支持自定义静态方法和实例方法，可以根据需要扩展样本类的功能。
  </description>

  \;

  <subparagraph|实现细节>

  <scm|define-case-class> 在宏展开时会生成样本类的构造函数、字段访问器、实例方法和静态方法。实例方法通过分发器（dispatcher）实现，支持链式调用和动态方法查找。

  <subparagraph|测试用例>

  测试：方法名不能与字段名重复

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-catch 'syntax-error

    \ \ (eval

    \ \ \ \ '(define-case-class instance-methods-conflict-test

    \ \ \ \ \ \ ((name string?)

    \ \ \ \ \ \ \ (age integer?))

    \ \ \ \ \ \ (define (%name)

    \ \ \ \ \ \ \ \ name))))

    \;

    (check-catch 'syntax-error

    \ \ (eval

    \ \ \ \ '(define-case-class static-methods-conflict-test

    \ \ \ \ \ \ ((name string?)

    \ \ \ \ \ \ \ (age integer?))

    \ \ \ \ \ \ (define (@name)

    \ \ \ \ \ \ \ \ name))))

    \;

    (check-catch 'syntax-error

    \ \ (eval

    \ \ '(define-case-class internal-methods-conflict-test

    \ \ \ \ \ \ ((name string?)

    \ \ \ \ \ \ \ (test-name string?)

    \ \ \ \ \ \ \ (age integer?))

    \ \ \ \ \ \ (define (test-name str)

    \ \ \ \ \ \ \ \ (string-append str " ")))))

    \;
  </goldfish-chunk>

  测试：不带用户自定义方法的样本类person

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (define-case-class person

    \ \ ((name string? "Bob")

    \ \ \ (age integer?)))

    \;

    (let1 bob (person :name "Bob" :age 21)

    \ \ (check (bob 'name) =\<gtr\> "Bob")

    \ \ (check (bob 'age) =\<gtr\> 21)

    \ \ (check ((bob :name "hello") 'name) =\<gtr\> "hello")

    \ \ (check-catch 'value-error (bob 'sex))

    \ \ (check-catch 'value-error (bob :sex))

    \ \ (check-true (bob :is-instance-of 'person))

    \ \ (check-true (person :is-type-of bob))

    \ \ (check (bob :to-string) =\<gtr\> "(person :name \\"Bob\\" :age 21)"))

    \;

    (check-catch 'type-error (person 1 21))

    \;

    (let ((bob (person "Bob" 21))

    \ \ \ \ \ \ (get-name (lambda (x)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (case* x

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((#\<less\>procedure?\<gtr\>) (x 'name))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else (value-error))))))

    \ \ (check (get-name bob) =\<gtr\> "Bob")

    \ \ (check-catch 'value-error (get-name 1)))

    \;
  </goldfish-chunk>

  测试：带用户自定义方法的样本类jerson

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (define-case-class jerson

    \ \ ((name string?)

    \ \ \ (age integer?))

    \ \ 

    \ \ (define (%to-string)

    \ \ \ \ (string-append "I am " name " " (number-\<gtr\>string age) " years old!"))

    \ \ (define (%greet x)

    \ \ \ \ (string-append "Hi " x ", " (%to-string)))

    )

    \;

    (let1 bob (jerson "Bob" 21)

    \ \ (check (bob :to-string) =\<gtr\> "I am Bob 21 years old!")

    \ \ (check (bob :greet "Alice") =\<gtr\> "Hi Alice, I am Bob 21 years old!"))

    \;
  </goldfish-chunk>

  测试：不带公开方法的样本类

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (define-case-class anonymous ()

    \ \ (define name "")

    \;

    \ \ (define (%get-name) name)

    \;

    \ \ (define (%set-name! x)

    \ \ \ \ (set! name x))

    )

    \;

    (let1 p (anonymous)

    \ \ (p :set-name! "Alice")

    \ \ (check (p :get-name) =\<gtr\> "Alice"))

    \;
  </goldfish-chunk>

  测试：在没有公开方法的时候，可以使用<scm|@apply>自定义构造函数

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (define-case-class my-bool ()

    \ \ (define data #t)

    \;

    \ \ (define (%set-true!)

    \ \ \ \ (set! data #t))

    \ \ (define (%set-false!)

    \ \ \ \ (set! data #f))

    \ 

    \ \ (define (%true?) data)

    \ \ (define (%false?) (not (%true?)))

    \ \ 

    \ \ (define (@apply x)

    \ \ \ \ (let1 r (my-bool)

    \ \ \ \ \ \ (cond ((eq? x 'true)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (r :set-true!))

    \ \ \ \ \ \ \ \ \ \ \ \ ((eq? x 'false)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (r :set-false!))

    \ \ \ \ \ \ \ \ \ \ \ \ ((boolean? x)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (if x (r :set-true!) (r :set-false!)))

    \ \ \ \ \ \ \ \ \ \ \ \ (else (r :set-false!)))

    \ \ \ \ \ \ r))

    )

    \;

    (check-true ((my-bool 'true) :true?))

    (check-true ((my-bool 'false) :false?))

    (check-true ((my-bool #t) :true?))

    (check-true ((my-bool #f) :false?))

    (check-true (my-bool :is-type-of (my-bool 'true)))

    \;
  </goldfish-chunk>

  测试：只有%开头的才是实例方法，其它的不应该被识别。

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (define-case-class test-case-class

    \ \ ((name string?))

    \ \ 

    \ \ (define (@this-is-a-static-method)

    \ \ \ \ (test-case-class "static"))

    \ \ 

    \ \ (define (%this-is-a-instance-method)

    \ \ \ \ (test-case-class (string-append name "instance")))

    )

    \;

    (let1 hello (test-case-class "hello ")

    \ \ (check-catch 'value-error (hello :this-is-a-static-method))

    \ \ (check (test-case-class :this-is-a-static-method) =\<gtr\> (test-case-class "static")))

    \;
  </goldfish-chunk>

  测试：使用 %this 引用实例本身

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ()

    \ \ (define-case-class person ((name string?) (country string?))

    \ \ \ \ (define (@default)

    \ \ \ \ \ \ (person "Andy" "China"))

    \ \ \ \ (define (%set-country! c . xs)

    \ \ \ \ \ \ (set! country c)

    \ \ \ \ \ \ (apply (%this) (if (null? xs) '(:this) xs)))

    \ \ \ \ (define (%set-name! n . xs)

    \ \ \ \ \ \ (set! name n)

    \ \ \ \ \ \ (apply (%this) (if (null? xs) '(:this) xs)))

    \ \ \ \ (define (%to-string)

    \ \ \ \ \ \ (format #f "Hello ~a from ~a" name country)))

    \;

    \ \ (define Andy (person :default))

    \ \ (check-catch 'wrong-type-arg (person :this))

    \ \ (check (Andy :to-string) =\<gtr\> "Hello Andy from China")

    \ \ (check (Andy :set-country! "USA" :to-string) =\<gtr\> "Hello Andy from USA")

    \ \ (check (Andy :to-string) =\<gtr\> "Hello Andy from USA")

    \ \ (check (Andy :set-country! "China" :set-name! "Ancker-0" :to-string) =\<gtr\> "Hello Ancker-0 from China")

    \ \ (check (Andy :set-country! "China") =\<gtr\> (person "Ancker-0" "China"))

    \ \ (check (Andy :this :set-country! "USA" :this :set-name! "Andy" :this :to-string) =\<gtr\> "Hello Andy from USA")

    \ \ (check-true (person :is-type-of Andy)))

    \;
  </goldfish-chunk>

  测试：内部方法

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ()

    \ \ (define-case-class person ((name string?) (country string?))

    \ \ \ \ (chained-define (@default)

    \ \ \ \ \ \ (person "Andy" "China"))

    \ \ \ \ (chained-define (set-country! c)

    \ \ \ \ \ \ (set! country c)

    \ \ \ \ \ \ (%this))

    \ \ \ \ (chained-define (set-name! n)

    \ \ \ \ \ \ (set! name n)

    \ \ \ \ \ \ (%this))

    \ \ \ \ (chained-define (%set-both! n c)

    \ \ \ \ \ \ (set-country! c)

    \ \ \ \ \ \ (set-name! n)

    \ \ \ \ \ \ (%this))

    \ \ \ \ (chained-define (%to-string)

    \ \ \ \ \ \ (rich-string (format #f "Hello ~a from ~a" name country))))

    \ \ (check (person :default :to-string :get) =\<gtr\> "Hello Andy from China")

    \ \ (check (person :default :set-both! "Bob" "Russia" :to-string :get) =\<gtr\> "Hello Bob from Russia")

    \ \ (check-catch 'value-error (person :default :set-country! "French")))

    \;
  </goldfish-chunk>

  <paragraph|define-object>

  <scm|define-object> 是基于 <scm|define-case-class> 的语法糖宏，用于快速定义无字段的纯对象类型。它专注于方法定义而不处理字段封装，适用于需要纯行为抽象的场景。

  \;

  <subparagraph|函数签名>

  <\goldfish-code>
    (define-object object-name . methods)
  </goldfish-code>

  <\description>
    <item*|object-name >样本类的名称（符号）。

    <item*|methods >方法定义列表，支持三种格式：

    <\itemize-minus>
      <item><with|font-family|tt|(@static-method ...)> - 静态方法（类方法）

      <item><with|font-family|tt|(%instance-method ...)> - 实例方法

      <item><with|font-family|tt|(internal-method ...)> - 内部辅助方法
    </itemize-minus>
  </description>

  \;

  <subparagraph|功能>

  <\description>
    <item*|纯行为对象>不包含任何字段定义，仅用于方法封装

    <item*|方法分类>通过前缀区分方法类型：

    <\itemize-minus>
      <item><scm|@> 前缀：静态方法（类名直接调用）

      <item><scm|%> 前缀：实例方法（对象实例调用）

      <item>无前缀：私有方法（内部使用）
    </itemize-minus>

    <item*|自动继承>包含 <scm|define-case-class> 的所有基础方法：

    <\itemize-minus>
      <item><scm|%equals> - 对象相等判断

      <item><scm|%to-string> - 字符串表示

      <item><scm|%apply> - 通用调用处理
    </itemize-minus>
  </description>

  \;

  <subparagraph|设计意义>

  <\description>
    <item*|>轻量级对象定义方案，适用于纯行为抽象

    <item*|>与 <scm|define-case-class> 形成互补：

    <\itemize-minus>
      <item><scm|define-case-class>：数据+行为封装

      <item><scm|define-object>：纯行为封装
    </itemize-minus>

    <item*|>通过前缀规范方法作用域，提高代码可读性
  </description>

  \;

  <subparagraph|实现细节>

  <\description>
    <item*|>宏展开为 <scm|define-case-class> 的空字段特化形式

    <item*|>编译时进行方法前缀校验

    <item*|>运行时方法查找采用两级缓存策略

    <item*|>生成的方法调度器优化了空字段情况下的性能
  </description>

  \;

  <subparagraph|典型应用场景>

  <\description>
    <item*|>工具类封装（如日志器、计数器）

    <item*|>策略模式实现

    <item*|>纯接口定义

    <item*|>函数组命名空间
  </description>

  \;

  <subparagraph|与define-case-class对比>

  <tformat|<cwith|1|5|1|1|cell-lborder|1ln>|<cwith|1|5|1|1|cell-halign|l>|<cwith|1|5|1|1|cell-rborder|1ln>|<cwith|1|5|2|2|cell-halign|l>|<cwith|1|5|2|2|cell-rborder|1ln>|<cwith|1|5|3|3|cell-halign|l>|<cwith|1|5|3|3|cell-rborder|1ln>|<cwith|1|5|1|3|cell-valign|c>|<cwith|1|1|1|3|cell-tborder|1ln>|<cwith|1|1|1|3|cell-bborder|1ln>|<cwith|2|2|1|3|cell-bborder|1ln>|<cwith|3|3|1|3|cell-bborder|1ln>|<cwith|4|4|1|3|cell-bborder|1ln>|<cwith|5|5|1|3|cell-bborder|1ln>|<table|<row|<cell|特性>|<cell|<scm|define-object>>|<cell|<scm|define-case-class>>>|<row|<cell|字段支持>|<cell|不支持>|<cell|支持类型化字段>>|<row|<cell|方法前缀>|<cell|强制要求>|<cell|可选>>|<row|<cell|初始化>|<cell|无参构造>|<cell|字段初始化构造>>|<row|<cell|适用场景>|<cell|行为抽象>|<cell|数据+行为封装>>>>

  <subparagraph|测试用例>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (define-object string-utils

    \ \ (define (@concat x y)

    \ \ \ \ (string-append x y))

    )

    \;

    (check (string-utils :concat "a" "b") =\<gtr\> "ab")

    \;

    (define-object object1

    \ \ (define x 0)

    \ \ (define (@concat x y)\ 

    \ \ \ \ (string-append x y))

    )

    \;

    (define-object object2

    \ \ (define y 0)

    \ \ (define (@return-object1) object1)

    )

    \;

    (check ((object2 :return-object1) :concat "a" "b") =\<gtr\> "ab")

    \;
  </goldfish-chunk>

  \;

  <paragraph|define-class>

  \ \ <scm|><scm|define-class> 是一个成员变量可变的类，所有成员变量均为<strong|私有>成员（即在<scm|define-case-class>的内部通过<scm|define>来定义），通过 <strong|<scm|get-name>>, <strong|<scm|set-name!>> 来给变量赋值和获取变量。

  \;

  <subparagraph|功能>

  <\description>
    <item*|可变状态管理 >

    <\itemize-minus>
      <item>成员变量（如 <scm|name>、<scm|age>、<scm|scores>）默认私有，必须通过 <scm|set-name!> 等方法修改。

      <item>支持初始化默认值（如 <scm|age> 默认为 <scm|18>）。
    </itemize-minus>

    <item*|类型安全 >自动生成带类型检查的 setter（如 <scm|(typed-define (%set-age! (x integer?))>）。

    <item*|自定义方法 >可定义类方法（如 <scm|%add-score!>、<scm|%average>），封装业务逻辑。

    <item*|语法简化 >相比手动用 <scm|define-case-class> 实现，大幅减少样板代码。
  </description>

  \;

  <subparagraph|设计意义>

  <\description>
    <item*|轻量级对象方案 >

    <\itemize-minus>
      <item>专注<with|font-series|bold|行为抽象>（如游戏角色、UI 组件等需要频繁状态变更的场景）。

      <item>与 <scm|define-case-class> 形成互补：

      <\itemize-minus>
        <item><strong|define-case-class<scm|>>：<with|font-series|bold|不可变数据> + 行为（函数式风格）。

        <item><strong|define-class<scm|>>：<with|font-series|bold|可变状态> + 行为（面向对象风格）。
      </itemize-minus>
    </itemize-minus>

    <item*|代码可读性 >

    <\itemize-minus>
      <item>强制命名规范（<scm|%> 前缀表示私有，<scm|get->/<scm|set-> 区分访问器）。

      <item>避免直接操作成员变量，降低耦合。
    </itemize-minus>

    <item*|类型安全 >通过 <scm|typed-define> 在运行时检查参数类型，防止非法赋值。
  </description>

  \;

  <subparagraph|实现细节>

  <\description>
    <item*|宏展开示例 >

    <\scm>
      (define-class Student ((name string? ""))
    </scm>

    展开为：

    <\scm>
      (define-case-class Student ()

      \ \ (define name "")

      \ \ (define (%get-name) name)

      \ \ (typed-define (%set-name! (x string?)) (set! name x))
    </scm>

    <item*|可变性控制 >所有状态变更通过 <scm|set!> 在方法内完成，避免外部直接修改。

    <item*|错误处理 >无效类型赋值会触发 <scm|type-error>（如 <scm|(s :set-age! "abc")> 会报错）。
  </description>

  \;

  <subparagraph|使用示例>

  <\scm>
    (define-class Student

    \ \ ((name string? "") \ \ \ \ \ ; 姓名，默认为空字符串

    \ \ \ (age integer? 18) \ \ \ \ \ ; 年龄，默认为18

    \ \ \ (scores list? '())) \ \ \ ; 分数列表，默认为空

    \;

    \ \ ;; 添加分数方法

    \ \ (define (%add-score! score)

    \ \ \ \ (set! scores (cons score scores))

    \;

    \ \ ;; 计算平均分方法

    \ \ (define (%average)

    \ \ \ \ (if (null? scores)

    \ \ \ \ \ \ \ \ 0

    \ \ \ \ \ \ \ \ (/ (apply + scores) (length scores)))

    )

    \ \ ;;使用方法

    (define s (Student)) \ ; 创建实例

    (s :set-name! "张三") \ \ \ \ \ ; 修改名字

    (s :add-score! 85) \ \ \ \ \ \ ; 添加分数85

    (s :add-score! 90) \ \ \ \ \ \ ; 添加分数90

    (s :average) \ \ \ \ \ \ \ \ \ \ \ \ ; 计算平均分 =\<gtr\> 87.5
  </scm>

  \;

  等价于：

  <\scm-code>
    (define-case-class Student ()

    \ \ ; 字段定义

    \ \ (define name "未命名")

    \ \ (define age 18)

    \ \ (define scores '())

    \ \ 

    \ \ ; Getter 方法

    \ \ (define (%get-name) name)

    \ \ (define (%get-age) age)

    \ \ (define (%get-scores) scores)

    \ \ 

    \ \ ; Setter 方法（带类型检查）

    \ \ (typed-define (%set-name! (x string?)) (set! name x))

    \ \ (typed-define (%set-age! (x integer?)) (set! age x))

    \ \ (typed-define (%set-scores! (x list?)) (set! scores x))

    \ \ 

    \ \ ; 用户自定义方法

    \ \ (define (%add-score! score)

    \ \ \ \ (set! scores (cons score scores))

    \ \ \ \ scores)

    \ \ 

    \ \ (define (%average)

    \ \ \ \ (if (null? scores)

    \ \ \ \ \ \ \ \ 0

    \ \ \ \ \ \ \ \ (/ (apply + scores) (length scores))))

    )
  </scm-code>

  \;

  <subparagraph|适用场景>

  <\description>
    <item*|>游戏开发（角色属性变更）。

    <item*|>GUI 编程（组件状态管理）。

    <item*|>需要封装可变状态的业务逻辑。
  </description>

  \;

  <subparagraph|测试用例>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    ;; Test define-class (可变类)

    (let ()

    \ \ (define-class person

    \ \ \ \ ((name string? "")

    \ \ \ \ \ (age integer? 0))

    \ \ \ \ 

    \ \ \ \ (define (@apply name)

    \ \ \ \ \ \ (let1 r (person)

    \ \ \ \ \ \ \ \ (r :set-name! name)

    \ \ \ \ \ \ \ \ (r :set-age! 10)

    \ \ \ \ \ \ \ \ r)))

    \ \ 

    \ \ ;; 测试@apply

    \ \ (define p1 (person))

    \ \ (define p2 (person "Bob"))

    \ \ 

    \ \ ;; 测试setter和getter

    \ \ (p1 :set-name! "Alice")

    \ \ (p1 :set-age! 25)

    \ \ (check (p1 :get-name) =\<gtr\> "Alice")

    \ \ (check (p1 :get-age) =\<gtr\> 25)

    \ \ (check (p2 :get-name) =\<gtr\> "Bob")

    \ \ (check (p2 :get-age) =\<gtr\> 10)

    \ \ 

    \ \ (check-true (person :is-type-of p1))

    \ \ (check-true (person :is-type-of p2))

    \;

    \ \ ;; 测试类型检查

    \ \ (check-catch 'type-error (p1 :set-name! 123))

    \ \ (check-catch 'type-error (p1 :set-age! "invalid"))

    )

    \;
  </goldfish-chunk>

  <paragraph|case-class?>

  <scm|case-class?> 是一个用于判断某个对象是否为 <with|font-series|bold|样本类（Case Class）> 的谓词函数。样本类是 Goldfish Scheme 中一种特殊的数据结构，类似于 Scala 中的 Case Class，主要用于表示不可变的数据对象。样本类对象通常由 <scm|define-case-class> 宏定义生成。

  <subparagraph|函数签名>

  <\scm>
    (case-class? x) =\<gtr\> boolean?
  </scm>

  <\description>
    <item*|参数 ><scm|x> : 任意类型的对象。

    <item*|返回值 >

    <\itemize-minus>
      <item>如果 <scm|x> 是一个样本类对象，返回 <scm|#t>。

      <item>否则，返回 <scm|#f>。
    </itemize-minus>
  </description>

  \;

  <subparagraph|功能>

  <scm|case-class?> 通过检查对象的内部结构来判断其是否为样本类。样本类对象的前两个方法必须是 <scm|:is-instance-of> 和 <scm|:equals>，这是样本类的标志性特征。

  \;

  <subparagraph|实现机制>

  <scm|case-class?> 的实现基于以下逻辑：\ 

  <\description>
    <item*|>检查对象是否为过程（<scm|procedure?>）。

    <item*|>获取过程的源代码（<scm|procedure-source>）。

    <item*|>检查源代码的前两个条件分支是否为 <scm|:is-instance-of> 和 <scm|:equals>。\ 

    <item*|>如果满足上述条件，则判定为样本类。
  </description>

  \;

  <subparagraph|注意事项>

  <\description>
    <item*|><scm|case-class?> 仅适用于由 <scm|define-case-class> 宏生成的样本类对象。

    <item*|>对于匿名函数、内置函数或普通自定义函数，<scm|case-class?> 会返回 <scm|#f>。
  </description>

  \;

  <subparagraph|设计意义>

  <\description>
    <item*|类型安全 >提供了一种类型检查机制，确保对象符合样本类的规范。

    <item*|模式匹配支持 >样本类通常用于模式匹配，<scm|case-class?> 可以帮助识别这些对象。

    <item*|代码可读性 >通过明确的谓词函数，增强代码的可读性和可维护性。
  </description>

  \;

  <subparagraph|测试用例>

  测试：匿名函数、内置函数或普通自定义函数会返回 <scm|#f>。

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-false (case-class? (lambda (x) x)))

    (check-false (case-class? +))

    (check-false (case-class? identity))

    \;
  </scm-chunk>

  测试：样本类判断

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((bob (person "Bob" 21)))

    \ \ (check-true (case-class? bob))

    \ \ (check-false (case-class? +))

    \ \ (check-false (case-class? 42))

    )

    \;
  </scm-chunk>

  <paragraph|==><index|==>

  <scm|==> 是一个用于判断两个对象是否相等的函数。它支持对 <with|font-series|bold|样本类（Case Class）>对象的特殊处理，同时也支持对普通对象的比较。如果两个对象都是样本类，则调用样本类的 <scm|:equals> 方法进行比较；如果其中一个对象是样本类，另一个不是，则会将非样本类对象装箱后再进行比较；如果两个对象都不是样本类，则使用 <scm|equal?> 进行比较。

  \;

  <subparagraph|函数签名>

  <\scm>
    (== left right) =\<gtr\> boolean?
  </scm>

  <\description>
    <item*|参数 >

    <\itemize-minus>
      <item><scm|left>: 任意类型的对象。

      <item><scm|right>: 任意类型的对象。
    </itemize-minus>

    <item*|返回值 >

    <\itemize-minus>
      <item>如果 <scm|left> 和 <scm|right> 相等，返回 <scm|#t>。

      <item>否则，返回 <scm|#f>。
    </itemize-minus>
  </description>

  \;

  <subparagraph|功能>

  <scm|==> 函数的比较逻辑如下：\ 

  <\description>
    <item*|>如果 <scm|left> 和 <scm|right> 都是样本类，则调用 <scm|left> 的 <scm|:equals> 方法进行比较。

    <item*|>如果 <scm|left> 是样本类而 <scm|right> 不是，则将 <scm|right> 用 <scm|box> 函数装箱后调用 <scm|left> 的 <scm|:equals> 方法。

    <item*|>如果 <scm|right> 是样本类而 <scm|left> 不是，则将 <scm|left> 用 <scm|box> 函数装箱后调用 <scm|right> 的 <scm|:equals> 方法。

    <item*|>如果两个对象都不是样本类，则使用 <scm|equal?> 进行比较。
  </description>

  \;

  <subparagraph|注意事项>

  <\description>
    <item*|><scm|==> 函数对样本类对象的比较是基于 <scm|:equals> 方法的实现，因此样本类的相等性判断可以自定义。

    <item*|>对于非样本类对象，<scm|==> 的行为与 <scm|equal?> 一致。

    <item*|>装箱操作通过 <scm|box> 函数实现，将普通对象转换为样本类对象。
  </description>

  \;

  <subparagraph|设计意义>

  <\description>
    <item*|统一比较接口 >提供了一种统一的比较方式，无论是样本类还是普通对象，都可以使用 <scm|==> 进行比较。

    <item*|拓展性 >样本类可以通过实现自定义的 <scm|:equals> 方法来定义自己的相等性逻辑。

    <item*|兼容性 >支持对普通对象的比较，确保与现有代码的兼容性。
  </description>

  \;

  <subparagraph|测试用例>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (== (list 1 2) (list 1 2)) =\<gtr\> #t)

    (check (!= (list 1 2) (list 1 2)) =\<gtr\> #f)

    (check (== (box 10) 10) =\<gtr\> #t) \ 

    (check (== 10 (box 10)) =\<gtr\> #t) \ 

    (check (== (box 10) (box 10)) =\<gtr\> #t) \ 

    (check (== 10 10) =\<gtr\> #t) \ 

    (check-true (== (person "Bob" 21) (person "Bob" 21)))

    \;
  </scm-chunk>

  <paragraph|!=><index|!=>

  <scm|!=> 是一个用于判断两个对象是否不相等的函数。它是 <scm|==> 函数的逻辑取反，即如果 <scm|==> 返回 <scm|#t>，则 <scm|!=> 返回 <scm|#f>，反之亦然。<scm|!=> 支持对 <with|font-series|bold|样本类（Case Class）> 对象的特殊处理，同时也支持对普通对象的比较。

  \;

  <subparagraph|函数签名>

  <\scm>
    (!= left right) =\<gtr\> boolean?
  </scm>

  <\description>
    <item*|参数 >

    <\itemize-minus>
      <item><scm|left>: 任意类型的对象。

      <item><scm|right>: 任意类型的对象。
    </itemize-minus>

    <item*|返回值 >

    <\itemize-minus>
      <item>如果 <scm|left> 和 <scm|right> 不相等，返回 <scm|#t>。

      <item>否则，返回 <scm|#f>。
    </itemize-minus>
  </description>

  \;

  <subparagraph|功能>

  <scm|!=> 函数的比较逻辑与 <scm|==> 完全相反：\ 

  <\description>
    <item*|>如果 <scm|left> 和 <scm|right> 都是样本类，则调用 <scm|left> 的 <scm|:equals> 方法进行比较,并取反结果。

    <item*|>如果 <scm|left> 是样本类而 <scm|right> 不是，则将 <scm|right> 用 <scm|box> 函数装箱后调用 <scm|left> 的 <scm|:equals> 方法,并取反结果。

    <item*|>如果 <scm|right> 是样本类而 <scm|left> 不是，则将 <scm|left> 用 <scm|box> 函数装箱后调用 <scm|right> 的 <scm|:equals> 方法,并取反结果。

    <item*|>如果两个对象都不是样本类，则使用 <scm|equal?> 进行比较，并取反结果。
  </description>

  \;

  <subparagraph|注意事项>

  <\description>
    <item*|><scm|!=> 是 <scm|==> 的逻辑取反，因此其行为完全依赖于 <scm|==> 的实现。

    <item*|>对于样本类对象，<scm|!=> 的行为取决于样本类的 <scm|:equals> 方法的实现。

    <item*|>对于非样本类对象，<scm|!=> 的行为与 <scm|equal?> 的取反结果一致。
  </description>

  \;

  <subparagraph|设计意义>

  <\description>
    <item*|逻辑完整性 >提供了与 <scm|==> 对称的不等性判断函数，完善了比较操作的逻辑。

    <item*|代码简洁性 >通过 <scm|!=> 可以更直观地表达不等性判断，避免使用 <scm|(not (== x y))> 的冗余写法。

    <item*|一致性 >与 <scm|==> 共享相同的比较逻辑，确保行为的一致性。
  </description>

  \;

  <subparagraph|测试用例>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (== (list 1 2) (list 1 2)) =\<gtr\> #t)

    (check (!= (list 1 2) (list 1 2)) =\<gtr\> #f)

    (check-true (!= (person "Bob" 20) (person "Bob" 21)))

    \;
  </scm-chunk>

  <paragraph|chained-define><index|chained-define>

  <scm|chained-define> 是一个用于在 Goldfish Scheme 中定义支持链式调用的函数的宏。它简化了在样本类（case class）中定义方法的语法，使得方法可以返回当前对象（<scm|%this>），从而支持链式调用。

  <subparagraph|函数签名>

  <\scm>
    (chained-define (method-name param1 param2 ...) body ...)
  </scm>

  <\description>
    <item*|参数 >

    <\itemize-minus>
      <item><scm|method-name>: 方法名，通常以 <scm|%> 开头表示实例方法。

      <item><scm|param1 param2 ...>: 方法的参数列表。

      <item><scm|body ...>: 方法的主体部分。
    </itemize-minus>

    <item*|返回值 ><scm|chained-define> 生成的函数会自动返回当前对象（<scm|%this>），除非在方法主体中显式返回其他值。这使得方法调用可以链式进行。
  </description>

  \;

  <subparagraph|功能>

  可以在 case class 中更方便地定义支持链式调用的函数。例如

  <\scm-code>
    (define (%set! index value . xs)

    \ \ (set! (data index) value)

    \ \ (if (null? xs)

    \ \ \ \ \ \ (%this)

    \ \ \ \ \ \ (apply (%this) xs)))
  </scm-code>

  可以用 <scm|chained-define> 简化为

  <\scm-code>
    (chained-define (%set! index value)

    \ \ (set! (data index) value)

    \ \ (%this))
  </scm-code>

  \;

  <subparagraph|设计意义>

  <\description>
    <item*|链式调用 ><scm|chained-define> 使得方法调用可以链式进行，简化了代码的书写和阅读。

    <item*|自动返回 >在方法主体中不需要显式返回 <scm|%this>，<scm|chained-define> 会自动处理。

    <item*|简化方法定义 >通过 <scm|chained-define>，可以更简洁地定义支持链式调用的方法。
  </description>

  \;

  <subparagraph|测试用例>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ()

    \ \ (define-case-class person ((name string?) (country string?))

    \ \ \ \ (chained-define (@default)

    \ \ \ \ \ \ (person "Andy" "China"))

    \ \ \ \ (chained-define (%set-country! c)

    \ \ \ \ \ \ (set! country c)

    \ \ \ \ \ \ (%this))

    \ \ \ \ (chained-define (%set-name! n)

    \ \ \ \ \ \ (set! name n)

    \ \ \ \ \ \ (%this))

    \ \ \ \ (chained-define (%set-both! n c)

    \ \ \ \ \ \ (%this :set-name! n :set-country! c))

    \ \ \ \ (chained-define (%to-string)

    \ \ \ \ \ \ (rich-string (format #f "Hello ~a from ~a" name country))))

    \ \ (check (person :default :to-string :get) =\<gtr\> "Hello Andy from China")

    \ \ (check (person :default :set-both! "Bob" "Russia" :to-string :get) =\<gtr\> "Hello Bob from Russia")

    \ \ (check ((person "Alice" "Japan") :set-name! "Lily" :to-string :get) =\<gtr\> "Hello Lily from Japan"))

    \;
  </scm-chunk>

  <paragraph|display*><index|display*>

  \;

  <subparagraph|概述>

  <scm|display*> 是 Goldfish Scheme 中用于展示多个对象的函数。它是 <scm|display> 函数的增强版，能够正确处理样本类（case class）对象，并且可以接受多个参数。<scm|display*> 会依次展示每个参数，并且会自动处理样本类对象的展示格式。

  \;

  <subparagraph|函数签名>

  <\scm>
    (display* x y z ...) =\<gtr\> \<less\>#unspecified\<gtr\>
  </scm>

  <\description>
    <item*|参数 ><scm|x>, <scm|y>, <scm|z>, ...：任意数量的参数，可以是任意类型的对象，包括样本类、字符串、数字等。

    <item*|返回值 >返回 <scm|<textless|>#unspecified\<gtr\>>，表示该函数主要用于副作用（展示内容），不返回具体的值。
  </description>

  \;

  <subparagraph|功能>

  <scm|display*> 函数会依次展示每个参数。如果参数是样本类对象，<scm|display*> 会调用样本类的 <scm|:to-string> 方法来获取其字符串表示形式，然后展示该字符串。如果参数不是样本类对象，则直接展示该对象。

  \;

  <subparagraph|注意事项>

  <\description>
    <item*|><scm|display*> 不会自动添加换行符，如果需要换行，可以手动添加 <scm|"\\n">。

    <item*|><scm|display*> 适用于需要展示多个对象的场景，特别是当这些对象中包含样本类时。
  </description>

  \;

  <subparagraph|测试用例>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check

    \ \ (with-output-to-string

    \ \ \ \ (lambda ()

    \ \ \ \ \ \ (display* "hello world" "\\n")))

    \ \ =\<gtr\> "hello world\\n")

    \;
  </scm-chunk>

  <paragraph|object-\<gtr\>string>

  <scm|object-<textgreater|>string> 是 Goldfish Scheme 中用于将任意对象转换为字符串表示的函数。它基于 S7 Scheme 的<scm| object-<textgreater|>string> 实现，并新增了对样本类（case class）的支持。如果对象是样本类，<scm|object-<textgreater|>string> 会调用样本类的 <scm|:to-string> 方法来获取其字符串表示；否则，直接调用 S7 的 <scm|object-<textgreater|>string> 函数。

  \;

  <subparagraph|函数签名>

  <\scm>
    (object-\<gtr\>string x) =\<gtr\> string?
  </scm>

  <\description>
    <item*|参数 ><scm|x>：任意类型的对象，可以是样本类、字符串、数字、字符、列表、向量等。

    <item*|返回值 >返回一个字符串，表示对象的字符串形式。
  </description>

  \;

  <subparagraph|功能>

  <scm|object-<textgreater|>string> 函数用于将对象转换为字符串。它的行为如下：\ 

  <\description>
    <item*|>如果对象是样本类（通过 <scm|case-class?> 判断），则调用样本类的 <scm|:to-string> 方法获取其字符串表示。

    <item*|>如果对象不是样本类，则调用 S7 Scheme 的 <scm|object-<textgreater|>string> 函数来获取其字符串表示。
  </description>

  \;

  <subparagraph|注意事项>

  <\description>
    <item*|><scm|object-<textgreater|>string> 是通用的对象转换函数，适用于所有类型的对象。

    <item*|>对于样本类，<scm|object-<textgreater|>string> 依赖于样本类实现的 <scm|:to-string> 方法，因此样本类需要正确实现该方法。
  </description>

  \;

  <subparagraph|设计意义>

  <scm|object-<textgreater|>string> 提供了一种统一的机制，用于将对象转换为字符串表示。它特别适用于调试、日志记录和展示对象内容的场景。通过支持样本类，<scm|object-<textgreater|>string> 能够更好地与 Goldfish Scheme 的样本类系统集成。

  \;

  <subparagraph|测试用例>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 bob (person "Bob" 21)

    \ \ (check (object-\<gtr\>string bob) =\<gtr\> "(person :name \\"Bob\\" :age 21)"))

    \;

    (check (object-\<gtr\>string 42) =\<gtr\> "42")

    (check (object-\<gtr\>string "hello") =\<gtr\> "\\"hello\\"")

    (check (object-\<gtr\>string #\\a) =\<gtr\> "#\\\\a")

    (check (object-\<gtr\>string '(1 2 3)) =\<gtr\> "(1 2 3)")

    (check (object-\<gtr\>string #(1 2 3)) =\<gtr\> "#(1 2 3)")

    \;
  </goldfish-chunk>

  <paragraph|box>

  <scm|box> 是 Goldfish Scheme 中用于将基础类型的值装箱为样本类（case class）的函数。它将整数、浮点数、字符、字符串、列表、向量和哈希表等基础类型的值转换为对应的样本类对象。通过装箱，基础类型的值可以享受样本类的功能，例如链式调用、类型检查和丰富的操作方法。

  \;

  <subparagraph|函数签名>

  <\scm>
    (box x) =\<gtr\> case-class?
  </scm>

  <\description>
    <item*|参数 ><scm|x>：需要装箱的值，支持以下类型：

    <\itemize-minus>
      <item>整数（<scm|integer?>）

      <item>浮点数（<scm|float?>）

      <item>字符（<scm|char?>）

      <item>字符串（<scm|string?>）

      <item>列表（<scm|list?>）

      <item>向量（<scm|vector?>）

      <item>哈希表（<scm|hash-table?>）
    </itemize-minus>

    <item*|返回值 >返回一个样本类对象，具体类型取决于输入值的类型：

    <\itemize-minus>
      <item>整数 \<rightarrow\> <scm|rich-integer>

      <item>浮点数 \<rightarrow\> <scm|rich-float>

      <item>字符 \<rightarrow\> <scm|rich-char>

      <item>字符串 \<rightarrow\> <scm|rich-string>

      <item>列表 \<rightarrow\> <scm|rich-list>

      <item>向量 \<rightarrow\> <scm|rich-vector>

      <item>哈希表 \<rightarrow\> <scm|rich-hash-table>
    </itemize-minus>
  </description>

  \;

  <subparagraph|功能>

  <scm|box> 函数根据输入值的类型，将其转换为对应的样本类对象。具体规则如下：\ 

  <\description>
    <item*|>如果 <scm|x> 是整数，返回 <scm|rich-integer> 样本类。

    <item*|>如果 <scm|x> 是浮点数，返回 <scm|rich-float> 样本类。

    <item*|>如果 <scm|x> 是字符，返回 <scm|rich-char> 样本类。

    <item*|>如果 <scm|x> 是字符串，返回 <scm|rich-string> 样本类。

    <item*|>如果 <scm|x> 是列表，返回 <scm|rich-list> 样本类。

    <item*|>如果 <scm|x> 是向量，返回 <scm|rich-vector> 样本类。

    <item*|>如果 <scm|x> 是哈希表，返回 <scm|rich-hash-table> 样本类。

    <item*|>如果 <scm|x> 是其他类型，抛出类型错误。
  </description>

  \;

  <subparagraph|注意事项>

  <\description>
    <item*|><scm|box> 仅支持特定的基础类型，其他类型会抛出类型错误。

    <item*|>装箱后的对象可以使用样本类的功能，例如链式调用和丰富的操作方法。

    <item*|><scm|box> 是隐式类型转换的核心机制，常用于简化代码和增强表达力。
  </description>

  \;

  <subparagraph|设计意义>

  <scm|box> 提供了一种简单的方式，将基础类型的值转换为样本类对象，从而享受样本类的功能。它是 Goldfish Scheme 中隐式类型转换的核心机制，能够显著简化代码并增强表达力。通过 <scm|box>，开发者可以更方便地操作基础类型的数据。

  \;

  <subparagraph|实现函数>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (box x)

    \ \ (cond ((integer? x) (rich-integer x))

    \ \ \ \ \ \ \ \ ((rational? x) (rich-rational x))

    \ \ \ \ \ \ \ \ ((float? x) (rich-float x))

    \ \ \ \ \ \ \ \ ((char? x) (rich-char x))

    \ \ \ \ \ \ \ \ ((string? x) (rich-string x))

    \ \ \ \ \ \ \ \ ((list? x) (rich-list x))

    \ \ \ \ \ \ \ \ ((vector? x) (rich-vector x))

    \ \ \ \ \ \ \ \ ((hash-table? x) (rich-hash-table x))

    \ \ \ \ \ \ \ \ (else (type-error "box: x must be integer?, rational?, float?, char?, string?, list?, vector?, hash-table?"))))

    \;
  </goldfish-chunk>

  <subparagraph|测试用例>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (box 42) =\<gtr\> (rich-integer 42))

    (check (box 3.14) =\<gtr\> (rich-float 3.14))

    (check (box #\\a) =\<gtr\> (rich-char 97))

    (check (box "hello") =\<gtr\> (rich-string "hello"))

    (check (box '(1 2 3)) =\<gtr\> (rich-list '(1 2 3)))

    (check (box #(1 2 3)) =\<gtr\> (rich-vector #(1 2 3)))

    (check (box (hash-table 'a 1 'b 2)) =\<gtr\> (rich-hash-table (hash-table 'a 1 'b 2)))

    (check-catch 'type-error (box #t))

    \;
  </goldfish-chunk>

  <paragraph|$>

  <scm|$> 是 Goldfish Scheme 中的一个语法糖，用于简化样本类（case class）的创建和操作。它将第一个参数装箱（boxing）为样本类，并将剩余的参数作为样本类的方法调用参数。<scm|$> 语法糖的核心目的是简化代码，避免显式调用 <scm|box> 函数，同时支持链式调用。

  \;

  <subparagraph|函数签名>

  <\scm>
    ($ x . xs) =\<gtr\> case-class?
  </scm>

  <\description>
    <item*|参数 ><scm|x>：需要装箱的值，支持以下类型：

    <\itemize-minus>
      <item>整数（<scm|integer?>）

      <item>浮点数（<scm|float?>）

      <item>字符（<scm|char?>）

      <item>字符串（<scm|string?>）

      <item>列表（<scm|list?>）

      <item>向量（<scm|vector?>）

      <item>哈希表（<scm|hash-table?>）
    </itemize-minus>

    \ \ \ <scm|xs>：可选参数，作为样本类的方法调用参数。

    <item*|返回值 >

    <\itemize-minus>
      <item>返回一个样本类对象，具体类型取决于 <scm|x> 的类型。

      <item>如果提供了 <scm|xs>，则返回调用样本类方法后的结果。
    </itemize-minus>
  </description>

  \;

  <subparagraph|功能>

  <scm|$> 语法糖的行为如下：\ 

  <\description>
    <item*|>将第一个参数 <scm|x> 装箱为样本类对象（通过 <scm|box> 函数）。

    <item*|>如果提供了剩余参数 <scm|xs>，则将 <scm|xs> 作为样本类的方法调用参数，返回调用结果。

    <item*|>如果没有提供 <scm|xs>，则直接返回装箱后的样本类对象。
  </description>

  \;

  <subparagraph|注意事项>

  <\description>
    <item*|><scm|$> 语法糖仅支持可以被 <scm|box> 函数处理的类型（整数、浮点数、字符、字符串、列表、向量、哈希表）。

    <item*|><scm|$> 语法糖支持链式调用，可以在一行代码中完成多个操作。

    <item*|>如果 <scm|x> 是样本类对象，<scm|$> 会直接使用该对象，而不会重新装箱。
  </description>

  \;

  <subparagraph|设计意义>

  <scm|$> 语法糖是 Goldfish Scheme 中隐式类型转换的核心机制之一。它通过简化样本类的创建和操作，显著提升了代码的简洁性和可读性。<scm|$> 语法糖特别适用于需要频繁操作样本类的场景，例如数据处理、字符串操作和集合操作。通过 <scm|$>，开发者可以更自然地表达复杂的操作逻辑。

  \;

  <subparagraph|实现函数>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define ($ x . xs)

    \ \ (if (null? xs) (box x) (apply (box x) xs)))

    \;
  </goldfish-chunk>

  <subparagraph|测试用例>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ 1 :to 3) =\<gtr\> '(1 2 3))

    (check ($ "hello world" :replace "world" "suger" :index-of "suger") =\<gtr\> 6)

    (check ($ '(1 2 3) :empty?) =\<gtr\> #f)

    \;

    (check

    \ (($ 100 :to 128)

    \ \ :take 10

    \ \ :map (@ + _ 1)

    \ \ :filter even?

    \ \ :collect)

    \ \ =\<gtr\> '(102 104 106 108 110))

    \;
  </scm-chunk>

  <chapter|富整数>

  <scm|rich-integer> 是 Goldfish Scheme 中的一个样本类（case class），用于封装整数并提供一系列操作和转换方法。该模块旨在增强 Scheme 中整数类型的功能，使其能够更方便地进行数值操作、类型转换和谓词判断。

  <section|基本结构>

  <paragraph|rich-integer>

  <scm|rich-integer> 是一个样本类，其构造函数接受一个整数作为参数，并将其封装在样本类中。通过样本类的机制，<scm|rich-integer> 提供了丰富的实例方法和静态方法。

  \;

  <subparagraph|样本类定义>

  <\verbatim>
    (define-case-class rich-integer ((data integer?))
  </verbatim>

  <\description>
    <item*|关键点解析 >

    <\itemize-minus>
      <item><strong|<scm|define-case-class>>: 这是 Goldfish Scheme 中用于定义样本类的宏。样本类是一种特殊的函数，它封装了数据，并提供了丰富的实例方法和静态方法。

      <item><strong|<scm|data>>: 这是 <scm|rich-integer> 样本类的唯一字段，类型为 <scm|integer?>，表示封装在样本类中的整数值。
    </itemize-minus>
  </description>

  \;

  <subparagraph|示例>

  <\scm>
    (let ((x ($ 42))) \ ; 创建一个 rich-integer 实例，封装整数 42

    \ \ (x :get)) \ \ \ \ \ \ \ ; 返回 42
  </scm>

  \;

  在这个示例中，<scm|$ 42> 创建了一个 <scm|rich-integer> 实例，封装了整数 <scm|42>。通过调用 <scm|:get> 方法，我们可以获取封装的整数值。

  \;

  <subparagraph|样本类的特性>

  <\description>
    <item*|封装性 ><scm|rich-integer> 封装了一个整数 <scm|data>，并通过样本类的机制提供了对该整数的访问和操作方法。

    <item*|拓展性 >通过样本类的机制，<scm|rich-integer> 可以定义丰富的实例方法和静态方法，扩展了 Scheme 中整数类型的功能。

    <item*|类型安全 ><scm|rich-integer> 的构造函数会自动进行类型检查，确保传入的参数是一个整数。
  </description>

  \;

  <subparagraph|实现函数>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define-case-class rich-integer ((data integer?))

    \;
  </goldfish-chunk>

  <section|选择器>

  <paragraph|rich-integer%get>

  <scm|%get> 是 <scm|rich-integer> 中最基本的选择器，用于返回样本类中封装的整数值。由于<scm|rich-integer> 是一个样本类，封装了一个整数 <scm|data>，<scm|%get> 的作用就是直接返回这个 <scm|data> 的值。

  \;

  <subparagraph|功能>

  <\description>
    <item*|返回值 >返回样本类中封装的整数值 <scm|data>。

    <item*|用途 >当需要获取 <scm|rich-integer> 实例中存储的原始整数值时，可以使用 <scm|%get> 方法。
  </description>

  \;

  <subparagraph|使用场景>

  <scm|%get> 方法的主要使用场景包括：

  <\description>
    <item*|获取原始值 >当需要将 <scm|rich-integer> 实例转换回普通的 Scheme 整数时，可以使用 <scm|%get> 方法。

    <item*|与其他函数结合使用 >在需要对 <scm|rich-integer> 实例进行进一步操作时，可以先使用 <scm|%get> 获取原始值，然后传递给其他函数。
  </description>

  \;

  <subparagraph|示例>

  <\scm>
    (let ((x ($ 42)))

    \ \ (define y (x :get)) \ ; y 现在是普通的 Scheme 整数 42

    \ \ (+ y 10)) \ ; 结果为 52
  </scm>

  \;

  在这个示例中，<scm|x> 是一个 <scm|rich-integer> 实例，封装了整数 <scm|42>。通过调用 <scm|x :get>，我们获取了原始的整数值 <scm|42>，并将其赋值给 <scm|y>。然后，我们可以对 <scm|y> 进行普通的 Scheme 整数操作，如加法。

  \;

  <subparagraph|实现函数>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%get) data)

    \;
  </goldfish-chunk>

  <subparagraph|测试用例>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ 42 :get) =\<gtr\> 42)

    \;
  </goldfish-chunk>

  <section|谓词>

  <paragraph|rich-integer%equals>

  <scm|%equals> 是 <scm|rich-integer> 样本类中的一个谓词方法，用于判断两个 <scm|rich-integer> 实例是否相等。谓词方法是指返回布尔值（<scm|#t> 或 <scm|#f>）的函数或方法，通常用于条件判断或逻辑操作。<scm|%equals> 方法由 <scm|define-case-class> 宏自动生成，确保了样本类实例之间的相等性比较能够正确进行。

  \;

  <subparagraph|方法定义>

  <scm|%equals> 方法的定义如下：

  <\scm>
    (define (%equals that)

    \ \ (== value (that 'value)))
  </scm>

  <\description>
    <item*|关键点解析 >

    <\itemize-minus>
      <item><scm|that>: 这是 <scm|%equals> 方法的参数，表示要与当前 <scm|rich-integer> 实例进行比较的另一个 <scm|rich-integer> 实例。

      <item><scm|==>: 这是 Goldfish Scheme 中的相等性比较函数，用于比较两个值是否相等。<scm|==> 函数支持样本类、普通 Scheme 值以及装箱（boxed）值之间的比较。

      <item><scm|value>: 这是当前 <scm|rich-integer> 实例中封装的整数值。

      <item><scm|(that 'value)>: 这是通过样本类的字段访问机制，获取 <scm|that> 实例中封装的整数值。
    </itemize-minus>
  </description>

  \;

  <subparagraph|功能>

  <\description>
    <item*|返回值 >返回一个布尔值 <scm|#t> 或 <scm|#f>，表示两个 <scm|rich-integer> 实例是否相等。

    <item*|用途 >用于比较两个 <scm|rich-integer> 实例中封装的整数值是否相等。
  </description>

  \;

  <subparagraph|谓词特性>

  <scm|%equals> 方法是一个典型的谓词方法，因为它满足以下特性：

  <\description>
    <item*|返回布尔值 >谓词方法的返回值必须是布尔值（<scm|#t> 或 <scm|#f>），而 <scm|%equals> 方法正是返回一个布尔值，表示两个实例是否相等。

    <item*|用于条件判断 >谓词方法通常用于条件判断（如 <scm|if>、<scm|cond> 等）或逻辑操作（如 <scm|and>、<scm|or> 等）。<scm|%equals> 方法可以用于判断两个 <scm|rich-integer> 实例是否相等，从而决定程序的执行路径。

    <item*|与标准谓词一致 ><scm|%equals> 方法与 Scheme 标准库中的谓词（如 <scm|equal?>、<scm|eq?> 等）功能一致，都是通过比较返回布尔值。
  </description>

  \;

  <subparagraph|使用场景>

  <scm|%equals> 方法的主要使用场景包括：

  <\description>
    <item*|比较两个 <scm|rich-integer> 实例 >当需要判断两个 <scm|rich-integer> 实例是否相等时，可以使用 <scm|%equals> 方法。

    <item*|在集中操作中使用 >在需要对 <scm|rich-integer> 实例进行集合操作（如去重、查找等）时，<scm|%equals> 方法可以用于判断实例是否相等。
  </description>

  \;

  <subparagraph|示例>

  <\scm>
    (let ((x ($ 42))

    \ \ \ \ \ \ (y ($ 42))

    \ \ \ \ \ \ (z ($ 43)))

    \ \ (check-true (x :equals y)) \ ; x 和 y 相等，返回 #t

    \ \ (check-false (x :equals z))) \ ; x 和 z 不相等，返回 #f
  </scm>

  \;

  在这个示例中，<scm|x> 和 <scm|y> 是两个封装了相同整数值 <scm|42> 的 <scm|rich-integer> 实例，因此 <scm|x :equals y> 返回 <scm|#t>。而 <verbatim|x> 和 <scm|z> 封装的值不同，因此 <scm|x :equals z> 返回 <scm|#f>。

  \;

  <subparagraph|实现函数>

  <scm|%equals> 方法由 <scm|define-case-class> 宏自动生成。

  \;

  <subparagraph|测试用例>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ($ 42 :equals ($ 42)))

    (check-false ($ 41 :equals ($ 42)))

    \;
  </goldfish-chunk>

  <section|转换器>

  <paragraph|rich-integer%to>

  <scm|rich-integer%to> 是富整数(<scm|rich-integer>)的实例方法，用于生成从当前整数值到目标整数的连续整数序列，返回封装为富列表(<scm|rich-list>)的序列结果。若目标值小于当前值，返回空列表。

  \;

  <subparagraph|功能>

  <\description>
    <item*|生成序列 >返回从当前整数值 <scm|data> 到 <scm|n> 的连续整数序列

    <item*|边界处理 >

    <\itemize-minus>
      <item>当 <scm|n \<gtr\>= data> 时，生成 <scm|[data, data+1, ..., n]> 的闭区间序列

      <item>当 <scm|n \<less\> data> 时，返回空列表 <scm|()>
    </itemize-minus>

    <item*|返回值 >封装为 <scm|rich-list> 样本类，支持链式操作

    <item*|不变性保证 >原 <scm|rich-integer> 值不会被修改
  </description>

  \;

  <subparagraph|使用场景>

  <\description>
    <item*|>生成连续的ID范围

    <item*|>数值模拟时的离散化采样

    <item*|>循环边界初始化

    <item*|>测试数据生成（如 (<scm|$ 1 :to 100>) 生成1-100的测试输入）
  </description>

  \;

  <subparagraph|注意事项>

  <\description>
    <item*|性能 >大范围序列（如 <scm|1 :to 1e6>）会预分配内存

    <item*|类型限制 >参数 <scm|n> 必须为整数（<scm|integer?>）
  </description>

  \;

  <subparagraph|实现函数>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to n)\ 

    \ \ (unless (integer? n)\ 

    \ \ \ \ (type-error\ 

    \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ %to '(n) 'n "integer" (object-\<gtr\>string n))))

    \ \ (if (\<less\> n data)\ 

    \ \ \ \ (rich-list (list))\ 

    \ \ \ \ (rich-list (iota (+ (- n data) 1) data))))

    \;
  </goldfish-chunk>

  <subparagraph|测试用例>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (($ 1 :to 2) :collect) =\<gtr\> (list 1 2))

    (check (($ 1 :to 1) :collect) =\<gtr\> (list 1))

    (check (($ 2 :to 1) :collect) =\<gtr\> (list ))

    \;
  </goldfish-chunk>

  <paragraph|rich-integer%until>

  <scm|rich-integer%until> 是富整数(<scm|rich-integer>)的实例方法，用于生成从当前整数值开始到终止值(不包含)的整数序列，返回封装为富列表(<scm|rich-list>)的序列结果。若当前值大于等于终止值，则返回空列表。

  \;

  <subparagraph|功能>

  <\description>
    <item*|生成序列 >返回从当前整数值 <scm|data> 到 <scm|n-1> 的连续整数序列

    <item*|边界处理 >

    <\itemize-minus>
      <item>若 <scm|n <textless|>= data>，返回空列表

      <item>若 <scm|n <textgreater|> data>，返回 <scm|[data, data+1, ..., n-1]>
    </itemize-minus>

    <item*|返回值 >封装为 <scm|rich-list> 样本类，支持链式操作

    <item*|不变性保证 >原 <scm|rich-integer> 值不会被修改
  </description>

  \;

  <subparagraph|使用场景>

  <\description>
    <item*|范围迭代 >快速生成需要迭代的整数范围（如循环边界）。

    <item*|序列生成 >结合 <scm|rich-list> 的方法（如 <scm|:map、:filter>）进行数据处理。

    <item*|边界检查 >避免手动处理空序列或无效范围。
  </description>

  \;

  <subparagraph|注意事项>

  <\description>
    <item*|与 <scm|:to> 的区别 >

    <\itemize-minus>
      <item><scm|:until> 不包含结束值（<scm|n>），而 <scm|:to> 包含结束值。

      <item>示例对比：

      <\scm>
        ($ 1 :until 3) =\<gtr\> (1 2) \ \ ; 不包含 3

        ($ 1 :to 3) \ \ \ =\<gtr\> (1 2 3) ; 包含 3
      </scm>
    </itemize-minus>

    <item*|性能 >基于 <scm|iota> 实现，时间复杂度为 O(n)，适合小范围序列。
  </description>

  \;

  <subparagraph|实现函数>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%until n)\ 

    \ \ (unless (integer? n)\ 

    \ \ \ \ (type-error\ 

    \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ %until '(n) 'n "integer" (object-\<gtr\>string n))))

    \ \ (if (\<less\>= n data)\ 

    \ \ \ \ (rich-list (list))\ 

    \ \ \ \ (rich-list (iota (+ (- n data)) data))))

    \;
  </goldfish-chunk>

  <subparagraph|测试用例>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (($ 1 :until 3) :collect) =\<gtr\> (list 1 2))

    (check (($ 1 :until 2) :collect) =\<gtr\> (list 1))

    (check (($ 2 :until 2) :collect) =\<gtr\> (list ))

    \;
  </goldfish-chunk>

  <paragraph|rich-integer%to-rich-char>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-rich-char)

    \ \ (rich-char data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-catch 'value-error ($ #x110000 :to-rich-char))

    \;
  </goldfish-chunk>

  <paragraph|rich-integer%to-string>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-string)

    \ \ (number-\<gtr\>string data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ 1 :to-string) =\<gtr\> "1")

    \;
  </goldfish-chunk>

  <section|静态方法>

  <paragraph|rich-integer@max-value>

  Goldfish Scheme中的整数是64位有符号整数，最大值为<math|2<rsup|63>-1>。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@max-value) 9223372036854775807)

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (+ 1 (rich-integer :max-value)) =\<gtr\> (rich-integer :min-value))

    \;
  </goldfish-chunk>

  <paragraph|rich-integer@min-value>

  Goldfish Scheme中的整数是64位有符号整数，最大值为<math|-2<rsup|63>>。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@min-value) -9223372036854775808)

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (- (rich-integer :min-value) 1) =\<gtr\> (rich-integer :max-value))

    \;
  </goldfish-chunk>

  <section|其余函数>

  <paragraph|rich-integer%sqrt>

  求富整数的平方根的整数下界。

  <\equation*>
    <scm|(x :sqrt)>=<around*|\<lfloor\>|<sqrt|x>|\<rfloor\>>
  </equation*>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    ;;return exact integer

    (define (%sqrt)

    \ \ (if (\<less\> data 0)

    \ \ \ \ \ \ (value-error

    \ \ \ \ \ \ \ \ (format #f "sqrt of negative integer is undefined! \ \ \ \ \ \ \ \ ** Got ~a **" data))

    \ \ \ \ \ \ (inexact-\<gtr\>exact (floor (sqrt data)))))

    \;
  </goldfish-chunk>

  测试用例：

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ 0 :sqrt) =\<gtr\> 0) \ \ \ \ \ \ 

    (check ($ 1 :sqrt) =\<gtr\> 1) \ \ \ \ \ \ 

    (check ($ 2 :sqrt) =\<gtr\> 1) \ \ \ \ \ \ 

    (check ($ 9 :sqrt) =\<gtr\> 3) \ \ \ \ \ \ 

    (check ($ 8 :sqrt) =\<gtr\> 2)

    (check ($ 10 :sqrt) =\<gtr\> 3)

    (check ($ 144 :sqrt) =\<gtr\> 12) \ \ \ \ \ \ 

    (check ($ 289 :sqrt) =\<gtr\> 17) \ \ \ \ \ \ 

    (check ($ 290 :sqrt) =\<gtr\> 17) \ \ \ \ \ \ 

    (check ($ 10201 :sqrt) =\<gtr\> 101) \ \ \ \ \ \ 

    (check ($ 10403 :sqrt) =\<gtr\> 101)\ 

    (check ($ (rich-integer :max-value) :sqrt) =\<gtr\> 3037000499)

    (check-catch 'value-error ($ -1 :sqrt))

    \;
  </goldfish-chunk>

  <subsection|结尾>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <chapter|富有理数>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define-case-class rich-rational ((data rational?))

    \;
  </goldfish-chunk>

  <section|选择器>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%get) data)

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ 1/3 :get) =\<gtr\> 1/3)

    (check ($ 0 :get) =\<gtr\> 0)

    (check ($ -1/3 :get) =\<gtr\> -1/3)

    \;
  </scm-chunk>

  <section|其它函数>

  <paragraph|rich-float%abs>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%abs)\ 

    \ \ (if (\<less\> data 0)

    \ \ \ \ \ \ (- 0 data)

    \ \ \ \ \ \ data))

    \ \ 
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ 1/3 :abs) =\<gtr\> 1/3)

    (check ($ 0.0 :abs) =\<gtr\> 0.0)

    (check ($ -1/3 :abs) =\<gtr\> 1/3)

    \;
  </goldfish-chunk>

  <section|结尾>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <chapter|富浮点数>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define-case-class rich-float ((data float?))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
  </goldfish-chunk>

  <section|选择器>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%get) data)

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ 12.2 :get) =\<gtr\> 12.2)

    \;
  </goldfish-chunk>

  <section|谓词>

  <paragraph|rich-float%abs>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%abs)\ 

    \ \ (if (\<less\> data 0)

    \ \ \ \ \ \ (- 0 data)

    \ \ \ \ \ \ data))

    \ \ 
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ 1.1 :abs) =\<gtr\> 1.1)

    (check ($ 0.0 :abs) =\<gtr\> 0.0)

    (check ($ -1.1 :abs) =\<gtr\> 1.1)

    \;
  </goldfish-chunk>

  <section|转换器>

  <paragraph|rich-float%to-string>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-string)

    \ \ (number-\<gtr\>string data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ 1.1 :to-string) =\<gtr\> "1.1")

    (check ($ 0.0 :to-string) =\<gtr\> "0.0")

    (check ($ -1.2 :to-string) =\<gtr\> "-1.2")

    (check ($ 1.0 :to-string) =\<gtr\> "1.0")

    \;
  </goldfish-chunk>

  <section|其余函数>

  <paragraph|rich-float%sqrt>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%sqrt)

    \ \ (if (\<less\> data 0)

    \ \ \ \ \ \ (value-error

    \ \ \ \ \ \ \ \ (format #f "sqrt of negative float is undefined! \ \ \ \ \ \ \ \ ** Got ~a **" data))

    \ \ \ \ \ \ (sqrt data)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ 0.0 :sqrt) =\<gtr\> 0.0) \ \ \ \ \ \ 

    (check ($ 1.0 :sqrt) =\<gtr\> 1.0) \ \ \ \ \ \ 

    (check ($ 1.44 :sqrt) =\<gtr\> 1.2) \ \ \ \ \ \ 

    (check ($ 1.69 :sqrt) =\<gtr\> 1.3) \ \ \ \ \ \ 

    (check-catch 'value-error ($ -1.5 :sqrt))

    \;
  </goldfish-chunk>

  \;

  <section|结尾>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <chapter|富字符>

  富字符支持Unicode，内部采用Unicode码点的整数表示，并且封装了大量常用函数。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define-case-class rich-char ((data any?))

    \ \ 

    (define code-point

    \ \ (cond ((char? data)

    \ \ \ \ \ \ \ \ \ (char-\<gtr\>integer data))

    \ \ \ \ \ \ \ \ ((integer? data)

    \ \ \ \ \ \ \ \ \ (if (and (\<gtr\>= data 0) (\<less\>= data #x10FFFF))

    \ \ \ \ \ \ \ \ \ \ \ \ \ data

    \ \ \ \ \ \ \ \ \ \ \ \ \ (value-error "rich-char: code point out of range" data)))

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (type-error "rich-char: only accept char and integer"))))

    \;
  </goldfish-chunk>

  <section|谓词>

  <paragraph|rich-char%equals>

  重写define-case-class自动生成equals函数。因为rich-char的默认构造函数可以接受整数和字符两种类型，我们需要保证<scm|(rich-char #\\a)>和<scm|(rich-char 65)>是相等的。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%equals that)

    \ \ (cond ((char? that)

    \ \ \ \ \ \ \ \ \ (= code-point (char-\<gtr\>integer that)))

    \ \ \ \ \ \ \ \ ((rich-char :is-type-of that)

    \ \ \ \ \ \ \ \ \ (= code-point (that :to-integer)))

    \ \ \ \ \ \ \ \ (else #f)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ((rich-char #x30) :equals (rich-char #x30)))

    (check-false ((rich-char #x31) :equals (rich-char #x30)))

    \;
  </goldfish-chunk>

  <paragraph|rich-char%ascii?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%ascii?)

    \ \ (and (\<gtr\>= code-point 0) (\<less\>= code-point 127)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ((rich-char #x0) :ascii?))

    (check-true ((rich-char #x7f) :ascii?))

    (check-false ((rich-char #x8f) :ascii?))

    \;

    (check-true ($ #\\a :ascii?))

    (check-true ($ #\\Z :ascii?))

    \;
  </goldfish-chunk>

  <paragraph|rich-char%numeric?>

  <paragraph|rich-char%upper?>

  用于判断字符是否为大写字母，基于 ASCII 字符集的范围（<scm|#x41> 到 <scm|#x5A>）。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%upper?)

    \ \ (and (\<gtr\>= code-point #x41) (\<less\>= code-point #x5A)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    ;; 大写字母

    (check-true ($ #\\A :upper?))

    (check-true ($ #\\Z :upper?))

    \;

    ;; 小写字母

    (check-false ($ #\\a :upper?))

    (check-false ($ #\\z :upper?))

    \;

    ;; 非字母字符

    (check-false ($ #\\0 :upper?))

    (check-false ($ #\\@ :upper?)) \ ;; @ 符号 (ASCII 64)

    (check-false ($ #\\[ :upper?)) \ ;; 左方括号 (ASCII 91)

    \;
  </goldfish-chunk>

  <paragraph|rich-char%lower?>

  用于判断字符是否为小写字母，基于ASCII字符集的范围（<scm|#x61>到<scm|#x7A>）

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%lower?)

    \ \ (and (\<gtr\>= code-point #x61) (\<less\>= code-point #x7A)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    ;; 小写字母

    (check-true ($ #\\a :lower?))

    (check-true ($ #\\z :lower?))

    \;

    ;; 大写字母

    (check-false ($ #\\A :lower?))

    (check-false ($ #\\Z :lower?))

    \;

    ;; 非字母字符

    (check-false ($ #\\0 :lower?))

    (check-false ($ #\\` :lower?)) \ ;; 反引号 (ASCII 96)

    (check-false ($ #\\{ :lower?)) \ ;; 左花括号 (ASCII 123)

    \;
  </goldfish-chunk>

  <paragraph|rich-char%digit?>

  判断一个字符是否为数字。它支持所有 Unicode 标准中定义的数字字符，包括以下范围：

  <tabular|<tformat|<twith|table-hmode|min>|<twith|table-width|1par>|<cwith|1|-1|1|-1|cell-hyphen|t>|<table|<row|<\cell>
    数字名称
  </cell>|<\cell>
    范围
  </cell>|<\cell>
    示例字符
  </cell>>|<row|<\cell>
    <strong|ASCII 数字>
  </cell>|<\cell>
    <code*|U+0030><nbsp>-<nbsp><code*|U+0039>
  </cell>|<\cell>
    <code*|0-9>
  </cell>>|<row|<\cell>
    <strong|全角数字>
  </cell>|<\cell>
    <code*|U+FF10><nbsp>-<nbsp><code*|U+FF19>
  </cell>|<\cell>
    <code*|０-９>
  </cell>>|<row|<\cell>
    <strong|阿拉伯数字>
  </cell>|<\cell>
    <code*|U+0660><nbsp>-<nbsp><code*|U+0669>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|扩展阿拉伯数字>
  </cell>|<\cell>
    <code*|U+06F0><nbsp>-<nbsp><code*|U+06F9>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|印度数字>
  </cell>|<\cell>
    <code*|U+0966><nbsp>-<nbsp><code*|U+096F>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|孟加拉数字>
  </cell>|<\cell>
    <code*|U+09E6><nbsp>-<nbsp><code*|U+09EF>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|古尔穆奇数字>
  </cell>|<\cell>
    <code*|U+0A66><nbsp>-<nbsp><code*|U+0A6F>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|古吉拉特数字>
  </cell>|<\cell>
    <code*|U+0AE6><nbsp>-<nbsp><code*|U+0AEF>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|奥里亚数字>
  </cell>|<\cell>
    <code*|U+0B66><nbsp>-<nbsp><code*|U+0B6F>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|泰米尔数字>
  </cell>|<\cell>
    <code*|U+0BE6><nbsp>-<nbsp><code*|U+0BEF>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|泰卢固数字>
  </cell>|<\cell>
    <code*|U+0C66><nbsp>-<nbsp><code*|U+0C6F>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|卡纳达数字>
  </cell>|<\cell>
    <code*|U+0CE6><nbsp>-<nbsp><code*|U+0CEF>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|马拉雅拉姆数字>
  </cell>|<\cell>
    <code*|U+0D66><nbsp>-<nbsp><code*|U+0D6F>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|泰文数字>
  </cell>|<\cell>
    <code*|U+0E50><nbsp>-<nbsp><code*|U+0E59>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|老挝数字>
  </cell>|<\cell>
    <code*|U+0ED0><nbsp>-<nbsp><code*|U+0ED9>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|藏文数字>
  </cell>|<\cell>
    <code*|U+0F20><nbsp>-<nbsp><code*|U+0F29>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|缅甸数字>
  </cell>|<\cell>
    <code*|U+1040><nbsp>-<nbsp><code*|U+1049>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|高棉数字>
  </cell>|<\cell>
    <code*|U+17E0><nbsp>-<nbsp><code*|U+17E9>
  </cell>|<\cell>
    \;
  </cell>>|<row|<\cell>
    <strong|蒙古数字>
  </cell>|<\cell>
    <code*|U+1810><nbsp>-<nbsp><code*|U+1819>
  </cell>|<\cell>
    \;
  </cell>>>>>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%digit?)

    \ \ (or

    \ \ \ (and (\<gtr\>= code-point 48) (\<less\>= code-point 57))

    \ \ \ (and (\<gtr\>= code-point #xFF10) (\<less\>= code-point #xFF19))

    \ \ \ (and (\<gtr\>= code-point #x0660) (\<less\>= code-point #x0669))

    \ \ \ (and (\<gtr\>= code-point #x06F0) (\<less\>= code-point #x06F9))

    \ \ \ (and (\<gtr\>= code-point #x0966) (\<less\>= code-point #x096F))

    \ \ \ (and (\<gtr\>= code-point #x09E6) (\<less\>= code-point #x09EF))

    \ \ \ (and (\<gtr\>= code-point #x0A66) (\<less\>= code-point #x0A6F))

    \ \ \ (and (\<gtr\>= code-point #x0AE6) (\<less\>= code-point #x0AEF))

    \ \ \ (and (\<gtr\>= code-point #x0B66) (\<less\>= code-point #x0B6F))

    \ \ \ (and (\<gtr\>= code-point #x0BE6) (\<less\>= code-point #x0BEF))

    \ \ \ (and (\<gtr\>= code-point #x0C66) (\<less\>= code-point #x0C6F))

    \ \ \ (and (\<gtr\>= code-point #x0CE6) (\<less\>= code-point #x0CEF))

    \ \ \ (and (\<gtr\>= code-point #x0D66) (\<less\>= code-point #x0D6F))

    \ \ \ (and (\<gtr\>= code-point #x0E50) (\<less\>= code-point #x0E59))

    \ \ \ (and (\<gtr\>= code-point #x0ED0) (\<less\>= code-point #x0ED9))

    \ \ \ (and (\<gtr\>= code-point #x0F20) (\<less\>= code-point #x0F29))

    \ \ \ (and (\<gtr\>= code-point #x1040) (\<less\>= code-point #x1049))

    \ \ \ (and (\<gtr\>= code-point #x17E0) (\<less\>= code-point #x17E9))

    \ \ \ (and (\<gtr\>= code-point #x1810) (\<less\>= code-point #x1819))))

    \ \ 
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((char1 (rich-char 48)) \ ;; ASCII '0'

    \ \ \ \ \ \ (char2 (rich-char #xFF10)) \ ;; 全角 '０'

    \ \ \ \ \ \ (char3 (rich-char #x0660)) \ ;; 阿拉伯数字 '٠'

    \ \ \ \ \ \ (char4 (rich-char #x06F0)) \ ;; 扩展阿拉伯数字 '۰'

    \ \ \ \ \ \ (char5 (rich-char #x0966)) \ ;; 印度数字

    \ \ \ \ \ \ (char6 (rich-char #x09E6)) \ ;; 孟加拉数字

    \ \ \ \ \ \ (char7 (rich-char #x0A66)) \ ;; 古尔穆奇数字

    \ \ \ \ \ \ (char8 (rich-char #x0AE6)) \ ;; 古吉拉特数字

    \ \ \ \ \ \ (char9 (rich-char #x0B66)) \ ;; 奥里亚数字

    \ \ \ \ \ \ (char10 (rich-char #x0BE6)) \ ;; 泰米尔数字

    \ \ \ \ \ \ (char11 (rich-char #x0C66)) \ ;; 泰卢固数字

    \ \ \ \ \ \ (char12 (rich-char #x0CE6)) \ ;; 卡纳达数字\ 

    \ \ \ \ \ \ (char13 (rich-char #x0D66)) \ ;; 马拉雅拉姆数字

    \ \ \ \ \ \ (char14 (rich-char #x0E50)) \ ;; 泰文数字 '๐'

    \ \ \ \ \ \ (char15 (rich-char #x0ED0)) \ ;; 老挝数字

    \ \ \ \ \ \ (char16 (rich-char #x0F20)) \ ;; 藏文数字

    \ \ \ \ \ \ (char17 (rich-char #x1040)) \ ;; 缅甸数字 '၀'

    \ \ \ \ \ \ (char18 (rich-char #x17E0)) \ ;; 高棉数字 '០'

    \ \ \ \ \ \ (char19 (rich-char #x1810)) \ ;; 蒙古数字 '᠐'

    \ \ \ \ \ \ (char20 (rich-char 65))) \ ;; ASCII 'A'

    \;

    \ \ ;; 测试 %digit?

    \ \ (check (char1 :digit?) =\<gtr\> #t) \ ;; ASCII 数字

    \ \ (check (char2 :digit?) =\<gtr\> #t) \ ;; 全角数字

    \ \ (check (char3 :digit?) =\<gtr\> #t) \ ;; 阿拉伯数字

    \ \ (check (char4 :digit?) =\<gtr\> #t) \ ;; 扩展阿拉伯数字

    \ \ (check (char5 :digit?) =\<gtr\> #t) \ ;; 印度数字

    \ \ (check (char6 :digit?) =\<gtr\> #t) \ ;; 孟加拉数字

    \ \ (check (char7 :digit?) =\<gtr\> #t) \ ;; 古尔穆奇数字

    \ \ (check (char8 :digit?) =\<gtr\> #t) \ ;; 古吉拉特数字

    \ \ (check (char9 :digit?) =\<gtr\> #t) \ ;; 奥里亚数字

    \ \ (check (char10 :digit?) =\<gtr\> #t) \ ;; 泰米尔数字

    \ \ (check (char11 :digit?) =\<gtr\> #t) \ ;; 泰卢固数字

    \ \ (check (char12 :digit?) =\<gtr\> #t) \ ;; 卡纳达数字

    \ \ (check (char13 :digit?) =\<gtr\> #t) \ ;; 马拉雅拉姆数字

    \ \ (check (char14 :digit?) =\<gtr\> #t) \ ;; 泰文数字

    \ \ (check (char15 :digit?) =\<gtr\> #t) \ ;; 老挝数字

    \ \ (check (char16 :digit?) =\<gtr\> #t) \ ;; 藏文数字

    \ \ (check (char17 :digit?) =\<gtr\> #t) \ ;; 缅甸数字

    \ \ (check (char18 :digit?) =\<gtr\> #t) \ ;; 高棉数字

    \ \ (check (char19 :digit?) =\<gtr\> #t) \ ;; 蒙古数字

    \ \ (check (char20 :digit?) =\<gtr\> #f)) \ ;; 非数字字符

    \;
  </goldfish-chunk>

  <section|转换>

  <paragraph|rich-char%to-upper>

  目前只支持将英文字母的a-z转换为A-Z，其它字符保持不变。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-upper . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-char

    \ \ \ \ \ \ (if (and (\<gtr\>= code-point #x61) (\<less\>= code-point #x7A))

    \ \ \ \ \ \ \ \ \ \ (bitwise-and code-point #b11011111)

    \ \ \ \ \ \ \ \ \ \ code-point))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #\\a :to-upper) =\<gtr\> #\\A)

    (check ($ #\\z :to-upper) =\<gtr\> #\\Z)

    (check ($ #\\A :to-upper) =\<gtr\> #\\A)

    (check ($ #\\Z :to-upper) =\<gtr\> #\\Z)

    (check ($ #\\@ :to-upper) =\<gtr\> #\\@)

    \;

    (check ($ #\\Z :to-upper :to-lower) =\<gtr\> #\\z) ; chain

    \;
  </goldfish-chunk>

  <paragraph|rich-char%to-lower>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-lower . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-char

    \ \ \ \ \ \ (if (and (\<gtr\>= code-point #x41) (\<less\>= code-point #x5A))

    \ \ \ \ \ \ \ \ \ \ (bitwise-ior code-point #b00100000)

    \ \ \ \ \ \ \ \ \ \ code-point))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #\\A :to-lower) =\<gtr\> #\\a)

    (check ($ #\\Z :to-lower) =\<gtr\> #\\z)

    (check ($ #\\a :to-lower) =\<gtr\> #\\a)

    (check ($ #\\z :to-lower) =\<gtr\> #\\z)

    (check ($ #\\@ :to-lower) =\<gtr\> #\\@)

    \;

    (check ($ #\\z :to-lower :to-upper) =\<gtr\> #\\Z) ; chain

    \;
  </goldfish-chunk>

  <paragraph|rich-char%to-bytevector>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-bytevector)

    \ \ (cond

    \ \ \ \ ((\<less\>= code-point #x7F)

    \ \ \ \ \ (bytevector code-point))

    \;

    \ \ \ \ ((\<less\>= code-point #x7FF)

    \ \ \ \ \ (let ((byte1 (bitwise-ior #b11000000 (bitwise-and (arithmetic-shift code-point -6) #b00011111)))

    \ \ \ \ \ \ \ \ \ \ \ (byte2 (bitwise-ior #b10000000 (bitwise-and code-point #b00111111))))

    \ \ \ \ \ \ \ (bytevector byte1 byte2)))

    \;

    \ \ \ \ ((\<less\>= code-point #xFFFF)

    \ \ \ \ \ (let ((byte1 (bitwise-ior #b11100000 (bitwise-and (arithmetic-shift code-point -12) #b00001111)))

    \ \ \ \ \ \ \ \ \ \ \ (byte2 (bitwise-ior #b10000000 (bitwise-and (arithmetic-shift code-point -6) #b00111111)))

    \ \ \ \ \ \ \ \ \ \ \ (byte3 (bitwise-ior #b10000000 (bitwise-and code-point #b00111111))))

    \ \ \ \ \ \ \ (bytevector byte1 byte2 byte3)))

    \;

    \ \ \ \ ((\<less\>= code-point #x10FFFF)

    \ \ \ \ \ (let ((byte1 (bitwise-ior #b11110000 (bitwise-and (arithmetic-shift code-point -18) #b00000111)))

    \ \ \ \ \ \ \ \ \ \ \ (byte2 (bitwise-ior #b10000000 (bitwise-and (arithmetic-shift code-point -12) #b00111111)))

    \ \ \ \ \ \ \ \ \ \ \ (byte3 (bitwise-ior #b10000000 (bitwise-and (arithmetic-shift code-point -6) #b00111111)))

    \ \ \ \ \ \ \ \ \ \ \ (byte4 (bitwise-ior #b10000000 (bitwise-and code-point #b00111111))))

    \ \ \ \ \ \ \ (bytevector byte1 byte2 byte3 byte4)))

    \;

    \ \ \ \ (else

    \ \ \ \ \ (value-error "Invalid code point"))))

    \;
  </goldfish-chunk>

  <paragraph|rich-char@from-bytevector>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@from-bytevector x)

    \ \ (define (utf8-byte-sequence-\<gtr\>code-point byte-seq)

    \ \ \ \ (let ((len (bytevector-length byte-seq)))

    \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ ((= len 1)

    \ \ \ \ \ \ \ \ \ (bytevector-u8-ref byte-seq 0))

    \ \ \ \ \ \ \ \ ((= len 2)

    \ \ \ \ \ \ \ \ \ (let ((b1 (bytevector-u8-ref byte-seq 0))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (b2 (bytevector-u8-ref byte-seq 1)))

    \ \ \ \ \ \ \ \ \ \ \ (bitwise-ior

    \ \ \ \ \ \ \ \ \ \ \ \ (arithmetic-shift (bitwise-and b1 #x1F) 6)

    \ \ \ \ \ \ \ \ \ \ \ \ (bitwise-and b2 #x3F))))

    \ \ \ \ \ \ \ \ ((= len 3)

    \ \ \ \ \ \ \ \ \ (let ((b1 (bytevector-u8-ref byte-seq 0))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (b2 (bytevector-u8-ref byte-seq 1))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (b3 (bytevector-u8-ref byte-seq 2)))

    \ \ \ \ \ \ \ \ \ \ \ (bitwise-ior

    \ \ \ \ \ \ \ \ \ \ \ \ (arithmetic-shift (bitwise-and b1 #x0F) 12)

    \ \ \ \ \ \ \ \ \ \ \ \ (arithmetic-shift (bitwise-and b2 #x3F) 6)

    \ \ \ \ \ \ \ \ \ \ \ \ (bitwise-and b3 #x3F))))

    \ \ \ \ \ \ \ \ ((= len 4)

    \ \ \ \ \ \ \ \ \ (let ((b1 (bytevector-u8-ref byte-seq 0))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (b2 (bytevector-u8-ref byte-seq 1))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (b3 (bytevector-u8-ref byte-seq 2))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (b4 (bytevector-u8-ref byte-seq 3)))

    \ \ \ \ \ \ \ \ \ \ \ (bitwise-ior

    \ \ \ \ \ \ \ \ \ \ \ (arithmetic-shift (bitwise-and b1 #x07) 18)

    \ \ \ \ \ \ \ \ \ \ \ (arithmetic-shift (bitwise-and b2 #x3F) 12)

    \ \ \ \ \ \ \ \ \ \ \ (arithmetic-shift (bitwise-and b3 #x3F) 6)

    \ \ \ \ \ \ \ \ \ \ \ (bitwise-and b4 #x3F))))

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (value-error "Invalid UTF-8 byte sequence length")))))

    \;

    \ \ (rich-char (utf8-byte-sequence-\<gtr\>code-point x)))

    \;
  </goldfish-chunk>

  <paragraph|rich-char%to-string>

  在Scheme中，有一些表示字符的特殊规则，这种特殊的规则，解决了那些无法显示的字符的显示问题，比如：

  <\session|goldfish|default>
    <\unfolded-io>
      \<gtr\>\ 
    <|unfolded-io>
      #\\space
    <|unfolded-io>
      <goldfish-result|#\\space>
    </unfolded-io>

    <\unfolded-io>
      \<gtr\>\ 
    <|unfolded-io>
      (object-\<gtr\>string (integer-\<gtr\>char 32))
    <|unfolded-io>
      <goldfish-result|"#\\space">
    </unfolded-io>

    <\unfolded-io>
      \<gtr\>\ 
    <|unfolded-io>
      #\\return
    <|unfolded-io>
      <goldfish-result|#\\return>
    </unfolded-io>

    <\folded-io>
      \<gtr\>\ 
    <|folded-io>
      (char-\<gtr\>integer #\\return)
    <|folded-io>
      <goldfish-result|13>
    </folded-io>

    <\folded-io>
      \<gtr\>\ 
    <|folded-io>
      (object-\<gtr\>string (integer-\<gtr\>char 13))
    <|folded-io>
      <goldfish-result|"#\\return">
    </folded-io>

    <\input>
      \<gtr\>\ 
    <|input>
      \;
    </input>
  </session>

  <subparagraph|实现>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-string)

    \ \ (if (%ascii?)

    \ \ \ \ \ \ (object-\<gtr\>string (integer-\<gtr\>char code-point))

    \ \ \ \ \ \ (string-append "#\\\\" (utf8-\>string (%to-bytevector)))))

    \;
  </goldfish-chunk>

  <subparagraph|测试>

  不可见的ASCII字符

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #\\space :to-string) =\<gtr\> "#\\\\space")

    (check ($ #\\return :to-string) =\<gtr\> "#\\\\return")

    \;
  </goldfish-chunk>

  普通的字母

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #\\a :to-string) =\<gtr\> "#\\\\a")

    (check ($ #\\A :to-string) =\<gtr\> "#\\\\A")

    \;
  </goldfish-chunk>

  ASCII范围外的字符：希腊字母、中文、表情符：

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((rich-char #xA3) :to-string) =\<gtr\> "#\\\\£")

    \;

    (check ((rich-char #x4E2D) :to-string) =\<gtr\> "#\\\\<code|中>")

    (check (object-\<gtr\>string (rich-char #x4E2D)) =\<gtr\> "#\\\\中")

    \;

    (check ((rich-char #x1F600) :to-string) =\<gtr\> "#\\\\<code|😀>")

    \;
  </goldfish-chunk>

  <paragraph|rich-char@from-string><typehint|((x string?)) =\<gtr\> rich-char>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@from-string x)

    \ \ (when (not (string-starts? x "#\\\\"))

    \ \ \ \ (value-error "char@from-string: the input must start with #\\\\"))

    \ \ (if (= 1 ($ x :drop 2 :length))

    \ \ \ \ \ \ (rich-char :from-bytevector (string-\<gtr\>utf8 ($ x :drop 2 :get)))

    \ \ \ \ \ \ (value-error "rich-char: must be u8 string which length equals 1")))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    \;
  </goldfish-chunk>

  <paragraph|rich-char%make-string><typehint|() =\<gtr\> string>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%make-string)

    \ \ (utf8-\>string (%to-bytevector)))

    \;
  </goldfish-chunk>

  <subparagraph|测试>

  不可见的ASCII字符

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #\\space :make-string) =\<gtr\> " ")

    (check ($ #\\return :make-string) =\<gtr\> (string #\\return))

    \;
  </goldfish-chunk>

  普通的字母

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #\\a :make-string) =\<gtr\> "a")

    (check ($ #\\A :make-string) =\<gtr\> "A")

    \;
  </goldfish-chunk>

  ASCII范围外的字符：希腊字母、中文、表情符：

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((rich-char #xA3) :make-string) =\<gtr\> "£")

    (check ((rich-char #x4E2D) :make-string) =\<gtr\> "<code|中>")

    (check ((rich-char #x1F600) :make-string) =\<gtr\> "<code|😀>")

    \;
  </goldfish-chunk>

  <paragraph|rich-char@from-integer>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@from-integer x . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-char x)))

    \;
  </goldfish-chunk>

  <paragraph|rich-char%to-integer>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-integer)

    \ \ code-point)

    \;
  </goldfish-chunk>

  <section|结尾>

  \;

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <chapter|富字符串>

  富字符串基于基础的Scheme字符串类型，封装了大量易用的函数，并且支持Unicode。富字符串是不可变字符串，其中的一些字符串的操作，比如移除字符串左侧空白字符，会返回一个新的富字符串，而不是修改当前富字符串。

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define-case-class rich-string

    \ \ ((data string?))

    \ \ 

    (define N (u8-string-length data))

    \;
  </scm-chunk>

  <section|实现细节>

  基于富字符串的不可变性，我们直接在内部定义<scm|N>作为富字符串的长度，避免字符串长度的重复计算。另外，富字符串我们默认采用UTF-8编码，如果传入别的编码格式，目前无法正常处理。

  <section|静态方法>

  <paragraph|rich-string@empty>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@empty . args)

    \ \ (chain-apply args (rich-string "")))

    \;
  </goldfish-chunk>

  <paragraph|rich-string@is-type-of>

  这个静态方法是自动生成的，用于判断一个对象的类型是否是<scm|rich-string>。

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true (rich-string :is-type-of ($ "Hello")))

    \;

    (check-false (rich-string :is-type-of "hello"))

    (check-false (rich-string :is-type-of 1))

    (check-false (rich-string :is-type-of (box 1)))

    \;
  </goldfish-chunk>

  <paragraph|rich-string@value-of>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@value-of v . args)

    \ \ (chain-apply args

    \ \ \ \ (cond ((char? v) (rich-string (string v)))

    \ \ \ \ \ \ \ \ \ \ ((number? v) (rich-string (number-\<gtr\>string v)))

    \ \ \ \ \ \ \ \ \ \ ((symbol? v) (rich-string (symbol-\<gtr\>string v)))

    \ \ \ \ \ \ \ \ \ \ ((string? v) (rich-string v))

    \ \ \ \ \ \ \ \ \ \ ((rich-char :is-type-of v)

    \ \ \ \ \ \ \ \ \ \ \ (rich-string (v :make-string)))

    \ \ \ \ \ \ \ \ \ \ (else (type-error "Expected types are char, rich-char, number, symbol or string")))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (rich-string :value-of #\\a) =\<gtr\> "a")

    (check (rich-string :value-of 'a) =\<gtr\> "a")

    (check (rich-string :value-of 123) =\<gtr\> "123")

    (check (rich-string :value-of 1.0) =\<gtr\> "1.0")

    (check (rich-string :value-of "abc") =\<gtr\> "abc")

    (check (rich-string :value-of (rich-char #x4E2D)) =\<gtr\> "中")

    (check (rich-string :value-of #\\ ) =\<gtr\> " ")

    \;
  </goldfish-chunk>

  <section|选择器>

  <paragraph|rich-string%get>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%get) data)

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "abc" :get) =\<gtr\> "abc")

    (check ($ "" :get) =\<gtr\> "")

    \;
  </goldfish-chunk>

  <paragraph|rich-string%length>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%length)

    \ \ N)

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((rich-string "abc") :length) =\<gtr\> 3)

    (check ((rich-string "中文") :length) =\<gtr\> 2)

    (check (rich-string :empty :length) =\<gtr\> 0)

    \;
  </scm-chunk>

  <paragraph|rich-string%char-at>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%char-at index)

    \ \ (when (not (integer? index))

    \ \ \ \ (type-error "rich-string%char-at: index must be integer" index))

    \;

    \ \ (let* ((start index)

    \ \ \ \ \ \ \ \ \ (end (+ index 1))

    \ \ \ \ \ \ \ \ \ (byte-seq (string-\<gtr\>utf8 data start end)))

    \ \ \ \ (rich-char :from-bytevector byte-seq)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 str ($ "你好，世界")

    \ \ (check (str :char-at 0) =\<gtr\> (rich-char #x4F60)) \ ;; "你" 的 Unicode 码点

    \ \ (check (str :char-at 1) =\<gtr\> (rich-char #x597D)) \ ;; "好" 的 Unicode 码点

    \ \ (check (str :char-at 2) =\<gtr\> (rich-char #xFF0C)) \ ;; "，" 的 Unicode 码点

    \ \ (check (str :char-at 3) =\<gtr\> (rich-char #x4E16)) \ ;; "世" 的 Unicode 码点

    \ \ (check (str :char-at 4) =\<gtr\> (rich-char #x754C)) \ ;; "界" 的 Unicode 码点

    \ \ (check-catch 'out-of-range (str :char-at 10)))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%apply>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%apply i)

    \ \ (%char-at i))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 str ($ "Hello，世界")

    \ \ \ (check (str 0) =\<gtr\> ($ #\\H))

    \ \ \ (check (str 7) =\<gtr\> (rich-char :from-string "#\\\\界")))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%find>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%find pred) ((%to-rich-vector) :find pred))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 s ($ "你好世界HelloWord")

    \ \ (check ((s :find (@ _ :equals ($ "你" 0))) :get)\ 

    \ \ \ \ \ \ \ \ \ \ =\<gtr\> ($ "你" 0))

    \ \ (check-true ((s :find (@ _ :equals ($ "师" 0))) :empty?)))

    \;
  </scm-chunk>

  <paragraph|rich-string%find-last>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%find-last pred) ((%to-rich-vector) :find-last pred))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 s ($ "你好世界HelloWord")

    \ \ (check ((s :find-last (@ _ :equals ($ "你" 0))) :get)\ 

    \ \ \ \ \ \ \ \ \ \ =\<gtr\> ($ "你" 0))

    \ \ (check-true ((s :find-last (@ _ :equals ($ "师" 0))) :empty?)))

    \;
  </scm-chunk>

  <paragraph|rich-string%head><index|rich-string%head>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%head)

    \ \ (if (string-null? data)

    \ \ \ \ \ \ (index-error "rich-string%head: string is empty")

    \ \ \ \ \ \ ($ data 0)))

    \;
  </scm-chunk>

  <paragraph|rich-string%head-option><index|rich-string%head-option>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%head-option)

    \ \ (if (string-null? data)

    \ \ \ \ \ \ (none)

    \ \ \ \ \ \ (option ($ data 0))))

    \;
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "你好" :head) =\<gtr\> ($ "你" 0))

    (check-catch 'index-error (rich-string :empty :head))

    (check ($ "hello" :head-option) =\<gtr\> (option #\\h))

    (check (rich-string :empty :head-option) =\<gtr\> (none))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%last><index|rich-string%last>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%last)

    \ \ (if (string-null? data)

    \ \ \ \ \ \ (index-error "rich-string%last: string is empty")

    \ \ \ \ \ \ ($ data (- N 1))))

    \;
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "你好" :last) =\<gtr\> ($ "好" 0))

    (check-catch 'index-error (rich-string :empty :last))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%last-option><index|rich-string%last-option>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%last-option)

    \ \ (if (string-null? data)

    \ \ \ \ \ \ (none)

    \ \ \ \ \ \ (option ($ data (- N 1)))))

    \;
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "hello" :last-option) =\<gtr\> (option #\\o))

    (check (rich-string :empty :last-option) =\<gtr\> (none))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%slice>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%slice from until . args)

    \ \ (chain-apply args

    \ \ \ \ (let* ((start (max 0 from))

    \ \ \ \ \ \ \ \ \ \ \ (end (min N until)))

    \ \ \ \ \ \ (cond ((and (zero? start) (= end N))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (%this))

    \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= start end)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (rich-string :empty))

    \ \ \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ \ \ (rich-string (u8-substring data start end)))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 str ($ "Hello，世界")

    \ \ \ (check (str :slice 0 5) =\<gtr\> ($ "Hello"))

    \ \ \ (check (str :slice -10 5) =\<gtr\> ($ "Hello"))

    \ \ \ (check (str :slice 6 100) =\<gtr\> ($ "世界"))

    \ \ \ (check (str :slice 6 2) =\<gtr\> ($ ""))

    \ \ \ (check (str :slice -3 -2) =\<gtr\> ($ ""))

    \ \ \ (check (str :slice 100 101) =\<gtr\> ($ ""))

    \ \ \ (check (str :slice -1 100) =\<gtr\> ($ "Hello，世界"))

    \ \ \ (check (str :slice 0 5 :to-string) =\<gtr\> "Hello"))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%take>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%take n . args)

    \ \ (chain-apply args

    \ \ \ \ (%slice 0 n)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 str ($ "Hello，世界")

    \ \ (check (str :take -1) =\<gtr\> "")

    \ \ (check (str :take 0) =\<gtr\> "")

    \ \ (check (str :take 1) =\<gtr\> "H")

    \ \ (check (str :take 8) =\<gtr\> "Hello，世界")

    \ \ (check (str :take 9) =\<gtr\> "Hello，世界"))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%take-right>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%take-right n . args)

    \ \ (chain-apply args

    \ \ \ \ (%slice (- N n) N)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 str ($ "Hello，世界")

    \ \ (check (str :take-right -1) =\<gtr\> "")

    \ \ (check (str :take-right 0) =\<gtr\> "")

    \ \ (check (str :take-right 1) =\<gtr\> "界")

    \ \ (check (str :take-right 8) =\<gtr\> "Hello，世界")

    \ \ (check (str :take-right 9) =\<gtr\> "Hello，世界"))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%drop>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%drop n . args)

    \ \ (chain-apply args

    \ \ \ \ (%slice n N)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 str ($ "Hello，世界")

    \ \ (check (str :drop 1) =\<gtr\> "ello，世界")

    \ \ (check (str :drop 0) =\<gtr\> "Hello，世界")

    \ \ (check (str :drop -1) =\<gtr\> "Hello，世界")

    \ \ (check (str :drop 6) =\<gtr\> "世界")

    \ \ (check (str :drop 7) =\<gtr\> "界")

    \ \ (check (str :drop 8) =\<gtr\> "")

    \ \ (check (str :drop 9) =\<gtr\> ""))

    \;

    (check (rich-string :empty :drop 1) =\<gtr\> "")

    \;
  </goldfish-chunk>

  <paragraph|rich-string%drop-right>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%drop-right n . args)

    \ \ (chain-apply args

    \ \ \ \ (%slice 0 (- N n))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 str ($ "Hello，世界")

    \ \ (check (str :drop-right -1) =\<gtr\> "Hello，世界")

    \ \ (check (str :drop-right 0) =\<gtr\> "Hello，世界")

    \ \ (check (str :drop-right 1) =\<gtr\> "Hello，世")

    \ \ (check (str :drop-right 8) =\<gtr\> "")

    \ \ (check (str :drop-right 8) =\<gtr\> ""))

    \;
  </goldfish-chunk>

  <section|谓词>

  <paragraph|rich-string%equals>

  该函数由<scm|define-case-class>自动生成。

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "42") =\<gtr\> ($ "42"))

    (check-false ($ "41" :equals ($ "42")))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%empty?><typehint|=\<gtr\> boolean?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%empty?)

    \ \ (string-null? data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ((rich-string "") :empty?))

    (check-false ((rich-string "abc") :empty?))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%starts-with>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%starts-with prefix)

    \ \ (string-starts? data prefix))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%ends-with>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%ends-with suffix)

    \ \ (string-ends? data suffix))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%forall>

  检查字符串中的所有字符是否都满足给定的谓词。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%forall pred)

    \ \ ((%to-rich-vector) :forall pred))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-false ($ "全部都是中文" :forall (@ _ :digit?)))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%exists>

  检查字符串中是否存在至少一个字符满足给定的谓词。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%exists pred)

    \ \ ((%to-rich-vector) :exists pred))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ($ "全部都是中文" :exists (@ _ :equals (rich-char :from-string "#\\\\中"))))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%contains>

  检查字符串中是否包含指定的字符或者子字符串。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%contains elem)

    \ \ (cond ((rich-string :is-type-of elem)

    \ \ \ \ \ \ \ \ \ (string-contains data (elem :get)))

    \ \ \ \ 

    \ \ \ \ \ \ \ \ ((string? elem)

    \ \ \ \ \ \ \ \ \ (string-contains data elem))

    \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ ((rich-char :is-type-of elem)

    \ \ \ \ \ \ \ \ \ (string-contains data (elem :make-string)))

    \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ ((char? elem)

    \ \ \ \ \ \ \ \ \ (string-contains data (string elem)))

    \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ (else (type-error "elem must be char or string"))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 str (rich-string "Hello, World!")

    \ \ (check-true (str :contains #\\W))

    \ \ (check-true (str :contains "Hello"))

    \ \ (check-true (str :contains ""))

    \ \ (check-true (str :contains (rich-char #\\W)))

    \ \ (check-true (str :contains ($ "")))

    \ \ (check-true (str :contains ($ "Hello"))))

    \;

    (let1 str (rich-string "你好世界")

    \ \ (check-true (str :contains "好世"))

    \ \ (check-true (str :contains "你"))

    \ \ (check-true (str :contains ($ "你" 0))))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%index-of>

  查找字符串中指定的字符或子串的下标，找不到则返回 -1。默认从字符串起始位置开始查找。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define* (%index-of str/char (start-index 0))

    \ \ (define (bytes-match? data-bv data-pos str-bv str-size data-size)

    \ \ \ \ (let loop ((i 0))

    \ \ \ \ \ \ (if (\<gtr\>= i str-size)

    \ \ \ \ \ \ \ \ \ \ #t

    \ \ \ \ \ \ \ \ \ \ (and (\<less\> (+ data-pos i) data-size)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (= (bytevector-u8-ref data-bv (+ data-pos i))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (bytevector-u8-ref str-bv i))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1))))))

    \;

    \ \ (define (char-index-\<gtr\>byte-pos bv size char-index)

    \ \ \ \ (let loop ((i 0) (pos 0))

    \ \ \ \ \ \ (if (\<gtr\>= i char-index)

    \ \ \ \ \ \ \ \ \ \ pos

    \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) (bytevector-advance-u8 bv pos size)))))

    \ \ 

    \ \ (define* (inner-index-of str start-index)

    \ \ \ \ (if (or (string-null? data) (string-null? str))

    \ \ \ \ \ \ \ \ -1

    \ \ \ \ \ \ \ \ (let* ((data-bv (string-\<gtr\>utf8 data))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (str-bv (string-\<gtr\>utf8 str))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (data-size (bytevector-length data-bv))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (str-size (bytevector-length str-bv)))

    \ \ \ \ \ \ \ \ \ \ (if (or (negative? start-index)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\<gtr\>= start-index N))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ -1

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let ((start-byte-pos (char-index-\<gtr\>byte-pos data-bv data-size start-index)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let search ((byte-pos start-byte-pos) (current-char-index start-index))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\> (+ byte-pos str-size) data-size) -1)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((bytes-match? data-bv byte-pos str-bv str-size data-size)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ current-char-index)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (search (bytevector-advance-u8 data-bv byte-pos data-size)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (+ current-char-index 1))))))))))

    \;

    \ \ (unless (integer? start-index)

    \ \ \ \ (type-error "rich-string%index-of: the second parameter must be integer"))

    \ \ 

    \ \ (let ((positive-start-index (max 0 start-index)))

    \ \ \ \ (cond ((string? str/char)

    \ \ \ \ \ \ \ \ \ \ \ (inner-index-of str/char positive-start-index))

    \ \ \ \ \ \ \ \ \ \ ((rich-string :is-type-of str/char)

    \ \ \ \ \ \ \ \ \ \ \ (inner-index-of (str/char :get) positive-start-index))

    \ \ \ \ \ \ \ \ \ \ ((char? str/char)

    \ \ \ \ \ \ \ \ \ \ \ (inner-index-of (string str/char) positive-start-index))

    \ \ \ \ \ \ \ \ \ \ ((rich-char :is-type-of str/char)

    \ \ \ \ \ \ \ \ \ \ \ (inner-index-of (str/char :make-string) positive-start-index))

    \ \ \ \ \ \ \ \ \ \ (else (type-error "rich-string%index-of: first parameter must be string/rich-string/char/rich-char")))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 str (rich-string "你好，世界！")

    \ \ (check (str :index-of ($ "你")) =\<gtr\> 0)

    \ \ (check (str :index-of ($ "好")) =\<gtr\> 1)

    \ \ (check (str :index-of ($ "世")) =\<gtr\> 3)

    \ \ (check (str :index-of ($ "界")) =\<gtr\> 4)

    \ \ (check (str :index-of ($ "！")) =\<gtr\> 5)

    \ \ (check (str :index-of ($ "中" 0)) =\<gtr\> -1)

    \ \ (check (str :index-of (rich-string "你好")) =\<gtr\> 0)

    \ \ (check (str :index-of (rich-string "世界")) =\<gtr\> 3)

    \ \ (check (str :index-of (rich-string "你好，世界")) =\<gtr\> 0)

    \ \ (check (str :index-of (rich-string "世界！")) =\<gtr\> 3)

    \ \ (check (str :index-of (rich-string "你好，世界！")) =\<gtr\> 0)

    \ \ (check (str :index-of (rich-string "中国")) =\<gtr\> -1)

    \ \ (check (str :index-of ($ "你") 1) =\<gtr\> -1)

    \ \ (check (str :index-of (rich-string "世界") 4) =\<gtr\> -1))

    \;

    (let1 str (rich-string "Hello😀World")

    \ \ (check (str :index-of ($ "😀")) =\<gtr\> 5)

    \ \ (check (str :index-of (rich-string "😀")) =\<gtr\> 5)

    \ \ (check (str :index-of (rich-string "Hello😀")) =\<gtr\> 0)

    \ \ (check (str :index-of (rich-string "😀World")) =\<gtr\> 5)

    \ \ (check (str :index-of ($ "😀") 6) =\<gtr\> -1)

    \ \ (check (str :index-of (rich-string "😀World") 6) =\<gtr\> -1))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "Hello" :index-of #\\e) =\<gtr\> 1)

    (check ($ "Hello" :index-of #\\e 5) =\<gtr\> -1)

    (check ($ "Hello" :index-of #\\e -1) =\<gtr\> 1)

    \;
  </goldfish-chunk>

  <section|高阶函数>

  <paragraph|rich-string%map><typehint|((p procedure?)) =\<gtr\> rich-string?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%map f . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-string ((%to-rich-vector)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :map f

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :map (lambda (x) (x :make-string))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :make-string))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 s ($ "abc" :map (lambda (c) (c :to-upper)))

    \ \ (check s =\<gtr\> "ABC")

    \ \ (check (s :length) =\<gtr\> 3))

    \;

    (check ($ "abc中文" :map (lambda (c) (c :to-upper))) =\<gtr\> "ABC中文")

    \;
  </goldfish-chunk>

  <paragraph|rich-string%filter>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%filter pred . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-string ((%to-rich-vector)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :filter pred

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :map (lambda (x) (x :make-string))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :make-string))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "Hello123" :filter (@ _ :ascii?)) =\<gtr\> "Hello123")

    (check ($ "123abc" :filter (@ _ :digit?)) =\<gtr\> "123")

    (check ($ "ABCabc" :filter (@ _ :upper?)) =\<gtr\> "ABC")

    (check ($ "你好世界hello" :filter (@ _ :equals ($ "你" 0))) =\<gtr\> ($ "你"))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%reverse>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%reverse . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-string ((%to-rich-vector)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :reverse

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :map (lambda (x) (x :make-string))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :make-string))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "Hello123" :filter (@ _ :ascii?) :reverse) =\<gtr\> "321olleH")

    (check ($ "123abc" :filter (@ _ :digit?) :reverse) =\<gtr\> "321")

    (check ($ "ABCabc" :filter (@ _ :upper?) :reverse) =\<gtr\> "CBA")

    (check ($ "你好世界" :drop-while (@ _ :equals ($ "你" 0)) :reverse) =\<gtr\> "界世好")

    \;
  </goldfish-chunk>

  <paragraph|rich-string%for-each>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%for-each f)

    \ \ ((%to-rich-vector) :for-each f))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%count>

  计算字符串中满足给定谓词的字符的数量

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%count pred?)

    \ \ ((%to-rich-vector) :count pred?))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "" :count (@ == _ #\\A)) =\<gtr\> 0)

    (check ($ "hello" :count (@ == _ #\\l)) =\<gtr\> 2)

    (check ($ "你好，我是韩梅梅" :count (@ == _ (rich-char :from-string "#\\\\梅"))) =\<gtr\> 2)

    \;
  </goldfish-chunk>

  <paragraph|rich-string%index-where>

  返回字符串中第一个满足 pred 条件的字符的索引

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%index-where pred)

    \ \ (let ((bytes (string-\<gtr\>utf8 data))

    \ \ \ \ \ \ \ \ (len (bytevector-length (string-\<gtr\>utf8 data))))

    \ \ \ \ (let loop ((byte-pos 0) (char-index 0))

    \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ ((\<gtr\>= byte-pos len) -1)

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (let* ((next-pos (bytevector-advance-u8 bytes byte-pos len))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (char-bytes (bytevector-copy bytes byte-pos next-pos))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (char (rich-char :from-bytevector char-bytes)))

    \ \ \ \ \ \ \ \ \ \ \ (if (pred char)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ char-index

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop next-pos (+ char-index 1)))))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "Hello" :index-where (@ _ :equals (rich-char #\\e))) =\<gtr\> 1)

    (check ($ "" :index-where (@ _ :digit?)) =\<gtr\> -1)

    (check ($ "abc" :index-where (@ _ :digit?)) =\<gtr\> -1)

    (check ($ "中文" :index-where (@ _ :equals (rich-char #x4E2D))) =\<gtr\> 0)

    (check ($ "中文" :index-where (@ _ :equals (rich-char #x6587))) =\<gtr\> 1)

    \;
  </goldfish-chunk>

  <paragraph|rich-string%take-while>

  返回从开头开始连续满足 pred 条件的子字符串

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%take-while pred . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((stop-index (%index-where (lambda (c) (not (pred c))))))

    \ \ \ \ \ \ (if (= stop-index -1)

    \ \ \ \ \ \ \ \ \ \ (%this)

    \ \ \ \ \ \ \ \ \ \ (%slice 0 stop-index)))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "Hello123" :take-while (@ _ :ascii?)) =\<gtr\> "Hello123")

    (check ($ "123abc" :take-while (@ _ :digit?)) =\<gtr\> "123")

    (check ($ "你好World" :take-while (@ _ :ascii?)) =\<gtr\> "")

    (check ($ "" :take-while (@ _ :ascii?)) =\<gtr\> "")

    (check ($ "ABC" :take-while (@ _ :upper?)) =\<gtr\> "ABC")

    (check ($ "123abc" :take-while (@ _ :digit?)) =\<gtr\> ($ "123"))

    (check ($ "你好世界hello" :take-while (@ _ :equals ($ "你" 0))) =\<gtr\> ($ "你"))

    (check ($ "aaaaa" :take-while (@ _ :equals (rich-char #\\a)) :get) =\<gtr\> "aaaaa")

    (check ($ "" :take-while (@ _ :digit?)) =\<gtr\> "")

    \;
  </goldfish-chunk>

  <paragraph|rich-string%drop-while>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%drop-while pred . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((index (%index-where (lambda (c) (not (pred c))))))

    \ \ \ \ \ \ (if (= index -1)

    \ \ \ \ \ \ \ \ \ \ (rich-string "")

    \ \ \ \ \ \ \ \ \ \ (%slice index N)))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ " \ \ hello" :drop-while (@ _ :equals (rich-char #\\space))) =\<gtr\> "hello")

    (check ($ "123abc" :drop-while (@ _ :digit?)) =\<gtr\> "abc")

    (check ($ "你好世界" :drop-while (@ _ :equals ($ "你" 0))) =\<gtr\> "好世界")

    (check ($ "" :drop-while (@ _ :equals (rich-char #\\a))) =\<gtr\> "")

    (check ($ "aaaa" :drop-while (@ _ :equals (rich-char #\\a))) =\<gtr\> "")

    \;
  </goldfish-chunk>

  <section|转换器>

  <paragraph|rich-string%to-string>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-string)

    \ \ data)

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((rich-string "hello") :to-string) =\<gtr\> "hello")

    \;
  </goldfish-chunk>

  <paragraph|rich-string%to-vector>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-vector)

    \ \ (if (string-null? data)

    \ \ \ \ \ \ (vector)

    \ \ \ \ \ \ (let* ((bv (string-\<gtr\>utf8 data))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (bv-size (length bv))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (result (make-vector N)))

    \ \ \ \ \ \ \ \ (let loop ((i 0) (j 0))

    \ \ \ \ \ \ \ \ \ \ (if (\<gtr\>= i N)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ result

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let* ((next-j (bytevector-advance-u8 bv j bv-size))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (ch (rich-char :from-bytevector (bytevector-copy bv j next-j))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector-set! result i ch)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) next-j)))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 v ($ "中文" :to-vector)

    \ \ (check (v 0) =\<gtr\> (rich-char :from-string "#\\\\中"))

    \ \ (check (v 1) =\<gtr\> (rich-char :from-string "#\\\\文")))

    \;

    (let1 v ($ "hello" :to-vector)

    \ \ (check (v 0) =\<gtr\> (box #\\h))

    \ \ (check (v 4) =\<gtr\> (rich-char #\\o)))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%to-rich-vector>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-rich-vector)

    \ \ (rich-vector (%to-vector)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 v ($ "中文的" :to-rich-vector)

    \ \ (check (v :length) =\<gtr\> 3)

    \ \ (check (v 0) =\<gtr\> (rich-char :from-string "#\\\\中"))

    \ \ (check (v 1) =\<gtr\> (rich-char :from-string "#\\\\文"))

    \ \ (check (v 2) =\<gtr\> (rich-char :from-string "#\\\\的")))

    \;
  </goldfish-chunk>

  <section|修改器>

  <paragraph|rich-string%+>

  实例方法<scm|+>是为了简化字符串的拼接，尤其是拼接number类型的变量。

  两种方法的比较：

  <\scm-code>
    ; string concat in R7RS Scheme

    (string-append "Hello " (number-\<gtr\>string 2025))

    ; string concat in Goldfish Scheme

    ($ "Hello " :+ 2025 :get)
  </scm-code>

  后者更加简洁，能够更好地处理字符串和数字拼接。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%+ s . args)

    \ \ (chain-apply args

    \ \ \ \ (cond

    \ \ \ \ \ \ ((string? s)

    \ \ \ \ \ \ \ (rich-string (string-append data s)))

    \ \ \ \ \ \ ((rich-string :is-type-of s)

    \ \ \ \ \ \ \ (rich-string (string-append data (s :get))))

    \ \ \ \ \ \ ((number? s)

    \ \ \ \ \ \ \ (rich-string (string-append data (number-\<gtr\>string s))))

    \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ (type-error (string-append (object-\<gtr\>string s) "is not string or rich-string or number"))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "Hello" :+ " " :+ "World") =\<gtr\> "Hello World")

    (check ($ "hello " :+ (box "world")) =\<gtr\> "hello world")

    (check ($ "Hello " :+ 2025) =\<gtr\> "Hello 2025")

    (check ($ "Price is " :+ 1.2) =\<gtr\> "Price is 1.2")

    \;
  </goldfish-chunk>

  <paragraph|rich-string%strip-left>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%strip-left . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-string (string-trim data))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ " abc " :strip-left) =\<gtr\> "abc ")

    (check ($ " \ \ abc" :strip-left) =\<gtr\> "abc")

    (check ($ "\\t\\n abc" :strip-left) =\<gtr\> "abc")

    (check ($ " \\t \\n abc \\t \\n " :strip-left) =\<gtr\> "abc \\t \\n ")

    (check ($ "" :strip-left) =\<gtr\> "")

    (check ($ " \ \ " :strip-left) =\<gtr\> "")

    \;
  </goldfish-chunk>

  <paragraph|rich-string%strip-right>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%strip-right . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-string (string-trim-right data))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ " abc " :strip-right) =\<gtr\> " abc")

    (check ($ "abc \ \ " :strip-right) =\<gtr\> "abc")

    (check ($ "abc \\t\\n" :strip-right) =\<gtr\> "abc")

    (check ($ " \\t \\n abc \\t \\n " :strip-right) =\<gtr\> " \\t \\n abc")

    (check ($ "" :strip-right) =\<gtr\> "")

    (check ($ " \ \ " :strip-right) =\<gtr\> "")

    \;
  </goldfish-chunk>

  <paragraph|rich-string%strip-both>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%strip-both . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-string (string-trim-both data))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ " abc " :strip-both) =\<gtr\> "abc")

    (check ($ " \ \ abc \ \ " :strip-both) =\<gtr\> "abc")

    (check ($ "\\t\\n abc \\t\\n" :strip-both) =\<gtr\> "abc")

    (check ($ " \\t \\n abc \\t \\n " :strip-both) =\<gtr\> "abc")

    (check ($ "" :strip-both) =\<gtr\> "")

    (check ($ " \ \ " :strip-both) =\<gtr\> "")

    \;
  </goldfish-chunk>

  <paragraph|rich-string%strip-prefix>

  如果前缀不匹配，则返回原富字符串；如果前缀匹配，则返回移除前缀之后的富字符串。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%strip-prefix prefix . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-string (string-remove-prefix data prefix))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "" :strip-prefix "") =\<gtr\> ($ ""))

    (check ($ "hello" :strip-prefix "") =\<gtr\> ($ "hello"))

    (check ($ "hello" :strip-prefix "he") =\<gtr\> ($ "llo"))

    (check ($ "hello" :strip-prefix "hello") =\<gtr\> ($ ""))

    (check ($ "hello" :strip-prefix "abc") =\<gtr\> ($ "hello"))

    (check ($ "hello" :strip-prefix "helloo") =\<gtr\> ($ "hello"))

    (check ($ "hello" :strip-prefix "he" :strip-prefix "ll") =\<gtr\> ($ "o"))

    (check ($ "世界" :strip-prefix "世") =\<gtr\> "界")

    \;

    (check-catch 'wrong-number-of-args ("hello":strip-prefix "he"))

    (check-catch 'unbound-variable (123:strip-prefix 1))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%strip-suffix>

  如果后缀不匹配，则返回原富字符串；如果后缀匹配，则返回移除后缀之后的富字符串。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%strip-suffix suffix . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-string (string-remove-suffix data suffix))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "" :strip-suffix "") =\<gtr\> ($ ""))

    (check ($ "hello" :strip-suffix "") =\<gtr\> ($ "hello"))

    (check ($ "hello" :strip-suffix "lo") =\<gtr\> ($ "hel"))

    (check ($ "hello" :strip-suffix "hello") =\<gtr\> ($ ""))

    (check ($ "hello" :strip-suffix "abc") =\<gtr\> ($ "hello"))

    (check ($ "hello" :strip-suffix "hhello") =\<gtr\> ($ "hello"))

    (check ($ "hello" :strip-suffix "lo" :strip-suffix "el") =\<gtr\> ($ "h"))

    (check ($ "世界" :strip-suffix "界") =\<gtr\> "世")

    \;

    (check-catch 'wrong-number-of-args ("hello":strip-suffix "llo"))

    \;
  </goldfish-chunk>

  <paragraph|rich-string%replace-first>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%replace-first old new . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((next-pos (%index-of old)))

    \ \ \ \ \ \ (if (= next-pos -1)

    \ \ \ \ \ \ \ \ \ \ (%this)

    \ \ \ \ \ \ \ \ \ \ ((%slice 0 next-pos)

    \ \ \ \ \ \ \ \ \ \ \ :+ new

    \ \ \ \ \ \ \ \ \ \ \ :+ (%drop (+ next-pos ($ old :length))))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "hahaha" :replace-first "a" "oo") =\<gtr\> ($ "hoohaha"))

    (check ($ "hello" :replace-first "world" "") =\<gtr\> ($ "hello"))

    (check ($ "hello" :replace-first "l" "L" :strip-prefix "he") =\<gtr\> ($ "Llo"))

    \;

    (check ($ "韩梅梅" :replace-first "梅" "雪") =\<gtr\> "韩雪梅")

    \;
  </goldfish-chunk>

  <paragraph|rich-string%replace>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%replace old new . args)

    \ \ (define (replace-helper str old new start)

    \ \ \ \ (let ((next-pos ((rich-string str) :index-of old start)))

    \ \ \ \ \ \ (if (= next-pos -1)

    \ \ \ \ \ \ \ \ \ \ str

    \ \ \ \ \ \ \ \ \ \ (replace-helper ((rich-string str) :replace-first old new :get)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ old new next-pos))))

    \ \ (chain-apply args

    \ \ \ \ (rich-string (replace-helper data old new 0))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "hahaha" :replace "a" "oo") =\<gtr\> ($ "hoohoohoo"))

    (check ($ "hello" :replace "world" "") =\<gtr\> ($ "hello"))

    (check ($ "hello" :replace "l" "L" :strip-prefix "he") =\<gtr\> ($ "LLo"))

    \;

    (check ($ "韩梅梅" :replace "梅" "雪") =\<gtr\> "韩雪雪")

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-string%<code|pad-left>>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define* (%pad-left len (char #\\space) . args)

    \ \ (let ((result (rich-string (string-pad data len char))))

    \ \ \ \ (if (null? args)

    \ \ \ \ \ \ \ \ result

    \ \ \ \ \ \ \ \ (apply result args))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((s (rich-string "test")))

    \ \ (check (s :pad-left 5 #\\# :pad-left 6) =\<gtr\> (rich-string " #test")))

    \;

    (let ((s (rich-string "325")))

    \ \ (check (s :pad-left 5) =\<gtr\> (rich-string " \ 325")))

    \;

    (let ((s (rich-string "8871325")))

    \ \ (check (s :pad-left 5) =\<gtr\> (rich-string "71325")))

    \;

    (check \ ($ "abcdef" :slice 2 5 :pad-left 8 #\\-)

    \ \ \ \ \ \ \ \ =\<gtr\> (rich-string "-----cde"))

    \;

    (let ((s (rich-string "12345")))

    \ \ (check (s :pad-left 5) =\<gtr\> (rich-string "12345")))

    \;

    (let ((s (rich-string "")))

    \ \ (check (s :pad-left 3 #\\*) =\<gtr\> (rich-string "***")))

    \;

    (check-catch 'wrong-number-of-args ($ "test" :pad-left 10 #\\- 0 3 5))

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-string%<code|pad-right>>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define* (%pad-right len (char #\\space) . args)

    \ \ (let ((result (rich-string (string-pad-right data len char))))

    \ \ \ \ (if (null? args)

    \ \ \ \ \ \ \ \ result

    \ \ \ \ \ \ \ \ (apply result args))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((s (rich-string "test")))

    \ \ (check (s :pad-right 5 #\\# :pad-right 6) =\<gtr\> (rich-string "test# ")))

    \;

    (let ((s (rich-string "abc")))

    \ \ (check (s :pad-right 5) =\<gtr\> (rich-string "abc \ "))) \ 

    \;

    (let ((s (rich-string "123")))

    \ \ (check (s :pad-right 6 #\\*) =\<gtr\> (rich-string "123***"))) \ 

    \;

    (let ((s (rich-string "test")))

    \ \ (check (s :pad-right 4) =\<gtr\> (rich-string "test"))) \ 

    \;

    (let ((s (rich-string "overlength")))

    \ \ (check (s :pad-right 5) =\<gtr\> (rich-string "overl"))) \ 

    \;

    (check \ ($ "abcdefgh" :slice 3 6 :pad-right 6 #\\.)

    \ \ \ \ \ \ \ \ =\<gtr\> (rich-string "def..."))

    \;

    (let ((s (rich-string "")))

    \ \ (check (s :pad-right 3 #\\#) =\<gtr\> (rich-string "###")))

    \;

    (check-catch 'wrong-number-of-args ($ "test" :pad-right 10 #\\- 0 3 5))

    \;
  </goldfish-chunk>

  <section|其余函数>

  <paragraph|rich-string%split>

  富字符串按照分隔符分割之后，得到的是富向量，且富向量里面的每一个元素都是基础字符串。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%split sep)

    \ \ (let ((str-len ($ data :length))

    \ \ \ \ \ \ \ \ (sep-len ($ sep :length)))

    \ \ \ \ 

    \ \ \ \ (define (split-helper start acc)

    \ \ \ \ \ \ (let ((next-pos (%index-of sep start)))

    \ \ \ \ \ \ \ \ (if (= next-pos -1)

    \ \ \ \ \ \ \ \ \ \ \ \ (cons (%drop start :get) acc)

    \ \ \ \ \ \ \ \ \ \ \ \ (split-helper (+ next-pos sep-len) (cons (%slice start next-pos :get) acc)))))

    \ \ \ \ 

    \ \ \ \ (if (zero? sep-len)

    \ \ \ \ \ \ \ \ ((%to-rich-vector) :map (lambda (c) (c :make-string)))

    \ \ \ \ \ \ \ \ (rich-vector (reverse-list-\<gtr\>vector (split-helper 0 '()))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ "da@liii.pro" :split "@") =\<gtr\> #("da" "liii.pro"))

    (check ($ "da@liii.pro" :split ".") =\<gtr\> #("da@liii" "pro"))

    (check ($ "test" :split "") =\<gtr\> #("t" "e" "s" "t"))

    (check ($ "aXXbXXcXX" :split "XX") =\<gtr\> #("a" "b" "c" ""))

    (check ($ "a\|\|b\|\|c" :split "\|\|") =\<gtr\> #("a" "b" "c"))

    (check ($ "XXaXXb" :split "XX") =\<gtr\> #("" "a" "b"))

    (check ($ "你好，欢迎使用Liii STEM" :split "，") =\<gtr\> #("你好" "欢迎使用Liii STEM"))

    (check ($ "中国智造，惠及全球" :split "") =\<gtr\> #("中" "国" "智" "造" "，" "惠" "及" "全" "球"))

    \;

    (check (($ "qingyu@liii.pro" :split "@") :head) =\<gtr\> "qingyu")

    (check (($ "127.0.0.1" :split ".") :count) =\<gtr\> 4)

    (check-catch 'wrong-number-of-args ($ "127.0.0.1" :split "." :count))

    \;
  </goldfish-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    )

    \;
  </scm-chunk>

  <chapter|option>

  <section|option>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define-case-class option ((value any?))

    \;
  </goldfish-chunk>

  <subsection|选择器>

  <paragraph|option%get>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%get)

    \ \ (if (null? value)

    \ \ \ \ \ \ (value-error "option is empty, cannot get value")

    \ \ \ \ \ \ value))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((opt1 (option 42)) (opt2 (option '())))

    \ \ (check (opt1 :get) =\<gtr\> 42)

    \ \ (check-catch 'value-error (opt2 :get)))

    \;
  </goldfish-chunk>

  <paragraph|option%get-or-else>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%get-or-else default)

    \ \ (cond ((not (null? value)) value)

    \ \ \ \ \ \ \ \ ((and (procedure? default) (not (case-class? default)))

    \ \ \ \ \ \ \ \ \ (default))

    \ \ \ \ \ \ \ \ (else default)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((opt1 (option 42)) (opt2 (option '())))

    \ \ (check (opt1 :get-or-else 0) =\<gtr\> 42)

    \ \ (check (opt2 :get-or-else 0) =\<gtr\> 0)

    \;

    \ \ (check (opt1 :get-or-else (lambda () 0)) =\<gtr\> 42)

    \ \ (check (opt2 :get-or-else (lambda () 0)) =\<gtr\> 0)

    )

    \;

    (check ((none) :get-or-else ($ 1)) =\<gtr\> ($ 1))

    \;
  </goldfish-chunk>

  <paragraph|option%or-else>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%or-else default . args)

    \ \ (when (not (option :is-type-of default))

    \ \ \ \ (type-error "The first parameter of option%or-else must be a option case class"))

    \ \ 

    \ \ (chain-apply args

    \ \ \ \ (if (null? value)

    \ \ \ \ \ \ \ \ default

    \ \ \ \ \ \ \ \ (option value))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((opt1 (option 42)) (opt2 (option '())))

    \ \ (check (opt1 :or-else (option 0)) =\<gtr\> (option 42))

    \ \ (check (opt2 :or-else (option 0)) =\<gtr\> (option 0))

    \ \ (check (opt2 :or-else (option 0) :or-else (option 1)) =\<gtr\> (option 0))

    \ \ (check-catch 'type-error (opt1 :or-else 0))

    )

    \;
  </goldfish-chunk>

  <subsection|谓词>

  <paragraph|option%equals>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%equals that)

    \ \ (== value (that 'value)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ((option "str") :equals (option "str")))

    \;
  </goldfish-chunk>

  <paragraph|option%defined?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%defined?) (not (null? value)))

    \ \ 
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((opt1 (option 42)) (opt2 (option '())))

    \ \ (check-true (opt1 :defined?))

    \ \ (check-false (opt2 :defined?)))

    \;
  </goldfish-chunk>

  <paragraph|option%empty?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%empty?)

    \ \ (null? value))

    \;
  </goldfish-chunk>

  <paragraph|option%forall>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%forall f)

    \ \ (if (null? value)

    \ \ \ \ \ \ #f

    \ \ \ \ \ \ (f value)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((opt1 (option 42)) (opt2 (option '())))

    \ \ (check-true (opt1 :forall (lambda (x) (== x 42))))

    \ \ (check-false (opt2 :forall (lambda (x) (== x 42)))))

    \;
  </goldfish-chunk>

  <paragraph|option%exists>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%exists f)

    \ \ (if (null? value)

    \ \ \ \ \ \ #f

    \ \ \ \ \ \ (f value)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((opt1 (option 42)) (opt2 (option '())))

    \ \ (check-true (opt1 :exists (lambda (x) (== x 42))))

    \ \ (check-false (opt2 :exists (lambda (x) (== x 42)))))

    \;
  </goldfish-chunk>

  <paragraph|option%contains>

  如果 <with|font-family|tt|option> 是 <with|font-family|tt|none>，则返回 <with|font-family|tt|#f>；否则，对 <with|font-family|tt|option> 的值应用给定的谓词，并返回谓词的结果。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%contains pred?)

    \ \ (if (null? value)

    \ \ \ \ \ \ #f

    \ \ \ \ \ \ (pred? value)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((option "hello") :contains string?) =\<gtr\> #t)

    (check ((option 42) :contains integer?) =\<gtr\> #t)

    (check ((option #t) :contains boolean?) =\<gtr\> #t)

    (check ((option '()) :contains null?) =\<gtr\> #f)

    (check ((none) :contains string?) =\<gtr\> #f)

    (check ((option "hello") :contains number?) =\<gtr\> #f)

    \;
  </goldfish-chunk>

  <subsection|高阶函数>

  <paragraph|option%for-each>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%for-each f)

    \ \ (when (not (null? value))

    \ \ \ \ \ \ \ \ (f value)))

    \;
  </goldfish-chunk>

  <paragraph|option%map>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%map f . args)

    \ \ (chain-apply args

    \ \ \ \ (if (null? value)

    \ \ \ \ \ \ \ \ (option '())

    \ \ \ \ \ \ \ \ (option (f value)))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((opt1 (option 42))

    \ \ \ \ \ \ (opt2 (option '())))

    \ \ (check (opt1 :map (lambda (x) (+ x 1))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :map (lambda (x) (* x 2))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :get) =\<gtr\> 86)

    \ \ (check (opt2 :map (lambda (x) (+ x 1))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :map (lambda (x) (* x 2))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :empty?) =\<gtr\> #t))

    \;
  </goldfish-chunk>

  <paragraph|option%flatmap>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%flat-map f . args)

    \ \ (chain-apply args

    \ \ \ \ (if (null? value)

    \ \ \ \ \ \ \ \ (option '())

    \ \ \ \ \ \ \ \ (f value))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((opt1 (option 42))

    \ \ \ \ \ \ (opt2 (option '())))

    \ \ (check (opt1 :flat-map (lambda (x) (option (+ x 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :flat-map (lambda (x) (option (* x 2)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :get) =\<gtr\> 86)

    \ \ (check (opt2 :flat-map (lambda (x) (option (+ x 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :flat-map (lambda (x) (option (* x 2)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :empty?) =\<gtr\> #t))

    \;
  </goldfish-chunk>

  <paragraph|option%filter>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%filter pred . args)

    \ \ (chain-apply args

    \ \ \ \ (if (or (null? value) (not (pred value)))

    \ \ \ \ \ \ \ \ (option '())

    \ \ \ \ \ \ \ \ (option value))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((opt1 (option 42))

    \ \ \ \ \ \ (opt2 (option '())))

    \ \ (check (opt1 :filter (lambda (x) (\<gtr\> x 40))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :filter (lambda (x) (\<less\> x 50))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :get) =\<gtr\> 42)

    \ \ (check (opt1 :filter (lambda (x) (\<gtr\> x 50))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :filter (lambda (x) (\<less\> x 60))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :empty?) =\<gtr\> #t)

    \ \ (check (opt2 :filter (lambda (x) (\<gtr\> x 40))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :filter (lambda (x) (\<less\> x 50))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :empty?) =\<gtr\> #t))

    \;
  </goldfish-chunk>

  <subsection|结尾>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <paragraph|none><index|none>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (none) (option '()))

    \;
  </scm-chunk>

  <chapter|either>

  <section|either>

  either通常用于错误处理，通常我们在左值中存放错误信息，在右值中存放关键信息。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define-case-class either

    \ \ ((type symbol?)

    \ \ \ (value any?))

    \;
  </goldfish-chunk>

  \;

  <subsection|谓词>

  <paragraph|either%left?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%left?)

    \ \ (eq? type 'left))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ((left "Value error") :left?))

    (check-false ((right 1) :left?))

    \;
  </goldfish-chunk>

  <paragraph|either%right?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%right?)

    \ \ (eq? type 'right))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-false ((left "Value error") :right?))

    (check-true ((right 1) :right?))

    \;
  </goldfish-chunk>

  <subsection|选择器>

  <paragraph|either%get>

  无论是左值还是右值，直接将值取出。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%get)

    \ \ value)

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((right 1) :get) =\<gtr\> 1)

    (check ((left "error") :get) =\<gtr\> "error")

    \;
  </goldfish-chunk>

  <paragraph|either%or-else>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%or-else default)

    \ \ (unless (case-class? default)\ 

    \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ %or-else '(default) 'default "case-class" (object-\<gtr\>string default)))) \ 

    \ \ 

    \ \ (when (not (default :is-instance-of 'either))

    \ \ \ \ (type-error "The first parameter of either%or-else must be a either case class"))

    \;

    \ \ (if (%right?)

    \ \ \ \ \ \ (%this)

    \ \ \ \ \ \ default))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((right 1) :or-else (right 2)) =\<gtr\> (right 1))

    (check ((left "error") :get-or-else (right 2)) =\<gtr\> (right 2))

    \;
  </goldfish-chunk>

  <paragraph|either%get-or-else>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%get-or-else default)

    \ \ (cond ((%right?) value)

    \ \ \ \ \ \ \ \ ((and (procedure? default) (not (case-class? default)))

    \ \ \ \ \ \ \ \ \ (default))

    \ \ \ \ \ \ \ \ (else default)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((right 1) :get-or-else 2) =\<gtr\> 1)

    (check ((left "error") :get-or-else 2) =\<gtr\> 2)

    (check ((left "error") :get-or-else ($ 2)) =\<gtr\> ($ 2))

    \;
  </goldfish-chunk>

  <subsection|高阶函数>

  <paragraph|either%filter-or-else>

  如果右值存在，并且被给定的 pred 为真，返回右值，否则返回左值（被zero赋值）。如果右值不存在直接返回左值。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%filter-or-else pred zero)

    \ \ (unless (procedure? pred)\ 

    \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ %filter-or-else '(pred zero) 'pred "procedure" (object-\<gtr\>string pred))))

    \ \ 

    \ \ (unless (any? zero)\ 

    \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ %filter-or-else '(pred zero) 'zero "any" (object-\<gtr\>string zero)))) \ 

    \ \ (if (%right?)

    \ \ \ \ \ \ (if (pred value)

    \ \ \ \ \ \ \ \ \ \ (%this)

    \ \ \ \ \ \ \ \ \ \ (left zero))

    \ \ \ \ \ \ (%this)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 r ((right 12) :filter-or-else (lambda (x) (\<gtr\> x 10)) -1)

    \ \ (check-true (r :right?))

    \ \ (check (r :get) =\<gtr\> 12))

    \;

    (let1 r ((right 7) :filter-or-else (lambda (x) (\<gtr\> x 10)) -1)

    \ \ (check-true (r :left?))

    \ \ (check (r :get) =\<gtr\> -1))

    \;

    (let1 r ((left 7) :filter-or-else (lambda (x) #f) -1)

    \ \ (check-true (r :left?))

    \ \ (check (r :get) =\<gtr\> 7))

    \;
  </goldfish-chunk>

  <paragraph|either%contains>

  当且仅当是右值，而且值和传入参数相等，才会返回真，否则返回假。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%contains x)

    \ \ (and (%right?)

    \ \ \ \ \ \ \ (== x value)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ((right 1) :contains 1))

    (check-false ((left "error") :contains 1))

    (check-true ((right (box 1)) :contains 1))

    \;
  </goldfish-chunk>

  <paragraph|either%for-each>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%for-each f)

    \ \ (when (%right?)

    \ \ \ \ (f value)))

    \;
  </goldfish-chunk>

  <paragraph|either%to-option>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-option)

    \ \ (if (%right?)

    \ \ \ \ \ \ (option value)

    \ \ \ \ \ \ (none)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    ;; 测试 1: right 值转换为 option

    (let ((e1 (right 42)))

    \ \ (check ((e1 :to-option) :get) =\<gtr\> 42)

    \ \ (check-true ((e1 :to-option) :defined?))

    \ \ (check-false ((e1 :to-option) :empty?)))

    \;

    ;; 测试 2: left 值转换为 option (应该返回 none)

    (let ((e2 (left "error")))

    \ \ (check ((e2 :to-option) :empty?) =\<gtr\> #t)

    \ \ (check-false ((e2 :to-option) :defined?))

    \ \ (check-catch 'value-error ((e2 :to-option) :get)))

    \;
  </goldfish-chunk>

  <paragraph|either%map>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%map f . args)

    \ \ (chain-apply args

    \ \ \ \ (if (%right?)

    \ \ \ \ \ \ (right (f value))

    \ \ \ \ \ \ (%this))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 r ((right 1) :map (lambda (x) (+ x 1)))

    \ \ (check-true (r :right?))

    \ \ (check (r :get-or-else 0) =\<gtr\> 2))

    \;
  </goldfish-chunk>

  <paragraph|either%flat-map>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%flat-map f . args)

    \ \ (chain-apply args

    \ \ \ \ (if (%right?)

    \ \ \ \ \ \ (f value)

    \ \ \ \ \ \ (%this))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 r ((right 1) :flat-map (lambda (x) (right (+ x 1))))

    \ \ (check-true (r :right?))

    \ \ (check (r :get-or-else 0) =\<gtr\> 2))

    \;
  </goldfish-chunk>

  <paragraph|either%forall>

  如果是左值直接跳过返回真，如果是右值执行谓词判断，参数必须是一个过程。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%forall pred)

    \ \ (unless (procedure? pred)\ 

    \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ %forall '(pred) 'pred "procedure" (object-\<gtr\>string pred))))

    \ \ (if (%right?)

    \ \ \ \ \ \ (pred value)

    \ \ \ \ \ \ #t))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ((left "error") :forall even?))

    (check-true ((right 42) :forall even?))

    (check-false ((right 43) :forall even?))

    (check-false ((right "not-a-number") :forall number?))

    \;
  </goldfish-chunk>

  <paragraph|either%exists>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%exists pred)

    \ \ (unless (procedure? pred)\ 

    \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ %exists '(pred) 'pred "procedure" (object-\<gtr\>string pred))))

    \ \ (if (%right?)

    \ \ \ \ \ \ (pred value)

    \ \ \ \ \ \ #f))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-false ((left "error") :exists even?))

    (check-true ((right 42) :exists even?))

    (check-false ((right 43) :exists even?))

    (check-false ((right "not-a-number") :exists number?))

    \;
  </goldfish-chunk>

  <subsection|结尾>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <section|left>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (left v)

    \ \ (either 'left v))

    \;
  </goldfish-chunk>

  <section|right>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (right v)

    \ \ (either 'right v))

    \;
  </goldfish-chunk>

  <chapter|富列表>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define-case-class rich-list ((data list?))

    \;
  </goldfish-chunk>

  <section|静态方法>

  <paragraph|rich-list@range>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@range start end . step)

    \ \ (let ((step-size (if (null? step) 1 (car step))))

    \ \ \ \ (cond

    \ \ \ \ \ \ ((and (positive? step-size) (\<gtr\>= start end))

    \ \ \ \ \ \ \ (rich-list '()))

    \ \ \ \ \ \ ((and (negative? step-size) (\<less\>= start end))

    \ \ \ \ \ \ \ (rich-list '()))

    \ \ \ \ \ \ ((zero? step-size)

    \ \ \ \ \ \ \ (value-error "Step size cannot be zero"))

    \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ (let ((cnt (ceiling (/ (- end start) step-size))))

    \ \ \ \ \ \ \ \ \ (rich-list (iota cnt start step-size)))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (rich-list :range 1 5) =\<gtr\> ($ (list 1 2 3 4)))

    (check (rich-list :range 1 5 2) =\<gtr\> ($ (list 1 3)))

    (check (rich-list :range 1 6 2) =\<gtr\> ($ (list 1 3 5)))

    (check (rich-list :range 5 1 -1) =\<gtr\> ($ (list 5 4 3 2)))

    \;

    (check (rich-list :range 5 1 1) =\<gtr\> ($ (list )))

    \;

    (check-catch 'value-error (rich-list :range 1 5 0))

    \;
  </goldfish-chunk>

  <paragraph|rich-list@empty>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@empty . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-list (list ))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (rich-list :empty :empty?) =\<gtr\> #t)

    (check (rich-list :empty :head-option) =\<gtr\> (none))

    \;
  </goldfish-chunk>

  <paragraph|rich-list@concat>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@concat lst1 lst2 . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-list (append (lst1 :collect) (lst2 :collect)))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    \;

    (check (rich-list :concat ($ (list 1)) ($ (list 2))) =\<gtr\> ($ (list 1 2)))

    (check (rich-list :concat ($ (list 1 2)) ($ (list 3 4))) =\<gtr\> ($ (list 1 2 3 4)))

    (check (rich-list :concat (rich-list :range 1 4) ($ (list 3 4))) =\<gtr\> ($ (list 1 2 3 3 4)))

    (check (rich-list :concat ($ (list 1)) ($ (list 2))

    \ \ \ \ \ \ \ \ \ \ \ :collect) =\<gtr\> (list 1 2))

    <code|(check (rich-list :concat (rich-list '(1)) (rich-list '(2)) :count) =\> 2)>

    \;
  </goldfish-chunk>

  <paragraph|rich-list@fill>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@fill n elem)

    \ \ (cond

    \ \ \ \ ((\<less\> n 0)

    \ \ \ \ \ \ (value-error "n cannot be negative"))

    \ \ \ \ ((= n 0)

    \ \ \ \ \ \ (rich-list '()))

    \ \ \ \ (else

    \ \ \ \ \ \ (rich-list (make-list n elem)))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 result (rich-list :fill 3 "a")

    \ \ (check (result :collect) =\<gtr\> '("a" "a" "a")))

    \;

    (let1 result (rich-list :fill 0 "a")

    \ \ (check (result :collect) =\<gtr\> '()))

    \;

    (check-catch 'value-error (rich-list :fill -1 "a"))

    \;

    (let1 result (rich-list :fill 2 42)

    \ \ (check (result :collect) =\<gtr\> '(42 42)))

    \;

    (let1 result (rich-list :fill 1000 "x")

    \ \ (check (length (result :collect)) =\<gtr\> 1000))

    \;
  </goldfish-chunk>

  <section|选择器>

  <paragraph|rich-list%collect>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%collect) data)

    \;
  </goldfish-chunk>

  <paragraph|rich-list%apply>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%apply n)

    \ \ (list-ref data n))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ '(1 2 3) :apply 0) =\<gtr\> 1)

    (check ($ '(1 2 3) 0) =\<gtr\> 1)

    \;
  </goldfish-chunk>

  <paragraph|rich-list%find><typehint|((pred procedure?)) =\<gtr\> option?>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%find pred)

    \ \ (let loop ((lst data))

    \ \ \ \ (cond

    \ \ \ \ \ \ ((null? lst) (none))

    \ \ \ \ \ \ ((pred (car lst)) (option (car lst)))

    \ \ \ \ \ \ (else (loop (cdr lst))))))

    \;
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 lst (rich-list '(1 2 3 4 5))

    \ \ (check ((lst :find (lambda (x) (= x 3))) :get) =\<gtr\> 3)

    \ \ (check ((lst :find (lambda (x) (\<gtr\> x 2))) :get) =\<gtr\> 3)

    \ \ (check ((lst :find (lambda (x) (\<gtr\> x 10))) :empty?) =\<gtr\> #t)

    \ \ (check ((lst :find even?) :get) =\<gtr\> 2)

    \ \ (check ((lst :find (lambda (x) (\<less\> x 0))) :empty?) =\<gtr\> #t))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%find-last><typehint|((pred procedure?)) =\<gtr\> option?>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%find-last pred)

    \ \ (let ((reversed-list (reverse data))) \ ; 先反转列表

    \ \ \ \ (let loop ((lst reversed-list))

    \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ ((null? lst) (none)) \ ; 遍历完未找到

    \ \ \ \ \ \ \ \ ((pred (car lst)) (option (car lst))) \ ; 找到第一个匹配项（即原列表最后一个）

    \ \ \ \ \ \ \ \ (else (loop (cdr lst))))))) \ ; 继续查找

    \;
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 lst (rich-list '(1 2 3 4 5))

    \ \ (check ((lst :find-last even?) :get) =\<gtr\> 4) \ ; 最后一个偶数是4

    \ \ (check ((lst :find-last (@ \<gtr\> _ 3)) :get) =\<gtr\> 5) \ ; 最后一个大于3的元素是5

    \ \ (check ((lst :find-last (@ \<gtr\> _ 5)) :empty?) =\<gtr\> #t) \ ; 没有大于5的元素

    \ \ (check ((lst :find-last zero?) :empty?) =\<gtr\> #t) \ ; 没有0

    \ \ (check ((rich-list '()) :find-last even?) =\<gtr\> (none))) \ ; 空列表返回none

    \;
  </goldfish-chunk>

  <paragraph|rich-list%head>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%head)

    \ \ (if (null? data)

    \ \ \ \ \ \ (error 'out-of-range "rich-list%head: list is empty")

    \ \ \ \ \ \ (car data)))

    \;
  </scm-chunk>

  <paragraph|rich-list%head-option>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    <\code>
      (define (%head-option)

      \ \ (if (null? data)

      \ \ \ \ \ \ (none)

      \ \ \ \ \ \ (option (car data))))

      \;
    </code>

    \;
  </scm-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ (list 1 2 3) :head) =\<gtr\> 1)

    (check-catch 'out-of-range (rich-list :empty :head))

    (check ($ (list 1 2 3) :head-option) =\<gtr\> (option 1))

    (check (rich-list :empty :head-option) =\<gtr\> (none))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%last>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%last)

    \ \ (if (null? data)

    \ \ \ \ \ \ (index-error "rich-list%last: empty list")

    \ \ \ \ \ \ (car (reverse data))))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%last-option>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%last-option)

    \ \ (if (null? data)

    \ \ \ \ \ \ (none)

    \ \ \ \ \ \ (option (car (reverse data)))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ (list 1 2 3) :last) =\> 3)

    (check-catch 'index-error (rich-list :empty :last))

    (check ($ (list 1 2 3) :last-option) =\> (option 3))

    (check (rich-list :empty :last-option) =\> (none))

    \;
  </scm-chunk>

  <paragraph|rich-list%slice>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%slice from until . args)

    \ \ (chain-apply args

    \ \ \ \ (let* ((len (length data))

    \ \ \ \ \ \ \ \ \ \ (start (max 0 (min from len)))

    \ \ \ \ \ \ \ \ \ \ (end (max 0 (min until len))))

    \ \ \ \ \ \ (if (\<less\> start end)

    \ \ \ \ \ \ \ \ \ \ (rich-list (take (drop data start) (- end start)))

    \ \ \ \ \ \ \ \ \ \ (rich-list '())))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((lst ($ '(1 2 3 4 5))))

    \ \ ;; 基本切片

    \ \ (check (lst :slice 1 3 :collect) =\<gtr\> '(2 3))

    \;

    \ \ ;; from超出范围

    \ \ (check (lst :slice 10 3 :collect) =\<gtr\> '())

    \;

    \ \ ;; until超出范围

    \ \ (check (lst :slice 2 10 :collect) =\<gtr\> '(3 4 5))

    \;

    \ \ ;; from \<gtr\> until

    \ \ (check (lst :slice 3 1 :collect) =\<gtr\> '())

    \;

    \ \ ;; 负数索引

    \ \ (check (lst :slice -1 3 :collect) =\<gtr\> '(1 2 3))

    \;

    \ \ ;; 链式调用

    \ \ (check (lst :slice 1 4 :map (@ * _ 2) :collect) =\<gtr\> '(4 6 8))

    \;

    \ \ ;; 空切片

    \ \ (check (lst :slice 2 2 :collect) =\<gtr\> '())

    )

    \;
  </goldfish-chunk>

  <section|谓词>

  <paragraph|rich-list%empty?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%empty?)

    \ \ (null? data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ($ (list) :empty?))

    (check-false ($ '(1 2 3) :empty?))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%equals>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%equals that)

    \ \ (let* ((l1 data)

    \ \ \ \ \ \ \ \ \ (l2 (that 'data))

    \ \ \ \ \ \ \ \ \ (len1 (length l1))

    \ \ \ \ \ \ \ \ \ (len2 (length l2)))

    \ \ \ \ (if (not (eq? len1 len2))

    \ \ \ \ \ \ \ \ #f

    \ \ \ \ \ \ \ \ (let loop ((left l1) (right l2))

    \ \ \ \ \ \ \ \ \ \ (cond ((null? left) #t)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((!= (car left) (car right)) #f)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else (loop (cdr left) (cdr right))))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ (list ($ 1) ($ 2) ($ 3))) =\<gtr\> (($ 1 :to 3) :map $))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%forall>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%forall pred)

    \ \ (every pred data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 lst ($ '(1 2 3 4 5))

    \ \ (check (lst :forall (@ \<gtr\> _ 0)) =\<gtr\> #t)

    \ \ (check (lst :forall (@ \<gtr\> _ 3)) =\<gtr\> #f)

    )

    \;

    (check (rich-list :empty :forall (@ \<gtr\> _ 0)) =\<gtr\> #t)

    \;
  </goldfish-chunk>

  <paragraph|rich-list%exists>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%exists pred)

    \ \ (any pred data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 l (rich-list '(1 2 3))

    \ \ (check-true (l :exists even?)))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%contains><typehint|(elem) =\<gtr\> boolean?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%contains elem)

    \ \ (%exists (lambda (x) (equal? x elem))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 l (rich-list '(1 2 3))

    \ \ (check-true (l :contains 1))

    \ \ (check-false (l :contains 4)))

    \;
  </goldfish-chunk>

  <section|高阶函数>

  <paragraph|rich-list%map>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%map x . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-list (map x data))))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%flat-map>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%flat-map x . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-list (flat-map x data))))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%filter>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%filter x . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-list (filter x data))))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%for-each>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%for-each x)

    \ \ (for-each x data))

    \;
  </scm-chunk>

  <paragraph|rich-list%reverse>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%reverse . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-list (reverse data))))

    \ \ \ \ 
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((lst (rich-list '(1 2 3 4 5))))

    \ \ (check (lst :reverse :collect) =\<gtr\> '(5 4 3 2 1)))

    \;

    (let ((lst (rich-list '(a b c d e))))

    \ \ (check (lst :reverse :collect) =\<gtr\> '(e d c b a)))

    \;

    (let ((lst (rich-list '())))

    \ \ (check (lst :reverse :collect) =\<gtr\> '()))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%take>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%take x . args)

    \ \ (chain-apply args

    \ \ \ \ (begin\ 

    \ \ \ \ \ \ (define (scala-take data n)

    \ \ \ \ \ \ \ \ (unless (list? data)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scala-take '(data n) 'data "list" (object-\<gtr\>string data))))

    \ \ \ \ \ \ \ \ (unless (integer? n)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scala-take '(data n) 'n "integer" (object-\<gtr\>string n))))

    \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ (cond ((\<less\> n 0) '())

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= n (length data)) data)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else (take data n))))

    \ \ \ \ 

    \ \ \ \ \ \ (rich-list (scala-take data x)))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((lst (rich-list '(1 2 3 4 5))))

    \ \ (check (lst :take -1 :collect) =\<gtr\> '())

    \ \ (check (lst :take 0 :collect) =\<gtr\> '())

    \ \ (check (lst :take 3 :collect) =\<gtr\> '(1 2 3))

    \ \ (check (lst :take 5 :collect) =\<gtr\> '(1 2 3 4 5))

    \ \ (check (lst :take 10 :collect) =\<gtr\> '(1 2 3 4 5))

    )

    \;
  </scm-chunk>

  \;

  <paragraph|rich-list%drop >

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%drop x . args)

    \ \ (chain-apply args

    \ \ \ \ (begin\ 

    \ \ \ \ \ \ (define (scala-drop data n)

    \ \ \ \ \ \ \ \ (unless (list? data)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scala-drop '(data n) 'data "list" (object-\<gtr\>string data))))

    \ \ \ \ \ \ \ \ (unless (integer? n)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scala-drop '(data n) 'n "integer" (object-\<gtr\>string n))))

    \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ (cond ((\<less\> n 0) data)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= n (length data)) '())

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else (drop data n))))

    \ \ \ \ 

    \ \ \ \ \ \ (rich-list (scala-drop data x)))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((lst (rich-list '(1 2 3 4 5))))

    \ \ (check (lst :drop -1 :collect) =\<gtr\> '(1 2 3 4 5))

    \ \ (check (lst :drop 0 :collect) =\<gtr\> '(1 2 3 4 5))

    \ \ (check (lst :drop 3 :collect) =\<gtr\> '(4 5))

    \ \ (check (lst :drop 5 :collect) =\<gtr\> '())

    \ \ (check (lst :drop 10 :collect) =\<gtr\> '())

    )

    \;
  </goldfish-chunk>

  \;

  <\paragraph>
    rich-list%take-right
  </paragraph>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%take-right x . args)

    \ \ (chain-apply args

    \ \ \ \ (begin\ 

    \ \ \ \ \ \ (define (scala-take-right data n)

    \ \ \ \ \ \ \ \ (unless (list? data)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scala-take-right '(data n) 'data "list" (object-\<gtr\>string data))))

    \ \ \ \ \ \ \ \ (unless (integer? n)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scala-take-right '(data n) 'n "integer" (object-\<gtr\>string n))))

    \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ (cond ((\<less\> n 0) '())

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= n (length data)) data)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else (take-right data n))))

    \ \ \ \ 

    \ \ \ \ \ \ (rich-list (scala-take-right data x)))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((lst (rich-list '(1 2 3 4 5))))

    \ \ (check (lst :take-right -1 :collect) =\<gtr\> '())

    \ \ (check (lst :take-right 0 :collect) =\<gtr\> '())

    \ \ (check (lst :take-right 3 :collect) =\<gtr\> '(3 4 5))

    \ \ (check (lst :take-right 5 :collect) =\<gtr\> '(1 2 3 4 5))

    \ \ (check (lst :take-right 10 :collect) =\<gtr\> '(1 2 3 4 5))

    )

    \;
  </scm-chunk>

  <paragraph|rich-list%drop-right>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%drop-right x . args)

    \ \ (chain-apply args

    \ \ \ \ (begin\ 

    \ \ \ \ \ \ (define (scala-drop-right data n)

    \ \ \ \ \ \ \ \ (unless (list? data)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scala-drop-right '(data n) 'data "list" (object-\<gtr\>string data))))

    \ \ \ \ \ \ \ \ (unless (integer? n)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scala-drop-right '(data n) 'n "integer" (object-\<gtr\>string n))))

    \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ (cond ((\<less\> n 0) data)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= n (length data)) '())

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else (drop-right data n))))

    \ \ \ \ 

    \ \ \ \ \ \ (rich-list (scala-drop-right data x)))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((lst (rich-list '(1 2 3 4 5))))

    \ \ (check (lst :drop-right -1 :collect) =\<gtr\> '(1 2 3 4 5))

    \ \ (check (lst :drop-right 0 :collect) =\<gtr\> '(1 2 3 4 5))

    \ \ (check (lst :drop-right 3 :collect) =\<gtr\> '(1 2))

    \ \ (check (lst :drop-right 5 :collect) =\<gtr\> '())

    \ \ (check (lst :drop-right 10 :collect) =\<gtr\> '())

    )

    \;
  </goldfish-chunk>

  <paragraph|rich-list%count>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%count . xs)

    \ \ (cond ((null? xs) (length data))

    \ \ \ \ \ \ \ \ ((length=? 1 xs) (count (car xs) data))

    \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args "rich-list%count" xs))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ((rich-list (list 1 2 3)) :count) =\<gtr\> 3)

    (check ((rich-list (list 1 2 3)) :count (cut \<gtr\> \<less\>\<gtr\> 1)) =\<gtr\> 2)

    \;
  </scm-chunk>

  <paragraph|rich-list%length>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%length)

    \ \ (length data))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    <code|<\code*>
      (check ($ '() :length) =\> 0)

      (check ($ '(1) :length) =\> 1)

      (check ($ '(1 2) :length) =\> 2)

      (check ($ '(1 2 3) :length) =\> 3)

      (check ($ '(1 2 3 4 5) :length) =\> 5)

      (check ($ '(1 2 3 4 5 6 7 8 9 10) :length) =\> 10)

      \;
    </code*>>
  </scm-chunk>

  <paragraph|rich-list%fold>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%fold initial f)

    \ \ (fold f initial data))

    \;

    (define (%fold-right initial f)

    \ \ (fold-right f initial data))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((lst (rich-list '(1 2 3 4 5))))

    \ \ (check (lst :fold 0 +) =\<gtr\> 15)

    \ \ (check (lst :fold '() (lambda (x acc) (cons x acc))) =\<gtr\> '(5 4 3 2 1))

    \;

    \ \ (check (lst :fold-right 0 +) =\<gtr\> 15)

    \ \ (check (lst :fold-right '() (lambda (x acc) (cons x acc))) =\<gtr\> '(1 2 3 4 5))

    )

    \;
  </scm-chunk>

  \;

  <paragraph|rich-list%sort-with>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%sort-with less-p . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((sorted-data (list-stable-sort less-p data)))

    \ \ \ \ \ \ \ \ (rich-list sorted-data))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ '(3 1 2 4 5)

    \ \ \ \ \ \ \ \ :sort-with (lambda (x y) (\<less\> x y)))

    \ \ \ \ =\<gtr\> ($ '(1 2 3 4 5)))

    \;

    (check ($ (list 1 3 4 2 5) :sort-with \<less\> :take 2) =\<gtr\> (list 1 2))

    \;

    (check\ 

    \ \ ($ (list 1 3 4 2 5)\ 

    \ \ \ \ \ :sort-with \<less\>

    \ \ \ \ \ :take 2

    \ \ \ \ \ :collect)

    \ \ =\<gtr\> '(1 2))

    \;

    (check\ 

    \ \ ($ '((3 . a) (1 . b) (2 . c) (1 . d))

    \ \ \ \ \ :sort-with (lambda (x y) (\<less\> (car x) (car y))) \ ;; 按 car 排序

    \ \ \ \ \ :collect)

    \ \ =\<gtr\> '((1 . b) (1 . d) (2 . c) (3 . a)))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%sort-by>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%sort-by f . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((sorted-data (list-stable-sort (lambda (x y) (\<less\> (f x) (f y))) data)))

    \ \ \ \ (rich-list sorted-data))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    ;; 测试按绝对值排序

    (check ($ '(-3 1 -2 4 0) :sort-by abs :collect) =\<gtr\> '(0 1 -2 -3 4))

    \ \ 

    ;; 测试按结构体字段排序

    (let ((people ($ '((name . "Alice") (name . "Bob") (name . "Charlie")))))

    \ \ (check (people :sort-by (lambda (p) (string-length (cdr p))) :collect)

    \ \ \ \ \ \ \ \ \ =\<gtr\> '((name . "Bob") (name . "Alice") (name . "Charlie"))))

    \ \ 

    ;; 测试空列表

    (check ($ '() :sort-by identity :collect) =\<gtr\> '())

    \ \ 

    ;; 测试链式调用

    (check ($ '(-3 1 -2 4 0)\ 

    \ \ \ \ \ \ \ \ \ :sort-by abs\ 

    \ \ \ \ \ \ \ \ \ :filter positive?\ 

    \ \ \ \ \ \ \ \ \ :collect)

    \ \ \ \ \ \ \ =\<gtr\> '(1 4))

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-list%group-by>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%group-by func)

    \ \ (let ((group (make-hash-table)))

    \ \ \ \ (for-each

    \ \ \ \ \ \ (lambda (elem)\ 

    \ \ \ \ \ \ \ \ (let ((key (func elem)))

    \ \ \ \ \ \ \ \ \ \ (hash-table-update!/default

    \ \ \ \ \ \ \ \ \ \ \ \ group

    \ \ \ \ \ \ \ \ \ \ \ \ key

    \ \ \ \ \ \ \ \ \ \ \ \ (lambda (current-list) (cons elem current-list))

    \ \ \ \ \ \ \ \ \ \ \ \ '())))

    \ \ \ \ \ \ data)

    \ \ \ \ (hash-table-for-each\ 

    \ \ \ \ \ \ (lambda (k v) (hash-table-set! group k (reverse v)))\ 

    \ \ \ \ \ \ group)

    \ \ (rich-hash-table group)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check \ (($ '(1 2 3 4 5 6) :group-by (@ modulo _ 2)) :collect)

    \ \ \ \ \ \ \ \ =\<gtr\> \ (hash-table 0 '(2 4 6) 1 '(1 3 5)))

    \;

    (check \ (($ '(1 2 3 4 5 6) :group-by (@ modulo _ 3)) :collect)

    \ \ \ \ \ \ \ \ =\<gtr\> \ (hash-table 0 '(3 6) 1 '(1 4) 2 '(2 5)))

    \;

    (check \ (($ '(1 2 3 4 5 6 7) :group-by (@ modulo _ 3)) :collect)

    \ \ \ \ \ \ \ \ =\<gtr\> \ (hash-table 0 '(3 6) 1 '(1 4 7) 2 '(2 5)))

    \;

    (let ((result ($ '("apple" "banana" "cat" "dog") :group-by (@ string-length _))))

    \ \ (check (result :collect)\ 

    \ \ \ \ \ \ \ \ \ \ =\<gtr\> (hash-table 3 '("cat" "dog") 5 '("apple") 6 '("banana"))))

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-list%sliding>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%sliding size . step-arg)

    \ \ (unless (integer? size) (type-error "rich-list%sliding: size must be an integer " size))

    \ \ (unless (\<gtr\> size 0) (value-error "rich-list%sliding: size must be a positive integer " size))

    \;

    \ \ (let ((N (length data)))

    \ \ \ \ (if (null? data)

    \ \ \ \ \ \ \ \ #()

    \ \ \ \ \ \ \ \ (let* ((is-single-arg-case (null? step-arg))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (step (if is-single-arg-case 1 (car step-arg))))

    \;

    \ \ \ \ \ \ \ \ \ \ (when (and (not is-single-arg-case)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (or (not (integer? step)) (\<less\>= step 0)))

    \ \ \ \ \ \ \ \ \ \ \ \ (if (not (integer? step))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "rich-list%sliding: step must be an integer " step)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (value-error "rich-list%sliding: step must be a positive integer " step)))

    \ \ \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ \ \ (if (and is-single-arg-case (\<less\> N size))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector data)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let collect-windows ((current-list-segment data) (result-windows '()))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((null? current-list-segment) (list-\<gtr\>vector (reverse result-windows)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((and is-single-arg-case (\<less\> (length current-list-segment) size))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (list-\<gtr\>vector (reverse result-windows)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let* ((elements-to-take (if is-single-arg-case

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (min size (length current-list-segment))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (current-window (take current-list-segment elements-to-take))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (next-list-segment (if (\<gtr\>= step (length current-list-segment))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ '()

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (drop current-list-segment step))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (collect-windows next-list-segment

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons current-window result-windows)))))))))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    ;; Single-argument sliding for rich-list

    (check ($ '() :sliding 2) =\<gtr\> #())

    (check ($ '(1) :sliding 2) =\<gtr\> #((1)))

    (check ($ '(1 2) :sliding 2) =\<gtr\> #((1 2)))

    (check ($ '(1 2 3) :sliding 2) =\<gtr\> #((1 2) (2 3)))

    (check ($ '(1 2 3 4 5) :sliding 3) =\<gtr\> #((1 2 3) (2 3 4) (3 4 5)))

    (check ($ '(1 2 3 4 5) :sliding 1) =\<gtr\> #((1) (2) (3) (4) (5)))

    (check ($ '(1 2 3) :sliding 3) =\<gtr\> #((1 2 3)))

    (check ($ '(1 2 3) :sliding 4) =\<gtr\> #((1 2 3)))

    \;

    ;; Error cases for size (single-arg) for rich-list

    (check-catch 'value-error ($ '(1 2 3) :sliding 0))

    (check-catch 'value-error ($ '(1 2 3) :sliding -1))

    (check-catch 'type-error ($ '(1 2 3) :sliding 1.5))

    \;

    ;; Two-argument sliding for rich-list

    (check ($ '() :sliding 2 2) =\<gtr\> #())

    (check ($ '(1 2 3 4 5) :sliding 2 2) =\<gtr\> #((1 2) (3 4) (5)))

    (check ($ '(1 2 3 4 5 6) :sliding 2 3) =\<gtr\> #((1 2) (4 5)))

    (check ($ '(1 2 3 4 5) :sliding 3 1) =\<gtr\> #((1 2 3) (2 3 4) (3 4 5) (4 5) (5)))

    (check ($ '(1 2 3 4) :sliding 2 2) =\<gtr\> #((1 2) (3 4)))

    (check ($ '(1 2) :sliding 3 1) =\<gtr\> #((1 2) (2)))

    (check ($ '(1 2 3 4 5) :sliding 3 2) =\<gtr\> #((1 2 3) (3 4 5) (5)))

    (check ($ '(1 2 3 4 5 6 7) :sliding 3 3) =\<gtr\> #((1 2 3) (4 5 6) (7)))

    (check ($ '(1 2 3 4 5) :sliding 5 1) =\<gtr\> #((1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5)))

    (check ($ '(1 2 3 4 5) :sliding 6 1) =\<gtr\> #((1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5)))

    \;

    \;

    ;; Error cases for step (two-arg) for rich-list

    (check-catch 'value-error ($ '(1 2 3) :sliding 2 0))

    (check-catch 'value-error ($ '(1 2 3) :sliding 2 -1))

    (check-catch 'type-error ($ '(1 2 3) :sliding 2 1.5))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%zip>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%zip l . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-list (apply map cons (list data l)))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (($ '(1 2 3)) :zip '(a b c) :collect) =\<gtr\> '((1 . a) (2 . b) (3 . c)))

    (check (($ '(1 2 3)) :zip '(a b) :collect) =\<gtr\> '((1 . a) (2 . b)))

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-list%zip-with-index>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%zip-with-index . args)

    \ \ (chain-apply args

    \ \ \ \ (let loop ((lst data) (idx 0) (result '()))

    \ \ \ \ \ \ (if (null? lst)

    \ \ \ \ \ \ \ \ \ \ (rich-list (reverse result)) \ 

    \ \ \ \ \ \ \ \ \ \ (loop (cdr lst)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (+ idx 1)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons (cons idx (car lst)) result))))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check \ ($ '(a b c) :zip-with-index :collect) \ 

    \ \ \ \ \ \ \ \ =\<gtr\> '((0 . a) (1 . b) (2 . c)))

    \;

    (check \ ($ '() :zip-with-index :collect)\ 

    \ \ \ \ \ \ \ \ =\<gtr\> '())

    \;

    (check \ ($ '(1 1 2 2 2 3 4 5 6 7) :zip-with-index :collect)

    \ \ \ \ \ \ \ \ =\<gtr\> '((0 . 1) (1 . 1) (2 . 2) (3 . 2) (4 . 2) (5 . 3) (6 . 4) (7 . 5) (8 . 6) (9 . 7)))

    \;
  </goldfish-chunk>

  \;

  \;

  <paragraph|rich-list%distinct>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%distinct . args)

    \ \ (chain-apply args

    \ \ \ \ (let loop

    \ \ \ \ \ \ ((result '())\ 

    \ \ \ \ \ \ (data data)\ 

    \ \ \ \ \ \ (ht (make-hash-table)))

    \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ ((null? data) (rich-list (reverse result))) \ 

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (let ((elem (car data)))

    \ \ \ \ \ \ \ \ \ \ \ (if (eq? (hash-table-ref ht elem) #f)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (hash-table-set! ht elem #t) \ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (cons elem result) (cdr data) ht))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop result (cdr data) ht))))))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check \ ($ '(a a b c b) :distinct :collect)\ 

    \ \ \ \ \ \ \ \ =\<gtr\> '(a b c))

    \;

    (check \ ($ '(1 1 1 2 2 3 3 3 3 5 5 5) :distinct :collect)\ 

    \ \ \ \ \ \ \ \ =\<gtr\> '(1 2 3 5))

    \;

    (check \ ($ '() :distinct :collect)\ 

    \ \ \ \ \ \ \ \ =\<gtr\> '())

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-list%reduce>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%reduce f)

    \ \ (if (null? data)

    \ \ \ \ \ \ (value-error "rich-list%reduce: empty list is not allowed to reduce")

    \ \ \ \ \ \ (reduce f '() data)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-catch 'value-error ($ '() :reduce +))

    \;

    (check ($ '(1 2 3) :reduce +) =\<gtr\> 6) \ 

    (check ($ '(2 3 4) :reduce *) =\<gtr\> 24) \ 

    (check ($ '(5) :reduce (lambda (x y) (+ x y 10))) =\<gtr\> 5)

    \;
  </goldfish-chunk>

  <paragraph|rich-list%reduce-option>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%reduce-option f)

    \ \ (if (null? data)

    \ \ \ \ \ \ (none)

    \ \ \ \ \ \ (option (reduce f '() data))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ '() :reduce-option +) =\<gtr\> (none))

    \;

    (check ($ '(1 2 3) :reduce-option +) =\<gtr\> (option 6)) \ 

    (check ($ '(2 3 4) :reduce-option *) =\<gtr\> (option 24)) \ 

    (check ($ '(5) :reduce-option (lambda (x y) (+ x y 10))) =\<gtr\> (option 5))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%take-while>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%take-while pred . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((result (take-while pred data)))

    \ \ \ \ \ \ (rich-list result))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ '(1 2 3 4 5 6 7) :take-while (@ \<less\> _ 5) :collect) =\<gtr\> '(1 2 3 4))

    (check ($ '() :take-while (@ \<less\> _ 5) :collect) =\<gtr\> '())

    (check ($ '(1 2 3) :take-while number? :collect) =\<gtr\> '(1 2 3))

    (check ($ '(5 1 2 3) :take-while (@ \<less\> _ 3) :collect) =\<gtr\> '())

    \;
  </goldfish-chunk>

  <paragraph|rich-list%drop-while>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%drop-while pred . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((result (drop-while pred data)))

    \ \ \ \ \ \ (rich-list result))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ '(1 2 3 4 5 6 7) :drop-while (@ \<less\> _ 5) :collect) =\<gtr\> '(5 6 7))

    (check ($ '() :drop-while (@ \<less\> _ 5) :collect) =\<gtr\> '())

    (check ($ '(1 2 3) :drop-while number? :collect) =\<gtr\> '())

    (check ($ '(5 1 2 3) :drop-while (@ \<less\> _ 3) :collect) =\<gtr\> '(5 1 2 3))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%index-where>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%index-where pred)

    \ \ (list-index pred data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((xs ($ '(1 2 3 4 5))))

    \ \ (check (xs :index-where even?) =\<gtr\> 1)

    \ \ (check (xs :index-where (@ \<gtr\> _ 3)) =\<gtr\> 3)

    \ \ (check (xs :index-where (@ \<gtr\> _ 5)) =\<gtr\> #f)

    )

    \;
  </goldfish-chunk>

  <paragraph|rich-list%max-by>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%max-by f)

    \ \ (unless (procedure? f)\ 

    \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ %max-by '(f) 'f "procedure" (object-\<gtr\>string f)))) \ \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ (if (null? data)

    \ \ \ \ \ \ (value-error "rich-list%max-by: empty list is not allowed")

    \ \ \ \ \ \ (let loop ((rest (cdr data))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (max-elem (car data))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (max-val (let ((val (f (car data))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (unless (real? val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "rich-list%max-by: procedure must return real number but got"

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (object-\<gtr\>string val)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ val)))

    \ \ \ \ \ \ \ \ (if (null? rest)

    \ \ \ \ \ \ \ \ \ \ \ \ max-elem

    \ \ \ \ \ \ \ \ \ \ \ \ (let* ((current (car rest))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (current-val (let ((val (f current)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (unless (real? val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "rich-list%max-by: procedure must return real number but got"

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (object-\<gtr\>string val)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ val)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (\<gtr\> current-val max-val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (cdr rest) current current-val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (cdr rest) max-elem max-val)))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ '(1 2 3) :max-by identity) =\<gtr\> 3)

    (check ($ '((1) (3) (2)) :max-by car) =\<gtr\> '(3))

    (check-catch 'value-error ($ '() :max-by identity))

    (check-catch 'type-error ($ '(1 2 3) :max-by "not-function"))

    (check-catch 'type-error ($ '("a" "b" "c") :max-by identity))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%min-by>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%min-by f)

    \ \ (unless (procedure? f)\ 

    \ \ \ \ \ \ (type-error\ 

    \ \ \ \ \ \ \ \ (format #f "In funtion #\<less\>~a ~a\<gtr\>: argument *~a* must be *~a*! \ \ \ **Got ~a**"\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ %min-by '(f) 'f "procedure" (object-\<gtr\>string f)))) \ \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ (if (null? data)

    \ \ \ \ \ \ (value-error "rich-list%min-by: empty list is not allowed")

    \ \ \ \ \ \ (let loop ((rest (cdr data))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (min-elem (car data))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (min-val (let ((val (f (car data))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (unless (real? val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "rich-list%min-by: procedure must return real number but got"

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (object-\<gtr\>string val)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ val)))

    \ \ \ \ \ \ \ \ (if (null? rest)

    \ \ \ \ \ \ \ \ \ \ \ \ min-elem

    \ \ \ \ \ \ \ \ \ \ \ \ (let* ((current (car rest))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (current-val (let ((val (f current)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (unless (real? val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "rich-list%min-by: procedure must return real number but got"

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (object-\<gtr\>string val)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ val)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (\<less\> current-val min-val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (cdr rest) current current-val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (cdr rest) min-elem min-val)))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ '(1 2 3) :min-by identity) =\<gtr\> 1)

    (check ($ '((1) (3) (2)) :min-by car) =\<gtr\> '(1))

    (check-catch 'value-error ($ '() :min-by identity))

    (check-catch 'type-error ($ '(1 2 3) :min-by "not-function"))

    (check-catch 'type-error ($ '("a" "b" "c") :min-by identity))

    \;
  </goldfish-chunk>

  <section|修改器>

  <paragraph|rich-list%append>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%append l)

    \ \ (rich-list (append data l)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (rich-list :empty :append (list 1 2)) =\<gtr\> ($ (list 1 2)))

    (check ($ (list 1 2) :append (list )) =\<gtr\> ($ (list 1 2)))

    (check ($ (list 1 2) :append (list 3 4)) =\<gtr\> ($ (list 1 2 3 4)))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%max-by-option>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%max-by-option f)

    \ \ (if (null? data)

    \ \ \ \ \ \ (none)

    \ \ \ \ \ \ (option (%max-by f))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ '() :max-by-option identity) =\<gtr\> (none))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%min-by-option>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%min-by-option f)

    \ \ (if (null? data)

    \ \ \ \ \ \ (none)

    \ \ \ \ \ \ (option (%min-by f))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ '() :min-by-option identity) =\<gtr\> (none))

    \;
  </goldfish-chunk>

  <section|转换器>

  <paragraph|rich-list%to-string>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-string)

    \ \ (object-\<gtr\>string data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (object-\<gtr\>string ($ '(1 2 3))) =\<gtr\> "(1 2 3)")

    \;
  </goldfish-chunk>

  <paragraph|rich-list%make-string>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%make-string . xs)

    \ \ (define (parse-args xs)

    \ \ \ \ (cond

    \ \ \ \ \ \ ((null? xs) (values "" "" ""))

    \ \ \ \ \ \ ((length=? 1 xs)

    \ \ \ \ \ \ \ (let1 sep (car xs)

    \ \ \ \ \ \ \ \ \ (if (string? sep)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (values "" sep "")

    \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "rich-list%make-string: separator must be a string" sep))))

    \ \ \ \ \ \ ((length=? 2 xs)

    \ \ \ \ \ \ \ (error 'wrong-number-of-args "rich-list%make-string: expected 0, 1, or 3 arguments, but got 2" xs))

    \ \ \ \ \ \ ((length=? 3 xs)

    \ \ \ \ \ \ \ (let ((start (car xs))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (sep (cadr xs))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (end (caddr xs)))

    \ \ \ \ \ \ \ \ \ (if (and (string? start) (string? sep) (string? end))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (values start sep end)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (error 'type-error "rich-list%make-string: prefix, separator, and suffix must be strings" xs))))

    \ \ \ \ \ \ (else (error 'wrong-number-of-args "rich-list%make-string: expected 0, 1, or 3 arguments" xs))))

    \;

    \ \ (receive (start sep end) (parse-args xs)

    \ \ \ \ (let1 as-string (lambda (x) (if (string? x) x (object-\<gtr\>string x)))

    \ \ \ \ \ \ \ \ \ \ (string-append start (string-join (map as-string data) sep) end))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 l (rich-list (list 1 2 3))

    \ \ (check (l :make-string) =\<gtr\> "123")

    \ \ (check (l :make-string " ") =\<gtr\> "1 2 3")

    \ \ (check (l :make-string "[" "," "]") =\<gtr\> "[1,2,3]")

    \ \ 

    \ \ (check-catch 'wrong-number-of-args (l :make-string "[" ","))

    \ \ (check-catch 'type-error (l :make-string 123 "," "]"))

    \ \ (check-catch 'type-error (l :make-string "[" 123 "]"))

    \ \ (check-catch 'type-error (l :make-string "[" "," 123))

    )

    \;

    (check ($ (list "a" "b") :make-string) =\<gtr\> "ab")

    (check ($ (list "a" "b") :make-string " ") =\<gtr\> "a b")

    \;
  </scm-chunk>

  <paragraph|rich-list%to-vector>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-vector)

    \ \ (list-\<gtr\>vector data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((lst (rich-list '(1 2 3))))

    \ \ (check (lst :to-vector) =\<gtr\> \ #(1 2 3)))

    \;
  </goldfish-chunk>

  <paragraph|rich-list%to-rich-vector>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-rich-vector)

    \ \ (rich-vector (list-\<gtr\>vector data)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((lst (rich-list '(1 2 3))))

    \ \ (check (lst :to-rich-vector) =\<gtr\> (rich-vector #(1 2 3)))

    \ \ (check ((lst :to-rich-vector) :collect) =\<gtr\> #(1 2 3)))

    \;
  </goldfish-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    )

    \;
  </scm-chunk>

  \;

  <chapter|富向量>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define-case-class rich-vector ((data vector?))

    \;
  </goldfish-chunk>

  <section|静态方法>

  <paragraph|rich-vector@is-type-of>

  该方法由<goldfish-lang|define-case-class>自动生成。

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true (rich-vector :is-type-of (rich-vector :empty)))

    (check-true (rich-vector :is-type-of (rich-vector #(1 2 3))))

    \;

    (check-false (rich-vector :is-type-of #(1 2 3)))

    (check-false (rich-vector :is-type-of 1))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector@range>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@range start end . step)

    \ \ (let ((step-size (if (null? step) 1 (car step))))

    \ \ \ \ (cond

    \ \ \ \ \ \ ((and (positive? step-size) (\<gtr\>= start end))

    \ \ \ \ \ \ \ (rich-vector #()))

    \ \ \ \ \ \ ((and (negative? step-size) (\<less\>= start end))

    \ \ \ \ \ \ \ (rich-vector #()))

    \ \ \ \ \ \ ((zero? step-size)

    \ \ \ \ \ \ \ (value-error "Step size cannot be zero"))

    \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ (let ((cnt (ceiling (/ (- end start) step-size))))

    \ \ \ \ \ \ \ \ \ (rich-vector <code|<code*|(list-\>vector>> (iota cnt start step-size))))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (array :range 1 5) =\<gtr\> ($ (vector 1 2 3 4)))

    (check (array :range 1 5 2) =\<gtr\> ($ (vector 1 3)))

    (check (array :range 1 6 2) =\<gtr\> ($ (vector 1 3 5)))

    (check (array :range 5 1 -1) =\<gtr\> ($ (vector 5 4 3 2)))

    \;

    (check (array :range 5 1 1) =\<gtr\> ($ (vector )))

    \;

    (check-catch 'value-error (array :range 1 5 0))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector@empty>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@empty . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-vector #())))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (array :empty :empty?) =\<gtr\> #t)

    (check (array :empty :head-option) =\<gtr\> (none))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector@fill>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (@fill n elem . args)

    \ \ (unless (integer? n)

    \ \ \ \ (type-error "n must be integer" n))

    \ \ (when (\<less\> n 0)

    \ \ \ \ (value-error "n must be non-negative" n))

    \ \ (chain-apply args

    \ \ \ \ (rich-vector (make-vector n elem))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true (array :fill 0 #\\a :empty?))

    \;

    (check (array :fill 3 #\\a) =\<gtr\> ($ (vector #\\a #\\a #\\a)))

    \;
  </goldfish-chunk>

  <section|选择器>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%collect) data)

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%length>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%length)

    \ \ (vector-length data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #() :length) =\<gtr\> 0)

    (check ($ #(1 2 3) :length) =\<gtr\> 3)

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%size>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%size)

    \ \ (vector-length data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #() :size) =\<gtr\> 0)

    (check ($ #(1 2 3) :size) =\<gtr\> 3)

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%apply>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%apply i)

    \ \ (when (or (\<less\> i 0) (\<gtr\>= i (vector-length data)))

    \ \ \ \ (index-error "rich-vector%apply: out of range with index" i))

    \ \ (vector-ref data i))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #(1 2 3) :apply 1) =\<gtr\> 2)

    (check ($ #(1 2 3) 1) =\<gtr\> 2)

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%index-of>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%index-of x)

    \ \ (or (vector-index (lambda (y) (== x y)) data)

    \ \ \ \ \ \ -1))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))))

    \ \ (check (vec :index-of 1) =\<gtr\> 0)

    \ \ (check (vec :index-of 5) =\<gtr\> 4)

    \ \ (check (vec :index-of 6) =\<gtr\> -1))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%last-index-of>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%last-index-of x)

    \ \ (or (vector-index-right (lambda (y) (== x y)) data)

    \ \ \ \ \ \ -1))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 1 1 5 5))))

    \ \ (check (vec :last-index-of 1) =\<gtr\> 2)

    \ \ (check (vec :last-index-of 5) =\<gtr\> 4)

    \ \ (check (vec :last-index-of 6) =\<gtr\> -1))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%find>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%find p)

    \ \ (let loop ((i 0))

    \ \ \ \ (cond

    \ \ \ \ \ ((\<gtr\>= i (vector-length data)) (none))

    \ \ \ \ \ ((p (vector-ref data i)) (option (vector-ref data i)))

    \ \ \ \ \ (else (loop (+ i 1))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))))

    \ \ (check ((vec :find (lambda (x) (= x 3))) :get) =\<gtr\> 3)

    \ \ (check ((vec :find (lambda (x) (\<gtr\> x 2))) :get) =\<gtr\> 3)

    \ \ (check ((vec :find (lambda (x) (\<gtr\> x 10))) :empty?) =\<gtr\> #t)

    \ \ (check ((vec :find even?) :get) =\<gtr\> 2)

    \ \ (check ((vec :find (lambda (x) (\<less\> x 0))) :empty?) =\<gtr\> #t))

    \;
  </scm-chunk>

  <paragraph|rich-vector%find-last>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%find-last pred)

    \ \ (let loop ((i (- (vector-length data) 1)))

    \ \ \ \ (cond

    \ \ \ \ \ \ ((\<less\> i 0) (none)) \ ; 遍历完所有元素未找到

    \ \ \ \ \ \ ((pred (vector-ref data i)) (option (vector-ref data i))) \ ; 找到符合条件的元素

    \ \ \ \ \ \ (else (loop (- i 1)))))) \ ; 继续向前查找

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))))

    \ \ (check ((vec :find-last even?) :get) =\<gtr\> 4) \ ; 最后一个偶数是4

    \ \ (check ((vec :find-last (@ \<gtr\> _ 3)) :get) =\<gtr\> 5) \ ; 最后一个大于3的元素是5

    \ \ (check ((vec :find-last (@ \<gtr\> _ 5)) :empty?) =\<gtr\> #t) \ ; 没有大于5的元素

    \ \ (check ((vec :find-last zero?) :empty?) =\<gtr\> #t) \ ; 没有0

    \ \ (check ((array :empty) :find-last even?) =\<gtr\> (none))) \ ; 空向量返回none

    \;
  </scm-chunk>

  <paragraph|rich-vector%head>

  <paragraph|rich-vector%head-option>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%head)

    \ \ (if (\<gtr\> (vector-length data) 0)

    \ \ \ \ \ \ (vector-ref data 0)

    \ \ \ \ \ \ (error 'out-of-range "out-of-range")))

    \;

    (define (%head-option)

    \ \ (if (\<gtr\> (vector-length data) 0)

    \ \ \ \ \ \ (option (vector-ref data 0))

    \ \ \ \ \ \ (none)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ (vector 1 2 3) :head) =\> 1)

    (check-catch 'out-of-range (array :empty :head))

    (check ($ (vector 1 2 3) :head-option) =\> (option 1))

    (check (array :empty :head-option) =\> (none))

    \;
  </scm-chunk>

  <paragraph|rich-vector%last>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%last)

    \ \ (let ((len (vector-length data)))

    \ \ \ \ (if (\<gtr\> len 0)

    \ \ \ \ \ \ (vector-ref data (- len 1))

    \ \ \ \ \ \ (index-error "rich-vector%last: empty vector"))))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%last-option>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%last-option)

    \ \ (let ((len (vector-length data)))

    \ \ \ \ (if (\<gtr\> len 0)

    \ \ \ \ \ \ (option (vector-ref data (- len 1)))

    \ \ \ \ \ \ (none))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ (vector 1 2 3) :last) =\> 3)

    (check-catch 'index-error (array :empty :last))

    (check ($ (vector 1 2 3) :last-option) =\> (option 3))

    (check (array :empty :last-option) =\> (none))

    \;
  </scm-chunk>

  <paragraph|rich-vector%slice>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%slice from until . args)

    \ \ (chain-apply args

    \ \ \ \ (let* ((len (vector-length data))

    \ \ \ \ \ \ \ \ \ \ \ (start (max 0 from))

    \ \ \ \ \ \ \ \ \ \ \ (end (min len until)))

    \ \ \ \ \ \ (if (\<less\> start end)

    \ \ \ \ \ \ \ \ \ \ (rich-vector (vector-copy data start end))

    \ \ \ \ \ \ \ \ \ \ (rich-vector :empty)))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 vec (array #(1 2 3 4 5))

    \ \ (check (vec :slice 0 2) =\<gtr\> ($ #(1 2)))

    \ \ (check (vec :slice -1 2) =\<gtr\> ($ #(1 2)))

    \ \ (check (vec :slice 2 -1) =\<gtr\> ($ #()))

    \ \ (check (vec :slice 2 2) =\<gtr\> ($ #()))

    \ \ (check (vec :slice 6 2) =\<gtr\> ($ #()))

    \ \ (check (vec :slice -1 10) =\<gtr\> ($ #(1 2 3 4 5)))

    \ \ (check (vec :slice 4 10) =\<gtr\> ($ #(5)))

    \ \ (check (vec :slice 2 4) =\<gtr\> ($ #(3 4))))

    \;
  </scm-chunk>

  <section|谓词>

  <paragraph|rich-vector%empty?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%empty?)

    \ \ (= (length data) 0))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ($ (vector) :empty?))

    (check-false ($ #(1 2 3) :empty?))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%equals>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%equals that)

    \ \ (and (that :is-instance-of 'rich-vector)

    \ \ \ \ \ \ \ (vector= == data (that 'data))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check-true ($ #(1 2 3) :equals ($ #(1 2 3))))

    \;

    (check ($ (vector ($ "中" 0) ($ "文" 0))) =\<gtr\> ($ "中文" :to-vector))

    \;

    (check-false (($ "中文" :to-rich-vector) :equals ($ "中" 0)))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%forall>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%forall p)

    \ \ (vector-every p data))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))))

    \ \ (check (vec :forall (lambda (x) (\<gtr\> x 0))) =\<gtr\> #t)

    \ \ (check (vec :forall (lambda (x) (\<gtr\> x 3))) =\<gtr\> #f))

    \;

    (let ((empty-vec (array #())))

    \ \ (check (empty-vec :forall (lambda (x) (\<gtr\> x 0))) =\<gtr\> #t))

    \;
  </scm-chunk>

  <paragraph|rich-vector%exists>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%exists p)

    \ \ (vector-any p data))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%contains><typehint|(elem) =\<gtr\> boolean?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%contains elem)

    \ \ (%exists (lambda (x) (equal? x elem))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 vec (rich-vector #(1 2 3))

    \ \ (check-true (vec :contains 1))

    \ \ (check-false (vec :contains 4)))

    \;

    (let1 vec (rich-vector #("/" "tmp" "/"))

    \ \ (check-true (vec :contains "tmp"))

    \ \ (check-true (vec :contains "/"))

    \ \ (check-false (vec :contains "tmpxx")))

    \;
  </goldfish-chunk>

  <section|高阶函数>

  <paragraph|rich-vector%map>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%map x . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-vector (vector-map x data))))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%flat-map>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%flat-map f . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-vector (%map f :reduce vector-append))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 vec (array #(1 2 3 4 5))

    \ \ (check (vec :map (lambda (x) (vector x x))) =\<gtr\> #(#(1 1) #(2 2) #(3 3) #(4 4) #(5 5))))

    \;

    (let1 vec (array #(1 2 3 4 5))

    \ \ (check (vec :flat-map (lambda (x) (vector x x))) =\<gtr\> #(1 1 2 2 3 3 4 4 5 5)))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%filter>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%filter x . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-vector (vector-filter x data))))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%for-each>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%for-each x)

    \ \ (vector-for-each x data))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%reverse>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%reverse . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-vector (reverse data))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (rich-vector #(1 2 3 4 5))))

    \ \ (check (vec :reverse :collect) =\<gtr\> #(5 4 3 2 1)))

    \;

    (let ((vec (rich-vector #(a b c d e))))

    \ \ (check (vec :reverse :collect) =\<gtr\> #(e d c b a)))

    \;

    (let ((vec (rich-vector #())))

    \ \ (check (vec :reverse :collect) =\<gtr\> #()))

    \;

    (let ((vec (rich-vector #("/" "tmp" "/" "tmp2"))))

    \ \ (check (vec :reverse :collect) =\<gtr\> #("tmp2" "/" "tmp" "/")))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%count>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%count . xs)

    \ \ (cond ((null? xs) (vector-length data))

    \ \ \ \ \ \ \ \ ((length=? 1 xs) (vector-count (car xs) data))

    \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args "rich-vector%count" xs))))

    \;
  </scm-chunk>

  <paragraph|rich-vector%take>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%take n . args)

    \ \ (define (scala-take data n)

    \ \ \ \ (cond

    \ \ \ \ \ \ ((\<less\> n 0) (vector))

    \ \ \ \ \ \ ((\<gtr\>= n (vector-length data)) data)

    \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ (let ((new-vec (make-vector n)))

    \ \ \ \ \ \ \ \ \ \ (do ((i 0 (+ i 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= i n) new-vec)

    \ \ \ \ \ \ \ \ \ \ \ \ (vector-set! new-vec i (vector-ref data i)))))))

    \ \ 

    \ \ (chain-apply args

    \ \ \ \ (rich-vector (scala-take data n))))

    \;
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))))

    \ \ (check (vec :take -1 :collect) =\<gtr\> #())

    \ \ (check (vec :take 0 :collect) =\<gtr\> #())

    \ \ (check (vec :take 3 :collect) =\<gtr\> #(1 2 3))

    \ \ (check (vec :take 5 :collect) =\<gtr\> #(1 2 3 4 5))

    \ \ (check (vec :take 10 :collect) =\<gtr\> #(1 2 3 4 5))

    )

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%take-right>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%take-right n . args)

    \ \ (define (scala-take-right data n)

    \ \ \ \ (let ((len (vector-length data)))

    \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ ((\<less\> n 0) (vector))

    \ \ \ \ \ \ \ \ ((\<gtr\>= n len) data)

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ (let ((new-vec (make-vector n)))

    \ \ \ \ \ \ \ \ \ \ \ \ (do ((i (- len n) (+ i 1))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (j 0 (+ j 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= j n) new-vec)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector-set! new-vec j (vector-ref data i))))))))

    \;

    \ \ (chain-apply args

    \ \ \ \ (rich-vector (scala-take-right data n))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))))

    \ \ (check (vec :take-right -1 :collect) =\<gtr\> #())

    \ \ (check (vec :take-right 0 :collect) =\<gtr\> #())

    \ \ (check (vec :take-right 3 :collect) =\<gtr\> #(3 4 5))

    \ \ (check (vec :take-right 5 :collect) =\<gtr\> #(1 2 3 4 5))

    \ \ (check (vec :take-right 10 :collect) =\<gtr\> #(1 2 3 4 5))

    )

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-vector%drop>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%drop n . args)

    \ \ (define (scala-drop data n)

    \ \ \ \ (cond

    \ \ \ \ \ \ ((\<less\> n 0) data)

    \ \ \ \ \ \ ((\<gtr\>= n (vector-length data)) (vector))

    \ \ \ \ \ \ (else (vector-copy data n))))

    \ \ (chain-apply args

    \ \ \ \ (rich-vector (scala-drop data n))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))))

    \ \ (check (vec :drop -1 :collect) =\<gtr\> #(1 2 3 4 5))

    \ \ (check (vec :drop 0 :collect) =\<gtr\> #(1 2 3 4 5))

    \ \ (check (vec :drop 3 :collect) =\<gtr\> #(4 5))

    \ \ (check (vec :drop 5 :collect) =\<gtr\> #())

    \ \ (check (vec :drop 10 :collect) =\<gtr\> #())

    )

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%drop-right>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%drop-right n . args)

    \ \ (define (scala-drop-right data n)

    \ \ \ \ (cond

    \ \ \ \ \ \ ((\<less\> n 0) data)

    \ \ \ \ \ \ ((\<gtr\>= n (vector-length data)) (vector))

    \ \ \ \ \ \ (else (vector-copy data 0 (- (vector-length data) n)))))

    \ \ 

    \ \ (chain-apply args

    \ \ \ \ (rich-vector (scala-drop-right data n))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))))

    \ \ (check (vec :drop-right -1 :collect) =\<gtr\> #(1 2 3 4 5))\ 

    \ \ (check (vec :drop-right 0 :collect) =\<gtr\> #(1 2 3 4 5))\ 

    \ \ (check (vec :drop-right 3 :collect) =\<gtr\> #(1 2))\ 

    \ \ (check (vec :drop-right 5 :collect) =\<gtr\> #())\ 

    \ \ (check (vec :drop-right 10 :collect) =\<gtr\> #())\ 

    )

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%drop-while>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%drop-while pred . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((len (vector-length data)))

    \ \ \ \ \ \ (let loop ((i 0))

    \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= i len) (rich-vector :empty)) \ ; 所有元素都被丢弃

    \ \ \ \ \ \ \ \ \ \ ((pred (vector-ref data i)) (loop (+ i 1))) \ ; 继续丢弃

    \ \ \ \ \ \ \ \ \ \ (else (rich-vector (vector-copy data i)))))))) ; 返回剩余部分

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))) (empty-vec ($ #())))

    \ \ (check (vec :drop-while (@ \<less\> _ 3) :collect) =\<gtr\> #(3 4 5))

    \ \ (check (vec :drop-while (@ \<gtr\> _ 3) :collect) =\<gtr\> #(1 2 3 4 5))

    \ \ (check (vec :drop-while (@ \<less\> _ 3) :drop 1 :collect) =\<gtr\> #(4 5))

    \ \ (check (empty-vec :drop-while (@ \<less\> _ 3) :drop 1 :collect) =\<gtr\> #())

    \ \ (check (vec :drop-while (@ \<less\> _ 100) :collect) =\<gtr\> #())

    )

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%fold>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%fold initial f)

    \ \ (vector-fold f initial data))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%fold-right>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%fold-right initial f)

    \ \ (vector-fold-right f initial data))

    \;
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))))

    \ \ (check (vec :fold 0 +) =\<gtr\> 15)

    \ \ (check (vec :fold '() (lambda (x acc) (cons x acc))) =\<gtr\> '(5 4 3 2 1))

    \;

    \ \ (check (vec :fold-right 0 +) =\<gtr\> 15)

    \ \ (check (vec :fold-right '() (lambda (x acc) (cons x acc))) =\<gtr\> '(1 2 3 4 5))

    )

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%count>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%count . xs)

    \ \ (cond ((null? xs) (vector-length data))

    \ \ \ \ \ \ \ \ ((length=? 1 xs) (count (car xs) (vector-\<gtr\>list data)))

    \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args "rich-vector%count" xs))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #() :count) =\<gtr\> 0)

    (check ($ #() :count (@ \<gtr\> _ 2)) =\<gtr\> 0)

    (check ($ #(1 2 3 4 5) :count) =\<gtr\> 5)

    (check ($ #(1 2 3 4 5) :count (@ \<gtr\> _ 2)) =\<gtr\> 3)

    \;
  </scm-chunk>

  <paragraph|rich-vector%sort-with>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%sort-with less-p . args)

    \ \ (chain-apply args

    \ \ \ \ (rich-vector (vector-stable-sort less-p data))))

    \;
  </goldfish-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (rich-vector #(3 1 4 2 5))))

    \ \ (check (vec :sort-with \<less\>) =\<gtr\> (array #(1 2 3 4 5)))

    \ \ (check (vec :sort-with \<gtr\>) =\<gtr\> (array #(5 4 3 2 1)))

    \ \ (check (vec :sort-with \<less\> :collect) =\<gtr\> #(1 2 3 4 5)))

    \;

    (let ((vec (rich-vector #((2 . 1) (3 . 3) (1 . 3) (1 . 2) (3 . 2)))))

    \ \ (check (vec :sort-with (lambda (x y) (\<less\> (car x) (car y))))

    \ \ \ \ \ \ \ \ \ =\<gtr\> (rich-vector #((1 . 3) (1 . 2) (2 . 1) (3 . 3) (3 . 2))))

    \ \ (check (vec :sort-with (lambda (x y) (\<less\> (cdr x) (cdr y))))

    \ \ \ \ \ \ \ \ \ =\<gtr\> (rich-vector #((2 . 1) (1 . 2) (3 . 2) (3 . 3) (1 . 3)))))

    \;
  </scm-chunk>

  <paragraph|rich-vector%sort-by>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%sort-by f . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((sorted-data (vector-stable-sort (lambda (x y) (\<less\> (f x) (f y))) data)))

    \ \ \ \ \ \ (rich-vector sorted-data))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    ;; 测试按绝对值排序

    (check ($ #(-3 1 -2 4 0) :sort-by abs :collect) =\<gtr\> #(0 1 -2 -3 4))

    \ \ 

    ;; 测试按结构体字段排序

    (let ((people ($ #((name . "Alice") (name . "Bob") (name . "Charlie")))))

    \ \ (check (people :sort-by (lambda (p) (string-length (cdr p))) :collect)

    \ \ \ \ \ \ \ \ \ =\<gtr\> #((name . "Bob") (name . "Alice") (name . "Charlie"))))

    \ \ 

    ;; 测试空向量

    (check ($ #() :sort-by identity :collect) =\<gtr\> #())

    \ \ 

    ;; 测试链式调用

    (check ($ #(-3 1 -2 4 0)\ 

    \ \ \ \ \ \ \ \ \ :sort-by abs\ 

    \ \ \ \ \ \ \ \ \ :filter positive?\ 

    \ \ \ \ \ \ \ \ \ :collect)

    \ \ \ \ \ \ \ =\<gtr\> #(1 4))

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-vector%group-by>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%group-by func)

    \ \ (let ((group (make-hash-table)))

    \ \ \ \ (for-each

    \ \ \ \ \ \ (lambda (elem)\ 

    \ \ \ \ \ \ \ \ (let ((key (func elem)))

    \ \ \ \ \ \ \ \ \ \ (hash-table-update!/default

    \ \ \ \ \ \ \ \ \ \ \ \ group

    \ \ \ \ \ \ \ \ \ \ \ \ key

    \ \ \ \ \ \ \ \ \ \ \ \ (lambda (current-list) (cons elem current-list))

    \ \ \ \ \ \ \ \ \ \ \ \ '())))

    \ \ \ \ \ \ (vector-\<gtr\>list data))

    \ \ \ \ (hash-table-for-each\ 

    \ \ \ \ \ \ (lambda (k v) (hash-table-set! group k (reverse-list-\>vector v)))\ 

    \ \ \ \ \ \ group)

    \ \ \ \ (rich-hash-table group)))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check \ (($ #(1 2 3 4 5 6) :group-by (@ modulo _ 2)) :collect)

    \ \ \ \ \ \ \ \ =\<gtr\> \ (hash-table 0 #(2 4 6) 1 #(1 3 5)))

    \;

    (check \ (($ #(1 2 3 4 5 6) :group-by (@ modulo _ 3)) :collect)

    \ \ \ \ \ \ \ \ =\<gtr\> \ (hash-table 0 #(3 6) 1 #(1 4) 2 #(2 5)))

    \;

    (check \ (($ #(1 2 3 4 5 6 7) :group-by (@ modulo _ 3)) :collect)

    \ \ \ \ \ \ \ \ =\<gtr\> \ (hash-table 0 #(3 6) 1 #(1 4 7) 2 #(2 5)))

    \;

    (let ((result ($ #("apple" "banana" "cat" "dog") :group-by (@ string-length _))))

    \ \ (check (result :collect)\ 

    \ \ \ \ \ \ \ \ \ \ =\<gtr\> (hash-table 3 #("cat" "dog") 5 #("apple") 6 #("banana"))))

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-vector%sliding>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%sliding size . step-arg)

    \ \ (unless (integer? size) (type-error "rich-vector%sliding: size must be an integer " size))

    \ \ (unless (\<gtr\> size 0) (value-error "rich-vector%sliding: size must be a positive integer " size))

    \;

    \ \ (let ((N (vector-length data)))

    \ \ \ \ (if (zero? N)

    \ \ \ \ \ \ \ \ #()

    \ \ \ \ \ \ \ \ (let* ((is-single-arg-case (null? step-arg))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (step (if is-single-arg-case 1 (car step-arg))))

    \;

    \ \ \ \ \ \ \ \ \ \ ;; Validate step if provided

    \ \ \ \ \ \ \ \ \ \ (when (and (not is-single-arg-case)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (or (not (integer? step)) (\<less\>= step 0)))

    \ \ \ \ \ \ \ \ \ \ \ \ (if (not (integer? step))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "rich-vector%sliding: step must be an integer " step)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (value-error "rich-vector%sliding: step must be a positive integer " step)))

    \ \ \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ \ \ ;; single-argument version when N \<less\> size

    \ \ \ \ \ \ \ \ \ \ (if (and is-single-arg-case (\<less\> N size))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector data)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let collect-windows ((current-idx 0) (result-windows '()))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ;; Stop if current_idx is out of bounds

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((\<gtr\>= current-idx N) (list-\<gtr\>vector (reverse result-windows)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ;; For single-arg case

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((and is-single-arg-case (\<gtr\> (+ current-idx size) N))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (list-\<gtr\>vector (reverse result-windows)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let* ((window-end (if is-single-arg-case

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (+ current-idx size) \ \ \ \ \ ;; Single-arg: always takes full 'size'

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (min (+ current-idx size) N))) ;; Two-arg: can be partial

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (current-window (vector-copy data current-idx window-end)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (collect-windows (+ current-idx step) (cons current-window result-windows)))))))))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #() :sliding 2) =\<gtr\> #())

    (check ($ #(1) :sliding 2) =\<gtr\> #(#(1)))

    (check ($ #(1 2) :sliding 2) =\<gtr\> #(#(1 2)))

    (check ($ #(1 2 3) :sliding 2) =\<gtr\> #(#(1 2) #(2 3)))

    (check ($ #(1 2 3 4 5) :sliding 3) =\<gtr\> #(#(1 2 3) #(2 3 4) #(3 4 5)))

    (check ($ #(1 2 3 4 5) :sliding 1) =\<gtr\> #(#(1) #(2) #(3) #(4) #(5)))

    (check ($ #(1 2 3) :sliding 3) =\<gtr\> #(#(1 2 3)))

    (check ($ #(1 2 3) :sliding 4) =\<gtr\> #(#(1 2 3)))

    \;

    ;; Error cases for size

    (check-catch 'value-error ($ #(1 2 3) :sliding 0))

    (check-catch 'value-error ($ #(1 2 3) :sliding -1))

    (check-catch 'type-error ($ #(1 2 3) :sliding 1.5))

    (check-catch 'type-error ($ #(1 2 3) :sliding "a"))

    \;

    ;; Two-argument sliding

    (check ($ #() :sliding 2 2) =\<gtr\> #())

    (check ($ #(1 2 3 4 5) :sliding 2 2) =\<gtr\> #(#(1 2) #(3 4) #(5)))

    (check ($ #(1 2 3 4 5 6) :sliding 2 3) =\<gtr\> #(#(1 2) #(4 5)))

    (check ($ #(1 2 3 4 5) :sliding 3 1) =\<gtr\> #(#(1 2 3) #(2 3 4) #(3 4 5) #(4 5) #(5)))

    (check ($ #(1 2 3 4) :sliding 2 2) =\<gtr\> #(#(1 2) #(3 4)))

    (check ($ #(1 2) :sliding 3 1) =\<gtr\> #(#(1 2) #(2)))

    (check ($ #(1 2 3 4 5) :sliding 3 2) =\<gtr\> #(#(1 2 3) #(3 4 5) #(5)))

    (check ($ #(1 2 3 4 5 6 7) :sliding 3 3) =\<gtr\> #(#(1 2 3) #(4 5 6) #(7)))

    (check ($ #(1 2 3 4 5) :sliding 5 1) =\<gtr\> #(#(1 2 3 4 5) #(2 3 4 5) #(3 4 5) #(4 5) #(5)))

    (check ($ #(1 2 3 4 5) :sliding 6 1) =\<gtr\> #(#(1 2 3 4 5) #(2 3 4 5) #(3 4 5) #(4 5) #(5)))

    \;

    ;; Error cases for step (two-arg)

    (check-catch 'value-error ($ #(1 2 3) :sliding 2 0))

    (check-catch 'value-error ($ #(1 2 3) :sliding 2 -1))

    (check-catch 'type-error ($ #(1 2 3) :sliding 2 1.5))

    (check-catch 'type-error ($ #(1 2 3) :sliding 2 "a"))

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-vector%zip-with-index>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%zip-with-index . args)

    \ \ (chain-apply args

    \ \ \ \ (let* ((n (vector-length data))

    \ \ \ \ \ \ \ \ \ \ \ (result (make-vector n)))

    \ \ \ \ \ \ (let loop ((idx 0))

    \ \ \ \ \ \ \ \ (if (\<gtr\>= idx n)

    \ \ \ \ \ \ \ \ \ \ \ \ (rich-vector result)

    \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector-set!\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ result\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ idx\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons idx (vector-ref data idx)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ idx 1))))))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check \ ($ #(a b c) :zip-with-index :collect) \ 

    \ \ \ \ \ \ \ \ =\<gtr\> #((0 . a) (1 . b) (2 . c)))

    \;

    (check \ ($ #() :zip-with-index :collect)\ 

    \ \ \ \ \ \ \ \ =\<gtr\> #())

    \;

    (check \ ($ #(1 1 2 2 2 3 4 5 6 7) :zip-with-index :collect)

    \ \ \ \ \ \ \ \ =\<gtr\> #((0 . 1) (1 . 1) (2 . 2) (3 . 2) (4 . 2) (5 . 3) (6 . 4) (7 . 5) (8 . 6) (9 . 7)))

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-vector%distinct>

  为富向量去重，返回值仍旧是富向量。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%distinct . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((ht (make-hash-table))

    \ \ \ \ \ \ \ \ \ \ (length (vector-length data)))

    \ \ \ \ \ \ (let loop ((result '())

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (index 0))

    \ \ \ \ \ \ \ \ (if (\<gtr\>= index length)

    \ \ \ \ \ \ \ \ \ \ \ \ (rich-vector (list-\<gtr\>vector (reverse result)))

    \ \ \ \ \ \ \ \ \ \ \ \ (let ((elem (vector-ref data index)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (eq? (hash-table-ref ht elem) #f)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (hash-table-set! ht elem #t)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (cons elem result) (+ index 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop result (+ index 1)))))))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check \ ($ #(a a b c b) :distinct :collect)\ 

    \ \ \ \ \ \ \ \ =\<gtr\> #(a b c))

    \;

    (check \ ($ #(1 1 1 2 2 3 3 3 3 5 5 5) :distinct :collect)\ 

    \ \ \ \ \ \ \ \ =\<gtr\> #(1 2 3 5))

    \;

    (check \ ($ #() :distinct :collect)\ 

    \ \ \ \ \ \ \ \ =\<gtr\> #())

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%reduce>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%reduce f)

    \ \ (let ((len (vector-length data)))

    \ \ \ \ (if (zero? len)

    \ \ \ \ \ \ \ \ (value-error "rich-vector%reduce: empty vector is not allowed to reduce")

    \ \ \ \ \ \ \ \ (let loop ((acc (vector-ref data 0))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (i 1))

    \ \ \ \ \ \ \ \ \ \ (if (\<gtr\>= i len)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ acc

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (f acc (vector-ref data i)) (+ i 1)))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #(1 2 3 4) :reduce +) =\<gtr\> 10) \ ; 1 + 2 + 3 + 4 = 10

    (check ($ #(5) :reduce *) =\<gtr\> 5) \ \ \ \ \ \ \ \ ; 单个元素直接返回

    (check-catch 'value-error ($ #() :reduce +)) ; 空向量应该报错

    (check ($ #(#(1 1) #(2 2) #(3 3) #(4 4) #(5 5))

    \ \ \ \ \ \ \ :map vector-length

    \ \ \ \ \ \ \ :reduce +)

    =\<gtr\> 10)

    (check ($ #(#(1 1) #(2 2) #(3 3) #(4 4) #(5 5))

    \ \ \ \ \ \ \ :map identity \ ; 保持子向量不变

    \ \ \ \ \ \ \ :reduce vector-append)

    \ \ \ \ \ \ \ =\<gtr\> #(1 1 2 2 3 3 4 4 5 5))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%index-where>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%index-where pred)

    \ \ (or (vector-index pred data)

    \ \ \ \ \ \ -1))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))))

    \ \ (check (vec :index-where even?) =\<gtr\> 1)

    \ \ (check (vec :index-where (@ \<gtr\> _ 3)) =\<gtr\> 3)

    \ \ (check (vec :index-where (@ \<gtr\> _ 5)) =\<gtr\> -1))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%last-index-where>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%last-index-where pred)

    \ \ (or (vector-index-right pred data)

    \ \ \ \ \ \ -1))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (array #(1 2 3 4 5))))

    \ \ (check (vec :last-index-where even?) =\<gtr\> 3)

    \ \ (check (vec :last-index-where (@ \<gtr\> _ 3)) =\<gtr\> 4)

    \ \ (check (vec :last-index-where (@ \<gtr\> _ 5)) =\<gtr\> -1))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%take-while>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%take-while pred . args)

    \ \ (chain-apply args

    \ \ \ \ (let* ((vec data)

    \ \ \ \ \ \ \ \ \ \ \ (len (vector-length vec))

    \ \ \ \ \ \ \ \ \ \ \ (idx (vector-index (lambda (x) (not (pred x))) vec)))

    \ \ \ \ \ \ (rich-vector (vector-copy vec 0 (or idx len))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #(2 4 6 7 8 9) :take-while even?) =\<gtr\> #(2 4 6))

    (check ($ #(1 3 5 7) :take-while odd?) =\<gtr\> #(1 3 5 7))

    (check ($ #() :take-while even?) =\<gtr\> #())

    (check ($ #(1 2 3 4) :take-while even?) =\<gtr\> #())

    (check ($ #(0 0 0 1 0) :take-while zero?) =\<gtr\> #(0 0 0))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%max-by>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%max-by f)

    \ \ (when (not (procedure? f))

    \ \ \ \ (type-error "rich-vector%max-by: f must be a procedure"))

    \ \ 

    \ \ (let ((vec data)

    \ \ \ \ \ \ \ \ (len (length data)))

    \ \ \ \ (if (zero? len)

    \ \ \ \ \ \ \ \ (value-error "rich-vector%max-by: empty list is not allowed")

    \ \ \ \ \ \ \ \ (let loop ((i 1)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (max-elem (vector-ref vec 0))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (max-val (f (vector-ref vec 0))))

    \ \ \ \ \ \ \ \ \ \ (if (\<gtr\>= i len)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ max-elem

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let* ((current-elem (vector-ref vec i))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (current-val (f current-elem)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (unless (number? current-val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "f must return a number"))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (\<less\> current-val max-val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) max-elem max-val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) current-elem current-val))))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #(1 2 3 4 5) :max-by identity) =\<gtr\> 5)

    (check ($ #("apple" "banana" "pear") :max-by string-length) =\<gtr\> "banana")

    (check-catch 'value-error ($ #() :max-by identity))

    (check-catch 'type-error ($ #(1 2 3) :max-by "not-a-function"))

    (check-catch 'type-error ($ #(1 2 3) :max-by (lambda (x) "not-a-number")))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%min-by>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%min-by f)

    \ \ (when (not (procedure? f))

    \ \ \ \ (type-error "rich-vector%min-by: f must be a procedure"))

    \;

    \ \ (let ((vec data)

    \ \ \ \ \ \ \ \ (len (length data)))

    \ \ \ \ (if (zero? len)

    \ \ \ \ \ \ \ \ (value-error "rich-vector%min-by: empty list is not allowed")

    \ \ \ \ \ \ \ \ (let loop ((i 1)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (min-elem (vector-ref vec 0))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (min-val (f (vector-ref vec 0))))

    \ \ \ \ \ \ \ \ \ \ (if (\<gtr\>= i len)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ min-elem

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let* ((current-elem (vector-ref vec i))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (current-val (f current-elem)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (unless (number? current-val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "f must return a number"))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (\<gtr\> current-val min-val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) min-elem min-val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) current-elem current-val))))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #(1 2 3 4 5) :min-by identity) =\<gtr\> 1)

    (check ($ #("apple" "banana" "pear") :min-by string-length) =\<gtr\> "pear")

    (check-catch 'value-error ($ #() :min-by identity))

    (check-catch 'type-error ($ #(1 2 3) :min-by "not-a-function"))

    (check-catch 'type-error ($ #(1 2 3) :min-by (lambda (x) "not-a-number")))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%max-by-option>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%max-by-option f)

    \ \ (when (not (procedure? f))

    \ \ \ \ (type-error "rich-vector%max-by-option: f must be a procedure"))

    \;

    \ \ (if (zero? (vector-length data))

    \ \ \ \ \ \ (none)

    \ \ \ \ \ \ (option (%max-by f))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #() :max-by-option identity) =\<gtr\> (none))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%min-by-option>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%min-by-option f)

    \ \ (when (not (procedure? f))

    \ \ \ \ (type-error "rich-vector%min-by-option: f must be a procedure"))

    \;

    \ \ (if (zero? (vector-length data))

    \ \ \ \ \ \ (none)

    \ \ \ \ \ \ (option (%min-by f))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check ($ #() :min-by-option identity) =\<gtr\> (none))

    \;
  </goldfish-chunk>

  <section|转换器>

  <paragraph|rich-vector%to-string>

  将富向量转换为基础类型的字符串。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-string)

    \ \ ((%map object-\<gtr\>string)

    \ \ \ :make-string "#(" " " ")"))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (object-\<gtr\>string ($ #(1 2 3))) =\<gtr\> "#(1 2 3)")

    \;

    (let ((vec ($ #("Hello" "World"))))

    \ \ (check (vec :to-string) =\<gtr\> "#(\\"Hello\\" \\"World\\")"))

    \;

    (let ((vec ($ #())))

    \ \ (check (vec :to-string) =\<gtr\> "#()"))

    \;

    (let ((vec ($ "test123 你好" :to-rich-vector)))

    \ \ (check (vec :to-string) =\<gtr\> "#(#\\\\t #\\\\e #\\\\s #\\\\t #\\\\1 #\\\\2 #\\\\3 #\\\\space #\\\\你 #\\\\好)"))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%make-string>

  <\scm-chunk|goldfish/liii/lang.scm|true|true>
    (define (%make-string . xs)

    \ \ (define (parse-args xs)

    \ \ \ \ (cond

    \ \ \ \ \ \ ((null? xs) (values "" "" ""))

    \ \ \ \ \ \ ((length=? 1 xs)

    \ \ \ \ \ \ \ (let1 sep (car xs)

    \ \ \ \ \ \ \ \ \ (if (string? sep)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (values "" sep "")

    \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "rich-vector%make-string: separator must be a string" sep))))

    \ \ \ \ \ \ ((length=? 2 xs)

    \ \ \ \ \ \ \ (error 'wrong-number-of-args "rich-vector%make-string: expected 0, 1, or 3 arguments, but got 2" xs))

    \ \ \ \ \ \ ((length=? 3 xs)

    \ \ \ \ \ \ \ (let ((start (car xs))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (sep (cadr xs))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (end (caddr xs)))

    \ \ \ \ \ \ \ \ \ (if (and (string? start) (string? sep) (string? end))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (values start sep end)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (type-error "rich-vector%make-string: prefix, separator, and suffix must be strings" xs))))

    \ \ \ \ \ \ (else (error 'wrong-number-of-args "rich-vector%make-string: expected 0, 1, or 3 arguments" xs))))

    \;

    \ \ (receive (start sep end) (parse-args xs)

    \ \ \ \ (let* ((as-string (lambda (x) (if (string? x) x (object-\<gtr\>string x))))

    \ \ \ \ \ \ \ \ \ \ \ (middle (string-join (map as-string (vector-\<gtr\>list data)) sep)))

    \ \ \ \ \ \ (string-append start middle end))))

    \;
  </scm-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 v ($ #(1 2 3))

    \ \ (check (v :count) =\<gtr\> 3)

    \ \ (check (v :count (cut \<gtr\> \<less\>\<gtr\> 1)) =\<gtr\> 2)

    \ \ (check (v :make-string) =\<gtr\> "123")

    \ \ (check (v :make-string " ") =\<gtr\> "1 2 3")

    \ \ (check (v :make-string "[" "," "]") =\<gtr\> "[1,2,3]")

    \ \ 

    \ \ (check-catch 'wrong-number-of-args (v :make-string "[" ","))

    \ \ (check-catch 'type-error (v :make-string 123 "," "]"))

    \ \ (check-catch 'type-error (v :make-string "[" 123 "]"))

    \ \ (check-catch 'type-error (v :make-string "[" "," 123))

    )

    \;

    (check ($ #("a" "b" "c") :make-string) =\<gtr\> "abc")

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%to-list>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-list)

    \ \ (vector-\<gtr\>list data))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (rich-vector #(1 2 3))))

    \ \ (check (vec :to-list) =\<gtr\> '(1 2 3)))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%to-rich-list>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%to-rich-list)

    \ \ (rich-list (vector-\<gtr\>list data)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((vec (rich-vector #(1 2 3))))

    \ \ (check (vec :to-rich-list) =\<gtr\> (rich-list '(1 2 3)))

    \ \ (check ((vec :to-rich-list) :collect) =\<gtr\> '(1 2 3)))

    \;
  </goldfish-chunk>

  <section|修改器>

  <paragraph|rich-vector%set!><index|rich-vector%set!>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%set! i x)

    \ \ (when (or (\<less\> i 0) (\<gtr\>= i (length data)))

    \ \ \ \ (index-error "rich-vector%set! out of range at index" i))

    \ \ (vector-set! data i x))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 v ($ #(1 2 3))

    \ \ (v :set! 0 2)

    \ \ (check (v 0) =\<gtr\> 2)

    \ \ (check-catch 'index-error (v -1))

    \ \ (check-catch 'index-error (v 3)))

    \;

    (check-catch 'index-error (array :empty :set! 0 1))

    \;
  </goldfish-chunk>

  <paragraph|rich-vector%append><index|rich-vector%append>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%append v)

    \ \ (when (not (or (vector? v) (rich-vector :is-type-of v)))

    \ \ \ \ (type-error "rich-vector%append: input is not vector or rich-vector"))

    \ \ 

    \ \ (if (vector? v)

    \ \ \ \ \ \ (rich-vector (vector-append data v))

    \ \ \ \ \ \ (rich-vector (vector-append data (v :collect)))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (rich-vector :empty :append #(1)) =\<gtr\> #(1))

    (check (rich-vector :empty :append ($ #(1))) =\<gtr\> #(1))

    \;

    (check ($ #(1) :append #()) =\<gtr\> #(1))

    (check ($ #(1) :append (rich-vector :empty)) =\<gtr\> #(1))

    \;

    (check ($ #(1) :append #(2 3)) =\<gtr\> #(1 2 3))

    (check ($ #(1) :append ($ #(2 3))) =\<gtr\> #(1 2 3))

    \ \ \ \ \ \ \ 
  </goldfish-chunk>

  <section|结尾>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <section|array>

  在Scala语言中，和Rich Vector等价的数据结构是Array，我们这里为rich-vector设置一个名为array的别名。

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define array rich-vector)

    \;
  </goldfish-chunk>

  <chapter|富哈希表>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define-case-class rich-hash-table ((data hash-table?))

    \ \ (define (%collect) data)

    \;
  </goldfish-chunk>

  \;

  <section|静态方法>

  <paragraph|rich-hash-table@empty>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (chained-define (@empty)

    \ \ (rich-hash-table (make-hash-table)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (check (rich-hash-table :empty) =\<gtr\> ($ (hash-table)))

    (check (rich-hash-table :empty :collect) =\<gtr\> (hash-table))

    \;
  </goldfish-chunk>

  \;

  <section|选择器>

  <paragraph|rich-hash-table%find>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%find pred?)

    \ \ (define iter (make-iterator data))

    \ \ (let loop ((kv (iter)))

    \ \ \ \ (cond\ 

    \ \ \ \ \ \ \ \ ((eof-object? kv) (none))

    \ \ \ \ \ \ \ \ ((and (pair? kv) (pred? (car kv) (cdr kv))) (option kv))

    \ \ \ \ \ \ \ \ (else (loop (iter))))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 ht ($ (hash-table 'a 1 'b 2 'c 3))

    \ \ (check (ht :find (lambda (k v) (and (symbol? k) (even? v)))) =\<gtr\> (option (cons 'b 2)))

    \ \ (check ((ht :find (lambda (k v) (\<gtr\> v 4))) :empty?) =\<gtr\> #t))

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-hash-table%get><typehint|((k any?)) =\<gtr\> option?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%get k)

    \ \ (option (hash-table-ref/default data k '())))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 ht ($ (hash-table 'a 1 'b 2 'c 3))

    \ \ (check ((ht :get 'a) :get) =\<gtr\> 1)

    \ \ (check ((ht :get 'd) :empty?) =\<gtr\> #t))

    \;
  </goldfish-chunk>

  \;

  <section|删除器>

  <paragraph|rich-hash-table%remove><scm|><typehint|((k any?)) =\<gtr\> rich-hash-table>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%remove k)

    \ \ (rich-hash-table

    \ \ \ (let ((new (make-hash-table)))

    \ \ \ \ \ (hash-table-for-each

    \ \ \ \ \ \ (lambda (key val)

    \ \ \ \ \ \ \ (unless (equal? key k)

    \ \ \ \ \ \ \ \ (hash-table-set! new key val)))

    \ \ \ \ \ \ \ data)

    \ \ \ \ \ \ new)))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 ht1 ($ (hash-table 'a 1 'b 2 'c 3))

    \ \ (let1 ht2 (ht1 :remove 'b)

    \ \ \ \ (check-true \ (ht1 :contains 'b))

    \ \ \ \ (check-false (ht2 :contains 'b))

    \ \ \ \ (check ((ht2 :get 'c) :get) =\> 3)))

    \;
  </goldfish-chunk>

  <paragraph|rich-hash-table%remove!><typehint|((k any?)) =\<gtr\> rich-hash-table>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (chained-define (%remove! k)

    \ \ (hash-table-delete! data k)

    \ \ %this)

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 ht3 ($ (hash-table 'x 9 'y 8))

    \ \ (ht3 :remove! 'x)

    \ \ (check-false (ht3 :contains 'x))

    \ \ (check ((ht3 :get 'y) :get) =\> 8))

    \;
  </goldfish-chunk>

  <section|谓词>

  <paragraph|rich-hash-table%contains><typehint|((k any?)) =\<gtr\> boolean?>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%contains k)

    \ \ (hash-table-contains? data k))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 ht ($ (hash-table 'a 1 'b 2 'c 3))

    \ \ (check-true (ht :contains 'a))

    \ \ (check-false (ht :contains 'd)))

    \;
  </goldfish-chunk>

  <paragraph|rich-hash-table%forall>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%forall pred?)

    \ \ (let ((all-kv (map identity data)))

    \ \ \ \ (let loop ((kvs all-kv)) \ 

    \ \ \ \ \ \ (if (null? kvs)

    \ \ \ \ \ \ \ \ \ \ #t \ 

    \ \ \ \ \ \ \ \ \ \ (let ((kv (car kvs)))

    \ \ \ \ \ \ \ \ \ \ \ \ (if (pred? (car kv) (cdr kv))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (cdr kvs)) \ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ #f)))))) \ 

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 ht ($ (hash-table 'a 5 'b 8 'c 10 'd 12))

    \ \ \ \ (check (ht :forall (lambda (k v) (\<gtr\> v 4))) \ \ \ \ \ \ \ \ =\<gtr\> #t) \ 

    \ \ \ \ (check (ht :forall (lambda (k v) (\<less\> v 13))) \ \ \ \ \ \ \ =\<gtr\> #t) \ 

    \ \ \ \ (check (ht :forall (lambda (k v) (even? v))) \ \ \ \ \ \ =\<gtr\> #f) \ 

    \ \ 

    \ \ \ \ (check (ht :forall (lambda (k v) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (and (symbol? k) (\<gtr\> v 4)))) \ \ \ \ \ \ \ =\<gtr\> #t) \ 

    \;

    \ \ \ \ (check (ht :forall (lambda (k v) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (symbol? k))) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\<gtr\> #t) \ 

    \ \ 

    \ \ \ \ (check (ht :forall (lambda (k v) (eq? k v))) \ \ \ \ \ \ =\<gtr\> #f) \ 

    )

    \;

    (let1 ht-empty ($ (hash-table))

    \ \ \ \ (check (ht-empty :forall (lambda (k v) (string? v))) =\<gtr\> #t)

    )

    \;

    (let1 ht-mixed ($ (hash-table 'id 10 'score 85 3.14 "pi"))

    \ \ \ \ (check (ht-mixed :forall (lambda (k v) (number? v))) =\> #f)\ 

    \ \ \ \ (check (ht-mixed :forall (lambda (k v) (and (integer? v) (even? v)))) =\> #f)\ 

    )

    \;

    (let1 ht-fail ($ (hash-table 'valid 42 'invalid "string"))

    \ \ \ \ (check (ht-fail :forall (lambda (k v) (number? v))) \ \ \ =\<gtr\> #f)\ 

    \;

    \ \ \ \ (check (ht-fail :forall (lambda (k v)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (and (symbol? k) (number? v) (positive? v)))) =\<gtr\> #f)

    )

    \;

    ;; nested hash table test

    (let1 ht-nested ($ (hash-table\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 'a ($ (hash-table 'x 10))\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 'b ($ (hash-table 'y 20))))

    \ \ (check (ht-nested :forall\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (lambda (k sub-ht)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (sub-ht :forall (lambda (k v) (\<gtr\> v 9))))) =\<gtr\> #t)

    )

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-hash-table%exists>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%exists pred?)

    \ \ (define iter (make-iterator data))

    \ \ (let loop ((kv (iter)))

    \ \ \ \ (cond\ 

    \ \ \ \ \ \ \ \ ((eof-object? kv) #f)

    \ \ \ \ \ \ \ \ ((and (pair? kv) (pred? (car kv) (cdr kv))) #t)

    \ \ \ \ \ \ \ \ (else (loop (iter))))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let ((ht ($ (hash-table 'a 1 'b "2" 'c 3))))

    \ \ (check (ht :exists (lambda (k v) (string? v))) =\<gtr\> #t))

    \;

    (let ((ht ($ (hash-table "a" 1 'b 2 3 'c))))

    \ \ (check (ht :exists (lambda (k v) (number? k))) =\<gtr\> #t))

    \;

    (let ((ht ($ (hash-table))))

    \ \ (check (ht :exists (lambda (k v) #t)) =\<gtr\> #f))

    \;
  </goldfish-chunk>

  <section|高阶函数>

  <paragraph|rich-hash-table%map>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%map f . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((r (make-hash-table)))

    \ \ \ \ \ \ (hash-table-for-each

    \ \ \ \ \ \ \ \ \ (lambda (k v)

    \ \ \ \ \ \ \ \ \ \ \ (receive (k1 v1) (f k v)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (hash-table-set! r k1 v1)))

    \ \ \ \ \ \ \ \ \ data)

    \ \ \ \ \ \ (rich-hash-table r))))

    \;
  </goldfish-chunk>

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 ht ($ (hash-table 'a 1 'b 2 'c 3))

    \ \ (let1 r (ht :map (lambda (k v) (values k (+ v 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ :collect)

    \ \ \ \ (check (r 'a) =\<gtr\> 2)

    \ \ \ \ (check (r 'b) =\<gtr\> 3)

    \ \ \ \ (check (r 'c) =\<gtr\> 4)))

    \ \ \ \ \ \ 
  </goldfish-chunk>

  <paragraph|rich-hash-table%count>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%count pred)

    \ \ (hash-table-count pred data))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (define ht\ 

    \ \ ($ (hash-table 'a 2 'b 5 'c 8 'd 10 'e 1 'f "test" 'g -2)))

    \;

    (check (ht :count (lambda(k v) (and (number? v) (even? v)))) =\<gtr\> 4)

    (check (ht :count (lambda(k v) (and (number? v) (odd? v)))) =\<gtr\> 2)

    \;
  </goldfish-chunk>

  \;

  <paragraph|rich-hash-table%for-each>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%for-each proc)

    \ \ (hash-table-for-each proc data))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let \ ((ht ($ (hash-table 'x 10 'y 20 'z 30 'new 40))) \ \ \ \ 

    \ \ \ \ \ \ (sum 0)) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ (ht :for-each (lambda (k v)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (set! sum (+ sum v)))) \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ (check sum =\<gtr\> 100) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    )

    \;

    ;; Empty hash table

    (let ((ht ($ (make-hash-table))) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ \ \ \ \ (call-counter 0)) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ 

    \ \ (ht :for-each (lambda (k v)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (set! call-counter (+ call-counter 1))))

    \ \ 

    \ \ (check call-counter =\<gtr\> 0) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    )

    \;

    ;; Nested hash tables

    (let* ((inner ($ (hash-table 'x 100 'y 200))) \ \ \ \ \ 

    \ \ \ \ \ \ \ (outer ($ (hash-table 'a inner 'b 42))) \ \ \ \ 

    \ \ \ \ \ \ \ (total 0)) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    \ \ 

    \ \ (outer :for-each\ 

    \ \ \ \ (lambda (k v)

    \ \ \ \ \ \ (if (case-class? v)

    \ \ \ \ \ \ \ \ (v \ :for-each

    \ \ \ \ \ \ \ \ \ \ \ \ (lambda (k v)

    \ \ \ \ \ \ \ \ \ \ \ \ (set! total (+ total v))))

    \ \ \ \ \ \ \ \ (set! total (+ total v)))))

    \ \ 

    \ \ (check total =\<gtr\> 342) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 

    )

    \;
  </goldfish-chunk>

  <paragraph|rich-hash-table%filter>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    (define (%filter f . args)

    \ \ (chain-apply args

    \ \ \ \ (let ((r (make-hash-table)))

    \ \ \ \ \ \ (hash-table-for-each

    \ \ \ \ \ \ \ \ \ (lambda (k v)

    \ \ \ \ \ \ \ \ \ \ \ (when (f k v) (hash-table-set! r k v)))

    \ \ \ \ \ \ \ \ \ data)

    \ \ \ \ \ \ (rich-hash-table r))))

    \;
  </goldfish-chunk>

  \;

  <\goldfish-chunk|tests/goldfish/liii/lang-test.scm|true|true>
    (let1 ht ($ (hash-table 'a 1 'b 2 'c 3))

    \ \ (let1 r (ht :filter (lambda (k v) (even? v)) :collect)

    \ \ \ \ (check r =\<gtr\> (hash-table 'b 2))))

    \;
  </goldfish-chunk>

  <section|结尾>

  <\goldfish-chunk|goldfish/liii/lang.scm|true|true>
    )

    \;
  </goldfish-chunk>

  <chapter|(liii lang)模块的结尾>

  <\scm-chunk|goldfish/liii/lang.scm|true|false>
    ) ; end of begin

    ) ; end of library

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/lang-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>
</body>

<\initial>
  <\collection>
    <associate|font-base-size|12>
    <associate|page-height|auto>
    <associate|page-orientation|landscape>
    <associate|page-screen-margin|false>
    <associate|page-type|a4>
    <associate|page-width|auto>
    <associate|save-aux|false>
  </collection>
</initial>
